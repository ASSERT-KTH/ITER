bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  [CE]  <identifier>  expected  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  <identifier>  expected	3	None	replace
2	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  jsonAdapterPresent)  {  [CE]  cannot  find  symbol  serializedName  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  cannot  find  symbol  serializedName	3	None	replace
3	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  mapped,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]        NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  mapped,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  mapped,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	3	None	replace
4	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]          NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	3	None	replace
5	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  [CE]  incompatible  types  [FE]            NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  incompatible  types	3	None	replace
6	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]              NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	3	None	replace
7	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	3	None	replace
8	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  [CE]  <identifier>  expected  [FE]    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    	non-compiled	[CE]  <identifier>  expected	15	None	replace
9	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  serialize)  {  [CE]  <identifier>  expected  [FE]      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  serialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  serialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    	non-compiled	[CE]  <identifier>  expected	15	None	replace
10	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  serialize)  {  [CE]  incompatible  types  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  serialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  serialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    	non-compiled	[CE]  incompatible  types	15	None	replace
11	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  [CE]  incompatible  types  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    	non-compiled	[CE]  incompatible  types	15	None	replace
12	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  mapped,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  mapped,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  mapped,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	15	None	replace
13	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	7	None	replace
14	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	7	None	replace
15	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  jsonAdapterPresent)  {  [CE]  <identifier>  expected  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  <identifier>  expected	7	None	replace
16	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  serialize,  deserialize,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  serialize,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  serialize,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	7	None	replace
17	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize,  jsonAdapterPresent)  {  [CE]  cannot  find  symbol  type  [FE]                          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  cannot  find  symbol  type	7	None	replace
18	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  jsonAdapterPresent)  {  [CE]  <identifier>  expected  [FE]                            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  <identifier>  expected	7	None	replace
19	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize,  jsonAdapterPresent)  {  [CE]  <identifier>  expected  [FE]                              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  <identifier>  expected	7	None	replace
20	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  isPrimitive)  {  [CE]  cannot  find  symbol  serializedName  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	non-compiled	[CE]  cannot  find  symbol  serializedName	13	None	replace
21	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  [CE]  <identifier>  expected  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	non-compiled	[CE]  <identifier>  expected	13	None	replace
22	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]        NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	13	None	replace
23	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  [CE]  incompatible  types  [FE]          NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	non-compiled	[CE]  incompatible  types	13	None	replace
24	[BUG]  [BUGGY]  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [CE]  ';'  expected  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);	      	non-compiled	[CE]  ';'  expected	9	None	replace
25	[BUG]  [BUGGY]  final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [CE]  ';'  expected  [FE]                        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);	      	non-compiled	[CE]  ';'  expected	9	None	replace
26	[BUG]  [BUGGY]  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  [CE]  ';'  expected  [FE]                          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);	      	non-compiled	[CE]  ';'  expected	9	None	replace
27	[BUG]  [BUGGY]  final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  [CE]  ';'  expected  [FE]                            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);	      	non-compiled	[CE]  ';'  expected	9	None	replace
28	[BUG]  [BUGGY]  final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);  [CE]  ';'  expected  [FE]                              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);	      	non-compiled	[CE]  ';'  expected	9	None	replace
29	[BUG]  [BUGGY]  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);  [CE]  ';'  expected  [FE]                                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);	      	non-compiled	[CE]  ';'  expected	9	None	replace
30	[BUG]  [BUGGY]  final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType);  [CE]  ';'  expected  [FE]                                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  TypeAdapter  <?>  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType);	      	non-compiled	[CE]  ';'  expected	9	None	replace
31	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  serialize,  deserialize)  {  [CE]  cannot  find  symbol  type  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(type,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(value,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  type	11	None	replace
32	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  jsonAdapterPresent)  {  [CE]  cannot  find  symbol  value  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(value,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  value	11	None	replace
33	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize)  {  [CE]  <identifier>  expected  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(value,    serialize,    deserialize)    {    	non-compiled	[CE]  <identifier>  expected	11	None	replace
34	[BUG]  [BUGGY]  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  [CE]  missing  return  statement  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(value,    serialize,    deserialize)    {    	non-compiled	[CE]  missing  return  statement	11	None	replace
35	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize)  {  [CE]  cannot  find  symbol  serializedName  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize)  {	  final    ReflectiveTypeAdapterFactory    factory    =    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  serializedName	4	None	replace
36	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize)  {	  final    ReflectiveTypeAdapterFactory    factory    =    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	4	None	replace
37	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {	  final    ReflectiveTypeAdapterFactory    factory    =    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	4	None	replace
38	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldType,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldType,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldType,  deserialize)  {	  final    ReflectiveTypeAdapterFactory    factory    =    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	4	None	replace
39	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize)  {  [CE]  cannot  find  symbol  type  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize)  {	  final    ReflectiveTypeAdapterFactory    factory    =    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  type	4	None	replace
40	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter,  deserialize)  {	  final    ReflectiveTypeAdapterFactory    factory    =    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	4	None	replace
41	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize)  {	  final    ReflectiveTypeAdapterFactory    factory    =    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	4	None	replace
42	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  field,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  field,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  field,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	6	None	replace
43	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  jsonAdapterPresent,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  jsonAdapterPresent,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  jsonAdapterPresent,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	6	None	replace
44	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize)  {  [CE]  <identifier>  expected  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  <identifier>  expected	6	None	replace
45	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  typeAdapter,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  typeAdapter,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  typeAdapter,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	6	None	replace
46	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	6	None	replace
47	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	6	None	replace
48	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  field,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  field,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  field,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	6	None	replace
49	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);  [CE]  <identifier>  expected  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);	  	non-compiled	[CE]  <identifier>  expected	2	None	add
50	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructor,  context,  fieldType,  jsonAdapterPresent);  [CE]  <identifier>  expected  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructor,  context,  fieldType,  jsonAdapterPresent);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    mapped  =  getTypeAdapter(constructor,  context,  fieldType,  jsonAdapterPresent);	  	non-compiled	[CE]  <identifier>  expected	2	None	add
51	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize);  [CE]  <identifier>  expected  [FE]        NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize);	  	non-compiled	[CE]  <identifier>  expected	2	None	add
52	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  serialize,  jsonAdapterPresent);  [CE]  <identifier>  expected  [FE]          NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  serialize,  jsonAdapterPresent);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  serialize,  jsonAdapterPresent);	  	non-compiled	[CE]  <identifier>  expected	2	None	add
53	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  ConstructorConstructor  constructor  =  context.getConstructor(fieldType);  [CE]  illegal  start  of  type  [FE]            NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  ConstructorConstructor  constructor  =  context.getConstructor(fieldType);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    ConstructorConstructor  constructor  =  context.getConstructor(fieldType);	  	non-compiled	[CE]  illegal  start  of  type	2	None	add
54	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  JsonReader  reader  =  context.getJsonReader();  [CE]  illegal  start  of  type  [FE]              NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  JsonReader  reader  =  context.getJsonReader();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    JsonReader  reader  =  context.getJsonReader();	  	non-compiled	[CE]  illegal  start  of  type	2	None	add
55	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  ConstructorConstructor  constructor  =  field.getConstructor();  [CE]  illegal  start  of  type  [FE]                NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  ConstructorConstructor  constructor  =  field.getConstructor();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    ConstructorConstructor  constructor  =  field.getConstructor();	  	non-compiled	[CE]  illegal  start  of  type	2	None	add
56	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType);  [CE]  <identifier>  expected  [FE]                  NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType);	  	non-compiled	[CE]  <identifier>  expected	2	None	add
57	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	10	None	replace
58	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {  [CE]  <identifier>  expected  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  <identifier>  expected	10	None	replace
59	[BUG]  [BUGGY]  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	10	None	replace
60	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  serialize,  deserialize)  {  [CE]  <identifier>  expected  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  <identifier>  expected	10	None	replace
61	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  field,  name,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  field,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  field,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	10	None	replace
62	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  serialize,  deserialize)  {  [CE]  <identifier>  expected  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  <identifier>  expected	10	None	replace
63	[BUG]  [BUGGY]  ConstructorFactory.BoundField(context,  name,  serialize,  deserialize)  {  [CE]  ';'  expected  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  ConstructorFactory.BoundField(context,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	ConstructorFactory.BoundField(context,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  ';'  expected	10	None	replace
64	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serializedName,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	1	None	replace
65	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serializedName,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	1	None	replace
66	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapterPresent,  deserialize)  {  [CE]  cannot  find  symbol  typeAdapterPresent  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapterPresent,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapterPresent,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serializedName,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  typeAdapterPresent	1	None	replace
67	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  name,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  name,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  name,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serializedName,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	1	None	replace
68	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize,  name)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize,  name)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize,  name)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	16	None	replace
69	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  fieldType)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  fieldType)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  fieldType)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	16	None	replace
70	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  serialize)  {  [CE]  <identifier>  expected  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  serialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  serialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  <identifier>  expected	16	None	replace
71	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  serialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  serialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  serialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	16	None	replace
72	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize,  name)  {  [CE]  <identifier>  expected  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize,  name)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize,  name)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  <identifier>  expected	16	None	replace
73	[BUG]  [BUGGY]  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize,  name)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize,  name)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize,  name)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	16	None	replace
74	[BUG]  [BUGGY]  mapped  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  serialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  mapped  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  serialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	mapped  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  serialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	16	None	replace
75	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  isPrimitive)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	8	None	replace
76	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  isPrimitive)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	8	None	replace
77	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  isPrimitive)  {  [CE]  <identifier>  expected  [FE]                        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  <identifier>  expected	8	None	replace
78	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize,  isPrimitive)  {  [CE]  cannot  find  symbol  serializedName  [FE]                          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  cannot  find  symbol  serializedName	8	None	replace
79	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize,  isPrimitive)  {  [CE]  cannot  find  symbol  type  [FE]                            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  cannot  find  symbol  type	8	None	replace
80	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  fieldType,  isPrimitive)  {  [CE]  <identifier>  expected  [FE]                              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  fieldType,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  fieldType,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  <identifier>  expected	8	None	replace
81	[BUG]  [BUGGY]  mapped  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  fieldType,  isPrimitive)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  mapped  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  fieldType,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	mapped  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  fieldType,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	8	None	replace
82	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  typeAdapter)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	17	None	replace
83	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  typeAdapter)  {  [CE]  <identifier>  expected  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  <identifier>  expected	17	None	replace
84	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  typeAdapter)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  serialize,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	17	None	replace
85	[BUG]  [BUGGY]  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  typeAdapter)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serialize,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	17	None	replace
86	[BUG]  [BUGGY]  ConstructorFactory.BoundField(context,  name,  serialize,  deserialize,  typeAdapter)  {  [CE]  ';'  expected  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  ConstructorFactory.BoundField(context,  name,  serialize,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	ConstructorFactory.BoundField(context,  name,  serialize,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  ';'  expected	17	None	replace
87	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  serialize,  deserialize,  typeAdapter)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  serialize,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  serialize,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	17	None	replace
88	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  deserialize,  serialize)  {  [CE]  <identifier>  expected  [FE]                        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  deserialize,  serialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  deserialize,  serialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  <identifier>  expected	17	None	replace
89	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  isPrimitive);  [CE]  <identifier>  expected  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  isPrimitive);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  isPrimitive);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
90	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize);  [CE]  <identifier>  expected  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
91	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructor,  context,  fieldType,  isPrimitive);  [CE]  <identifier>  expected  [FE]        NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructor,  context,  fieldType,  isPrimitive);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructor,  context,  fieldType,  isPrimitive);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
92	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(typeAdapter,  context,  fieldType,  isPrimitive);  [CE]  <identifier>  expected  [FE]          NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(typeAdapter,  context,  fieldType,  isPrimitive);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(typeAdapter,  context,  fieldType,  isPrimitive);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
93	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [CE]  <identifier>  expected  [FE]            NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
94	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  deserialize);  [CE]  <identifier>  expected  [FE]              NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  deserialize);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  deserialize);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
95	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  ConstructorConstructor  constructor  =  field.getConstructor();  [CE]  illegal  start  of  type  [FE]                NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  ConstructorConstructor  constructor  =  field.getConstructor();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    ConstructorConstructor  constructor  =  field.getConstructor();	  	non-compiled	[CE]  illegal  start  of  type	12	None	add
96	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructor,  context,  fieldType,  serialize);  [CE]  <identifier>  expected  [FE]                  NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructor,  context,  fieldType,  serialize);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructor,  context,  fieldType,  serialize);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
97	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize)  {  [CE]  <identifier>  expected  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  serializedName,  deserialize)  {	  final    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  <identifier>  expected	5	None	replace
98	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize)  {  [CE]  <identifier>  expected  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize)  {	  final    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  <identifier>  expected	5	None	replace
99	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  deserialize);  [CE]  <identifier>  expected  [FE]    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  deserialize);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  deserialize);	  	non-compiled	[CE]  <identifier>  expected	14	None	add
100	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonAdapter.class);  [CE]  illegal  start  of  type  [FE]      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonAdapter.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    ObjectConstructor  constructor  =  field.getAnnotation(JsonAdapter.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
101	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Constructor  constructor  =  field.getAnnotation(JsonAdapter.class);  [CE]  illegal  start  of  type  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Constructor  constructor  =  field.getAnnotation(JsonAdapter.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    Constructor  constructor  =  field.getAnnotation(JsonAdapter.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
102	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  deserialize);  [CE]  <identifier>  expected  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  deserialize);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  deserialize);	  	non-compiled	[CE]  <identifier>  expected	14	None	add
103	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Constructor  constructor  =  field.getConstructor(JsonAdapter.class);  [CE]  illegal  start  of  type  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Constructor  constructor  =  field.getConstructor(JsonAdapter.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    Constructor  constructor  =  field.getConstructor(JsonAdapter.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
104	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Constructor  constructor  =  field.getConstructor(JsonFactory.class);  [CE]  illegal  start  of  type  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Constructor  constructor  =  field.getConstructor(JsonFactory.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    Constructor  constructor  =  field.getConstructor(JsonFactory.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
105	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Constructor  constructor  =  field.getConstructor(JsonReader.class);  [CE]  illegal  start  of  type  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Constructor  constructor  =  field.getConstructor(JsonReader.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    Constructor  constructor  =  field.getConstructor(JsonReader.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
106	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Constructor  constructor  =  field.getConstructor();  [CE]  illegal  start  of  type  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Constructor  constructor  =  field.getConstructor();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    Constructor  constructor  =  field.getConstructor();	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
107	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  field,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  field,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  field,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	6	None	replace
108	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(writer,  field,  serialize,  deserialize)  {  [CE]  cannot  find  symbol  writer  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(writer,  field,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(writer,  field,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  writer	6	None	replace
109	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  isPrimitive)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	13	None	replace
110	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  serialize,  isPrimitive)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  serialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  serialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	13	None	replace
111	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]        NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	13	None	replace
112	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize,  jsonAdapterPresent);  [CE]  <identifier>  expected  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize,  jsonAdapterPresent);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize,  jsonAdapterPresent);	  	non-compiled	[CE]  <identifier>  expected	2	None	add
113	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonAdapter.class);  [CE]  illegal  start  of  type  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonAdapter.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    ObjectConstructor  constructor  =  field.getAnnotation(JsonAdapter.class);	  	non-compiled	[CE]  illegal  start  of  type	2	None	add
114	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonFactory.class);  [CE]  illegal  start  of  type  [FE]        NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonFactory.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    ObjectConstructor  constructor  =  field.getAnnotation(JsonFactory.class);	  	non-compiled	[CE]  illegal  start  of  type	2	None	add
115	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [CE]  <identifier>  expected  [FE]          NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);	  	non-compiled	[CE]  <identifier>  expected	2	None	add
116	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize)  {  [CE]  cannot  find  symbol  value  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize)  {	  final    ReflectiveTypeAdapterFactory    factory    =    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  value	4	None	replace
117	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize,  isPrimitive)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	8	None	replace
118	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  isPrimitive)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	8	None	replace
119	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize,  isPrimitive)  {  [CE]  cannot  find  symbol  value  [FE]                        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  cannot  find  symbol  value	8	None	replace
120	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  typeAdapter,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	10	None	replace
121	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(compiler,  name,  serialize,  deserialize)  {  [CE]  cannot  find  symbol  compiler  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(compiler,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(compiler,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  compiler	10	None	replace
122	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  name,  serialize,  deserialize)  {  [CE]  cannot  find  symbol  value  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(value,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  value	10	None	replace
123	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serializedName,  deserialize)  {  [CE]  cannot  find  symbol  serializedName  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serializedName,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  serializedName,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  serializedName	10	None	replace
124	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldType,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldType,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldType,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	3	None	replace
125	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  serialize,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  serialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  serialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	3	None	replace
126	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	16	None	replace
127	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  name)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  name)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  name)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	16	None	replace
128	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  deserialize,  name)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  deserialize,  name)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  deserialize,  name)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	16	None	replace
129	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize)  {  [CE]  cannot  find  symbol  type  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  cannot  find  symbol  type	16	None	replace
130	[BUG]  [BUGGY]  if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  [CE]  ';'  expected  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }	      	non-compiled	[CE]  ';'  expected	9	None	replace
131	[BUG]  [BUGGY]  if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  else  {  throw  new  IllegalArgumentException( " ");  }  [CE]  ';'  expected  [FE]                        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  else  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  else  {  throw  new  IllegalArgumentException( " ");  }	      	non-compiled	[CE]  ';'  expected	9	None	replace
132	[BUG]  [BUGGY]  if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  else  {  mapped  =  new  TypeAdapterRuntimeTypeWrapper(context,  fieldType,  typeAdapter);  }  [CE]  ';'  expected  [FE]                          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  else  {  mapped  =  new  TypeAdapterRuntimeTypeWrapper(context,  fieldType,  typeAdapter);  }  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  else  {  mapped  =  new  TypeAdapterRuntimeTypeWrapper(context,  fieldType,  typeAdapter);  }	      	non-compiled	[CE]  ';'  expected	9	None	replace
133	[BUG]  [BUGGY]  if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  else  {  throw  new  IllegalStateException( " ");  }  [CE]  ';'  expected  [FE]                            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  else  {  throw  new  IllegalStateException( " ");  }  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  }  else  {  throw  new  IllegalStateException( " ");  }	      	non-compiled	[CE]  ';'  expected	9	None	replace
134	[BUG]  [BUGGY]  if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  }  [CE]  ';'  expected  [FE]                              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  }  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	if(jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  }	      	non-compiled	[CE]  ';'  expected	9	None	replace
135	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize,  typeAdapter)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	17	None	replace
136	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  typeAdapter)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	17	None	replace
137	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  serialize,  deserialize,  name)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  serialize,  deserialize,  name)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  serialize,  deserialize,  name)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	17	None	replace
138	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  typeAdapter)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	17	None	replace
139	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  deserialize,  typeAdapter)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	17	None	replace
140	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  [CE]  <identifier>  expected  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
141	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  serialize,  isPrimitive);  [CE]  <identifier>  expected  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  serialize,  isPrimitive);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  serialize,  isPrimitive);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
142	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  JsonWriter  writer  =  context.getJsonWriter();  [CE]  illegal  start  of  type  [FE]        NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  JsonWriter  writer  =  context.getJsonWriter();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    JsonWriter  writer  =  context.getJsonWriter();	  	non-compiled	[CE]  illegal  start  of  type	12	None	add
143	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  JsonReader  reader  =  context.getJsonReader();  [CE]  illegal  start  of  type  [FE]          NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  JsonReader  reader  =  context.getJsonReader();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    JsonReader  reader  =  context.getJsonReader();	  	non-compiled	[CE]  illegal  start  of  type	12	None	add
144	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  serialize);  [CE]  <identifier>  expected  [FE]            NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  serialize);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  serialize);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
145	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  JsonReader  writer  =  context.getJsonReader();  [CE]  illegal  start  of  type  [FE]    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  JsonReader  writer  =  context.getJsonReader();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    JsonReader  writer  =  context.getJsonReader();	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
146	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonFactory.class);  [CE]  illegal  start  of  type  [FE]      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonFactory.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    ObjectConstructor  constructor  =  field.getAnnotation(JsonFactory.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
147	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonReader.class);  [CE]  illegal  start  of  type  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonReader.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    ObjectConstructor  constructor  =  field.getAnnotation(JsonReader.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
148	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  TypeToken  type  =  field.getType();  [CE]  illegal  start  of  type  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  TypeToken  type  =  field.getType();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    TypeToken  type  =  field.getType();	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
149	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonToken.class);  [CE]  illegal  start  of  type  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonToken.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    ObjectConstructor  constructor  =  field.getAnnotation(JsonToken.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
150	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonLocation.class);  [CE]  illegal  start  of  type  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonLocation.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    ObjectConstructor  constructor  =  field.getAnnotation(JsonLocation.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
151	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonSourceFactory.class);  [CE]  illegal  start  of  type  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  ObjectConstructor  constructor  =  field.getAnnotation(JsonSourceFactory.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    ObjectConstructor  constructor  =  field.getAnnotation(JsonSourceFactory.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
152	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  jsonAdapterPresent,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  jsonAdapterPresent,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  name,  jsonAdapterPresent,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	15	None	replace
153	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  jsonAdapterPresent,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  jsonAdapterPresent,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  jsonAdapterPresent,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	15	None	replace
154	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  isPrimitive,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	add	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  isPrimitive,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serializedName,    deserialize)    {    	compilable	  [FE]  ComparisonFailure  	1	7	replace
155	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  isPrimitive,  deserialize)  {  [FE]  ComparisonFailure  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  isPrimitive,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  isPrimitive,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serializedName,    deserialize)    {    	compilable	  [FE]  ComparisonFailure  	1	7	replace
156	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(value,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	11	None	replace
157	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(jsonAdapterPresent,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(jsonAdapterPresent,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(jsonAdapterPresent,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(value,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	11	None	replace
158	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(serialize,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(serialize,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(serialize,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(value,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	11	None	replace
159	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize,  jsonAdapterPresent)  {  [CE]  cannot  find  symbol  value  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  cannot  find  symbol  value	7	None	replace
160	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldType,  deserialize,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldType,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldType,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	7	None	replace
161	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter)  {  [CE]  <identifier>  expected  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  typeAdapter)  {	  final    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  <identifier>  expected	5	None	replace
162	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Object  constructor  =  field.getAnnotation(JsonReader.class);  [CE]  illegal  start  of  type  [FE]    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  Object  constructor  =  field.getAnnotation(JsonReader.class);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    Object  constructor  =  field.getAnnotation(JsonReader.class);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
163	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  JsonReader  writer  =  context.getReader();  [CE]  illegal  start  of  type  [FE]      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  JsonReader  writer  =  context.getReader();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    JsonReader  writer  =  context.getReader();	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
164	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  TypeToken  <?>  type  =  field.getType();  [CE]  illegal  start  of  type  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  TypeToken  <?>  type  =  field.getType();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    TypeToken  <?>  type  =  field.getType();	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
165	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  JsonReader  writer  =  context.getReader(fieldType);  [CE]  illegal  start  of  type  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  JsonReader  writer  =  context.getReader(fieldType);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    JsonReader  writer  =  context.getReader(fieldType);	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
166	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  boolean  serialize  =  jsonAdapterPresent  ==  false;  [CE]  illegal  start  of  type  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  boolean  serialize  =  jsonAdapterPresent  ==  false;  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    boolean  serialize  =  jsonAdapterPresent  ==  false;	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
167	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  boolean  serialize  =  jsonAdapterPresent  ==  null;  [CE]  illegal  start  of  type  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  boolean  serialize  =  jsonAdapterPresent  ==  null;  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    boolean  serialize  =  jsonAdapterPresent  ==  null;	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
168	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  boolean  serialize  =  jsonAdapterPresent!=  null;  [CE]  illegal  start  of  type  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  boolean  serialize  =  jsonAdapterPresent!=  null;  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    boolean  serialize  =  jsonAdapterPresent!=  null;	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
169	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  JsonReader  reader  =  context.getReader();  [CE]  illegal  start  of  type  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  deserialize)  {  JsonReader  reader  =  context.getReader();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    JsonReader  reader  =  context.getReader();	  	non-compiled	[CE]  illegal  start  of  type	14	None	add
170	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  deserialize,  typeAdapter)  {  [CE]  cannot  find  symbol  type  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  deserialize,  typeAdapter)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  deserialize,  typeAdapter)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    typeAdapter)    {    	non-compiled	[CE]  cannot  find  symbol  type	17	None	replace
171	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  deserialize,  fieldType)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  deserialize,  fieldType)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  name,  deserialize,  fieldType)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	16	None	replace
172	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  deserialize,  fieldType)  {  [CE]  cannot  find  symbol  type  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  deserialize,  fieldType)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  deserialize,  fieldType)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    fieldType)    {    	non-compiled	[CE]  cannot  find  symbol  type	16	None	replace
173	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	add	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	compilable	  [FE]  ComparisonFailure  	13	8	replace
174	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  isPrimitive)  {  [FE]  ComparisonFailure  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	compilable	  [FE]  ComparisonFailure  	13	8	replace
175	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializer,  isPrimitive)  {  [CE]  cannot  find  symbol  serializer  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializer,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serializer,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	non-compiled	[CE]  cannot  find  symbol  serializer	13	None	replace
176	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  isPrimitive)  {  [CE]  cannot  find  symbol  value  [FE]        NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    	non-compiled	[CE]  cannot  find  symbol  value	13	None	replace
177	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize)  {	  final    ReflectiveTypeAdapterFactory    factory    =    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	4	None	replace
178	[BUG]  [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  ReflectiveTypeAdapterFactory  factory  =  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  serialize,  deserialize)  {	  final    ReflectiveTypeAdapterFactory    factory    =    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	4	None	replace
179	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  value,  deserialize)  {  [CE]  cannot  find  symbol  value  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  value,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  value,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serializedName,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  value	1	None	replace
180	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  isPrimitive)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	8	None	replace
181	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  deserialize,  isPrimitive)  {  [CE]  cannot  find  symbol  type  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  deserialize,  isPrimitive)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(type,  name,  deserialize,  isPrimitive)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    isPrimitive)    {    	non-compiled	[CE]  cannot  find  symbol  type	8	None	replace
182	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [CE]  ';'  expected  [FE]                      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);	      	non-compiled	[CE]  ';'  expected	9	None	replace
183	[BUG]  [BUGGY]  TypeToken  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [CE]  ';'  expected  [FE]                        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  TypeToken  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	TypeToken  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);	      	non-compiled	[CE]  ';'  expected	9	None	replace
184	[BUG]  [BUGGY]  mapped.put(fieldType,  typeAdapter);  [CE]  ';'  expected  [FE]                          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  mapped.put(fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	mapped.put(fieldType,  typeAdapter);	      	non-compiled	[CE]  ';'  expected	9	None	replace
185	[BUG]  [BUGGY]  final  TypeToken  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [CE]  ';'  expected  [FE]                            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  TypeToken  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  TypeToken  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  typeAdapter);	      	non-compiled	[CE]  ';'  expected	9	None	replace
186	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  [CE]  ';'  expected  [FE]                              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);	      	non-compiled	[CE]  ';'  expected	9	None	replace
187	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  typeAdapter,  name,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(context,  typeAdapter,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(context,  typeAdapter,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	10	None	replace
188	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  field,  name,  serialize,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  field,  name,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  field,  name,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	10	None	replace
189	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  field,  name,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  field,  name,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(typeAdapter,  field,  name,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(typeAdapter,    name,    serialize,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	10	None	replace
190	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  [CE]  <identifier>  expected  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter);	  	non-compiled	[CE]  <identifier>  expected	2	None	add
191	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  name,  jsonAdapterPresent);  [CE]  <identifier>  expected  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  name,  jsonAdapterPresent);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  name,  jsonAdapterPresent);	  	non-compiled	[CE]  <identifier>  expected	2	None	add
192	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter,  jsonAdapterPresent);  [CE]  <identifier>  expected  [FE]        NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  jsonAdapterPresent)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter,  jsonAdapterPresent);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter,  jsonAdapterPresent);	  	non-compiled	[CE]  <identifier>  expected	2	None	add
193	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  mapped,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  mapped,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  mapped,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	3	None	replace
194	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldValue,  jsonAdapterPresent)  {  [CE]  cannot  find  symbol  fieldValue  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldValue,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  fieldValue,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  cannot  find  symbol  fieldValue	3	None	replace
195	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize,  isPrimitive);  [CE]  <identifier>  expected  [FE]    NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize,  isPrimitive);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  serialize,  isPrimitive);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
196	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter,  isPrimitive);  [CE]  <identifier>  expected  [FE]      NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter,  isPrimitive);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  typeAdapter,  isPrimitive);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
197	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  name,  isPrimitive);  [CE]  <identifier>  expected  [FE]        NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  name,  isPrimitive);  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  name,  isPrimitive);	  	non-compiled	[CE]  <identifier>  expected	12	None	add
198	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  TypeToken  <?>  rawtypes  =  typeAdapter.getRawType();  [CE]  illegal  start  of  type  [FE]          NullPointerException    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  isPrimitive)  {  TypeToken  <?>  rawtypes  =  typeAdapter.getRawType();  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    isPrimitive)    {    TypeToken  <?>  rawtypes  =  typeAdapter.getRawType();	  	non-compiled	[CE]  illegal  start  of  type	12	None	add
199	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  writer)  {  [CE]  cannot  find  symbol  writer  [FE]                ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  writer)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serialize,  deserialize,  writer)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  writer	6	None	replace
200	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serializedName,  deserialize)  {  [CE]  cannot  find  symbol  serializedName  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serializedName,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  serializedName,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(field,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  serializedName	6	None	replace
201	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  typeAdapter,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  typeAdapter,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  jsonAdapterPresent,  typeAdapter,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	15	None	replace
202	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  jsonAdapterPresent,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]      ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  jsonAdapterPresent,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  jsonAdapterPresent,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	15	None	replace
203	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  jsonAdapterPresent,  deserialize)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]        ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  jsonAdapterPresent,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(fieldType,  jsonAdapterPresent,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    jsonAdapterPresent,    deserialize)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	15	None	replace
204	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                  ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(field,  name,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	7	None	replace
205	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  jsonAdapterPresent)  {  [CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;  [FE]                    ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  jsonAdapterPresent)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(name,  fieldType,  deserialize,  jsonAdapterPresent)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(name,    serialize,    deserialize,    jsonAdapterPresent)    {    	non-compiled	[CE]  constructor  BoundField  in  class  BoundField  cannot  be  applied  to  given  types;	7	None	replace
206	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(fieldValue,  serialize,  deserialize)  {  [CE]  cannot  find  symbol  fieldValue  [FE]          ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(fieldValue,  serialize,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(fieldValue,  serialize,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(value,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  fieldValue	11	None	replace
207	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  jsonAdapterPresent,  deserialize)  {  [CE]  cannot  find  symbol  value  [FE]            ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  jsonAdapterPresent,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(value,  jsonAdapterPresent,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(value,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  value	11	None	replace
208	[BUG]  [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serializedName,  deserialize)  {  [CE]  cannot  find  symbol  value  [FE]              ComparisonFailure    [CONTEXT]      JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);  final  TypeAdapter<?>  typeAdapter  =  mapped;    [BUGGY]  return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serializedName,  deserialize)  {  [BUGGY]    @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  throws  IOException,  IllegalAccessException  {  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	return  new  ReflectiveTypeAdapterFactory.BoundField(value,  serializedName,  deserialize)  {	  return    new    ReflectiveTypeAdapterFactory.BoundField(value,    serialize,    deserialize)    {    	non-compiled	[CE]  cannot  find  symbol  value	11	None	replace
