bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { [BUGGY] mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); [BUGGY] } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3779644730092272	111	111	1	replace	
2	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { [BUGGY] [BUGGY] mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3779644730092272	111	111	1	add	
3	[BUG] [BUGGY] FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { [FE] ComparisonFailure [CONTEXT] public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, [BUGGY] FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { [BUGGY] this.constructorConstructor = constructorConstructor; this.fieldNamingPolicy = fieldNamingPolicy; this.excluder = excluder; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] <init> [RETURN_TYPE] Excluder)  ConstructorConstructor constructorConstructor FieldNamingStrategy fieldNamingPolicy Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor boolean deserialized serialized ObjectConstructor constructor String name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	56	56	1	replace	
4	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, [BUGGY] [BUGGY] FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { this.constructorConstructor = constructorConstructor; this.fieldNamingPolicy = fieldNamingPolicy; this.excluder = excluder; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] <init> [RETURN_TYPE] Excluder)  ConstructorConstructor constructorConstructor FieldNamingStrategy fieldNamingPolicy Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor boolean deserialized serialized ObjectConstructor constructor String name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	56	56	1	add	
5	[BUG] [BUGGY] this.constructorConstructor = constructorConstructor; [FE] ComparisonFailure [CONTEXT] public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { [BUGGY] this.constructorConstructor = constructorConstructor; [BUGGY] this.fieldNamingPolicy = fieldNamingPolicy; this.excluder = excluder; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] <init> [RETURN_TYPE] Excluder)  ConstructorConstructor constructorConstructor FieldNamingStrategy fieldNamingPolicy Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor boolean deserialized serialized ObjectConstructor constructor String name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	57	57	1	replace	
6	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { [BUGGY] [BUGGY] this.constructorConstructor = constructorConstructor; this.fieldNamingPolicy = fieldNamingPolicy; this.excluder = excluder; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] <init> [RETURN_TYPE] Excluder)  ConstructorConstructor constructorConstructor FieldNamingStrategy fieldNamingPolicy Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor boolean deserialized serialized ObjectConstructor constructor String name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	57	57	1	add	
7	[BUG] [BUGGY] this.fieldNamingPolicy = fieldNamingPolicy; [FE] ComparisonFailure [CONTEXT] public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { this.constructorConstructor = constructorConstructor; [BUGGY] this.fieldNamingPolicy = fieldNamingPolicy; [BUGGY] this.excluder = excluder; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] <init> [RETURN_TYPE] Excluder)  ConstructorConstructor constructorConstructor FieldNamingStrategy fieldNamingPolicy Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor boolean deserialized serialized ObjectConstructor constructor String name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	58	58	1	replace	
8	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { this.constructorConstructor = constructorConstructor; [BUGGY] [BUGGY] this.fieldNamingPolicy = fieldNamingPolicy; this.excluder = excluder; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] <init> [RETURN_TYPE] Excluder)  ConstructorConstructor constructorConstructor FieldNamingStrategy fieldNamingPolicy Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor boolean deserialized serialized ObjectConstructor constructor String name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	58	58	1	add	
9	[BUG] [BUGGY] this.excluder = excluder; [FE] ComparisonFailure [CONTEXT] public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { this.constructorConstructor = constructorConstructor; this.fieldNamingPolicy = fieldNamingPolicy; [BUGGY] this.excluder = excluder; [BUGGY] } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] <init> [RETURN_TYPE] Excluder)  ConstructorConstructor constructorConstructor FieldNamingStrategy fieldNamingPolicy Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor boolean deserialized serialized ObjectConstructor constructor String name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	59	59	1	replace	
10	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { this.constructorConstructor = constructorConstructor; this.fieldNamingPolicy = fieldNamingPolicy; [BUGGY] [BUGGY] this.excluder = excluder; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] <init> [RETURN_TYPE] Excluder)  ConstructorConstructor constructorConstructor FieldNamingStrategy fieldNamingPolicy Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor boolean deserialized serialized ObjectConstructor constructor String name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	59	59	1	add	
11	[BUG] [BUGGY] } [FE] ComparisonFailure [CONTEXT] public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { this.constructorConstructor = constructorConstructor; this.fieldNamingPolicy = fieldNamingPolicy; this.excluder = excluder; [BUGGY] } [BUGGY]  [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] <init> [RETURN_TYPE] Excluder)  ConstructorConstructor constructorConstructor FieldNamingStrategy fieldNamingPolicy Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor boolean deserialized serialized ObjectConstructor constructor String name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	60	60	1	replace	
12	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder) { this.constructorConstructor = constructorConstructor; this.fieldNamingPolicy = fieldNamingPolicy; this.excluder = excluder; [BUGGY] [BUGGY] } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] <init> [RETURN_TYPE] Excluder)  ConstructorConstructor constructorConstructor FieldNamingStrategy fieldNamingPolicy Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor boolean deserialized serialized ObjectConstructor constructor String name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	60	60	1	add	
13	[BUG] [BUGGY] return excludeField(f, serialize, excluder); [FE] ComparisonFailure [CONTEXT] public boolean excludeField(Field f, boolean serialize) { [BUGGY] return excludeField(f, serialize, excluder); [BUGGY] } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] excludeField [RETURN_TYPE] boolean  Field f boolean serialize [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized ObjectConstructor constructor String $anonymous0 name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	63	63	1	replace	
14	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] public boolean excludeField(Field f, boolean serialize) { [BUGGY] [BUGGY] return excludeField(f, serialize, excluder); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] excludeField [RETURN_TYPE] boolean  Field f boolean serialize [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized ObjectConstructor constructor String $anonymous0 name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	63	63	1	add	
15	[BUG] [BUGGY] return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize); [FE] ComparisonFailure [CONTEXT] static boolean excludeField(Field f, boolean serialize, Excluder excluder) { [BUGGY] return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize); [BUGGY] } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] excludeField [RETURN_TYPE] boolean  Field f boolean serialize Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized ObjectConstructor constructor String $anonymous0 name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	67	67	1	replace	
16	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] static boolean excludeField(Field f, boolean serialize, Excluder excluder) { [BUGGY] [BUGGY] return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] excludeField [RETURN_TYPE] boolean  Field f boolean serialize Excluder excluder [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized ObjectConstructor constructor String $anonymous0 name Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	67	67	1	add	
17	[BUG] [BUGGY] SerializedName annotation = f.getAnnotation(SerializedName.class); [FE] ComparisonFailure [CONTEXT] private List<String> getFieldNames(Field f) { [BUGGY] SerializedName annotation = f.getAnnotation(SerializedName.class); [BUGGY] if (annotation == null) { String name = fieldNamingPolicy.translateName(f); return Collections.singletonList(name); } String serializedName = annotation.value(); String[] alternates = annotation.alternate(); if (alternates.length == 0) { return Collections.singletonList(serializedName); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getFieldNames [RETURN_TYPE] List  Field f [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized SerializedName annotation ObjectConstructor constructor List fieldNames String $anonymous0 alternate name serializedName String[] alternates Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	72	72	1	replace	
18	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private List<String> getFieldNames(Field f) { [BUGGY] [BUGGY] SerializedName annotation = f.getAnnotation(SerializedName.class); if (annotation == null) { String name = fieldNamingPolicy.translateName(f); return Collections.singletonList(name); } String serializedName = annotation.value(); String[] alternates = annotation.alternate(); if (alternates.length == 0) { return Collections.singletonList(serializedName); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getFieldNames [RETURN_TYPE] List  Field f [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized SerializedName annotation ObjectConstructor constructor List fieldNames String $anonymous0 alternate name serializedName String[] alternates Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	72	72	1	add	
19	[BUG] [BUGGY] if (annotation == null) { [FE] ComparisonFailure [CONTEXT] private List<String> getFieldNames(Field f) { SerializedName annotation = f.getAnnotation(SerializedName.class); [BUGGY] if (annotation == null) { [BUGGY] String name = fieldNamingPolicy.translateName(f); return Collections.singletonList(name); } String serializedName = annotation.value(); String[] alternates = annotation.alternate(); if (alternates.length == 0) { return Collections.singletonList(serializedName); }  [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getFieldNames [RETURN_TYPE] List  Field f [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized SerializedName annotation ObjectConstructor constructor List fieldNames String $anonymous0 alternate name serializedName String[] alternates Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	73	73	1	replace	
20	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private List<String> getFieldNames(Field f) { SerializedName annotation = f.getAnnotation(SerializedName.class); [BUGGY] [BUGGY] if (annotation == null) { String name = fieldNamingPolicy.translateName(f); return Collections.singletonList(name); } String serializedName = annotation.value(); String[] alternates = annotation.alternate(); if (alternates.length == 0) { return Collections.singletonList(serializedName); }  [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getFieldNames [RETURN_TYPE] List  Field f [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized SerializedName annotation ObjectConstructor constructor List fieldNames String $anonymous0 alternate name serializedName String[] alternates Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	73	73	1	add	
21	[BUG] [BUGGY] String name = fieldNamingPolicy.translateName(f); [FE] ComparisonFailure [CONTEXT] private List<String> getFieldNames(Field f) { SerializedName annotation = f.getAnnotation(SerializedName.class); if (annotation == null) { [BUGGY] String name = fieldNamingPolicy.translateName(f); [BUGGY] return Collections.singletonList(name); } String serializedName = annotation.value(); String[] alternates = annotation.alternate(); if (alternates.length == 0) { return Collections.singletonList(serializedName); } List<String> fieldNames = new ArrayList<String>(alternates.length + 1); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getFieldNames [RETURN_TYPE] List  Field f [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized SerializedName annotation ObjectConstructor constructor List fieldNames String $anonymous0 alternate name serializedName String[] alternates Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	74	74	1	replace	
22	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private List<String> getFieldNames(Field f) { SerializedName annotation = f.getAnnotation(SerializedName.class); if (annotation == null) { [BUGGY] [BUGGY] String name = fieldNamingPolicy.translateName(f); return Collections.singletonList(name); } String serializedName = annotation.value(); String[] alternates = annotation.alternate(); if (alternates.length == 0) { return Collections.singletonList(serializedName); } List<String> fieldNames = new ArrayList<String>(alternates.length + 1); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getFieldNames [RETURN_TYPE] List  Field f [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized SerializedName annotation ObjectConstructor constructor List fieldNames String $anonymous0 alternate name serializedName String[] alternates Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	74	74	1	add	
23	[BUG] [BUGGY] return Collections.singletonList(name); [FE] ComparisonFailure [CONTEXT] private List<String> getFieldNames(Field f) { SerializedName annotation = f.getAnnotation(SerializedName.class); if (annotation == null) { String name = fieldNamingPolicy.translateName(f); [BUGGY] return Collections.singletonList(name); [BUGGY] } String serializedName = annotation.value(); String[] alternates = annotation.alternate(); if (alternates.length == 0) { return Collections.singletonList(serializedName); } List<String> fieldNames = new ArrayList<String>(alternates.length + 1); fieldNames.add(serializedName); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getFieldNames [RETURN_TYPE] List  Field f [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized SerializedName annotation ObjectConstructor constructor List fieldNames String $anonymous0 alternate name serializedName String[] alternates Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	75	75	1	replace	
24	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private List<String> getFieldNames(Field f) { SerializedName annotation = f.getAnnotation(SerializedName.class); if (annotation == null) { String name = fieldNamingPolicy.translateName(f); [BUGGY] [BUGGY] return Collections.singletonList(name); } String serializedName = annotation.value(); String[] alternates = annotation.alternate(); if (alternates.length == 0) { return Collections.singletonList(serializedName); } List<String> fieldNames = new ArrayList<String>(alternates.length + 1); fieldNames.add(serializedName); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getFieldNames [RETURN_TYPE] List  Field f [VARIABLES] ConstructorConstructor constructorConstructor Field f boolean $anonymous1 $anonymous2 deserialized serialize serialized SerializedName annotation ObjectConstructor constructor List fieldNames String $anonymous0 alternate name serializedName String[] alternates Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	75	75	1	add	
25	[BUG] [BUGGY] Class<? super T> raw = type.getRawType(); [FE] ComparisonFailure [CONTEXT] @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { [BUGGY] Class<? super T> raw = type.getRawType(); [BUGGY]  if (!Object.class.isAssignableFrom(raw)) { return null; // it's a primitive! } ObjectConstructor<T> constructor = constructorConstructor.get(type); return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] create [RETURN_TYPE] <T>  Gson gson TypeToken<T> type [VARIABLES] ConstructorConstructor constructorConstructor boolean $anonymous1 $anonymous2 deserialized serialize serialized TypeToken type ObjectConstructor constructor Gson gson Class raw String $anonymous0 alternate name serializedName Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	93	93	1	replace	
26	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { [BUGGY] [BUGGY] Class<? super T> raw = type.getRawType(); if (!Object.class.isAssignableFrom(raw)) { return null; // it's a primitive! } ObjectConstructor<T> constructor = constructorConstructor.get(type); return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] create [RETURN_TYPE] <T>  Gson gson TypeToken<T> type [VARIABLES] ConstructorConstructor constructorConstructor boolean $anonymous1 $anonymous2 deserialized serialize serialized TypeToken type ObjectConstructor constructor Gson gson Class raw String $anonymous0 alternate name serializedName Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	93	93	1	add	
27	[BUG] [BUGGY] if (!Object.class.isAssignableFrom(raw)) { [FE] ComparisonFailure [CONTEXT] @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { Class<? super T> raw = type.getRawType(); [BUGGY] if (!Object.class.isAssignableFrom(raw)) { [BUGGY] return null; // it's a primitive! } ObjectConstructor<T> constructor = constructorConstructor.get(type); return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] create [RETURN_TYPE] <T>  Gson gson TypeToken<T> type [VARIABLES] ConstructorConstructor constructorConstructor boolean $anonymous1 $anonymous2 deserialized serialize serialized TypeToken type ObjectConstructor constructor Gson gson Class raw String $anonymous0 alternate name serializedName Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	95	95	1	replace	
28	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { Class<? super T> raw = type.getRawType(); [BUGGY] [BUGGY] if (!Object.class.isAssignableFrom(raw)) { return null; // it's a primitive! } ObjectConstructor<T> constructor = constructorConstructor.get(type); return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] create [RETURN_TYPE] <T>  Gson gson TypeToken<T> type [VARIABLES] ConstructorConstructor constructorConstructor boolean $anonymous1 $anonymous2 deserialized serialize serialized TypeToken type ObjectConstructor constructor Gson gson Class raw String $anonymous0 alternate name serializedName Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	95	95	1	add	
29	[BUG] [BUGGY] ObjectConstructor<T> constructor = constructorConstructor.get(type); [FE] ComparisonFailure [CONTEXT] @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { Class<? super T> raw = type.getRawType(); if (!Object.class.isAssignableFrom(raw)) { return null; // it's a primitive! } [BUGGY] ObjectConstructor<T> constructor = constructorConstructor.get(type); [BUGGY] return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] create [RETURN_TYPE] <T>  Gson gson TypeToken<T> type [VARIABLES] ConstructorConstructor constructorConstructor boolean $anonymous1 $anonymous2 deserialized serialize serialized TypeToken type ObjectConstructor constructor Gson gson Class raw String $anonymous0 alternate name serializedName Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	99	99	1	replace	
30	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { Class<? super T> raw = type.getRawType(); if (!Object.class.isAssignableFrom(raw)) { return null; // it's a primitive! } [BUGGY] [BUGGY] ObjectConstructor<T> constructor = constructorConstructor.get(type); return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] create [RETURN_TYPE] <T>  Gson gson TypeToken<T> type [VARIABLES] ConstructorConstructor constructorConstructor boolean $anonymous1 $anonymous2 deserialized serialize serialized TypeToken type ObjectConstructor constructor Gson gson Class raw String $anonymous0 alternate name serializedName Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	99	99	1	add	
31	[BUG] [BUGGY] return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); [FE] ComparisonFailure [CONTEXT] @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { Class<? super T> raw = type.getRawType(); if (!Object.class.isAssignableFrom(raw)) { return null; // it's a primitive! } ObjectConstructor<T> constructor = constructorConstructor.get(type); [BUGGY] return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); [BUGGY] } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] create [RETURN_TYPE] <T>  Gson gson TypeToken<T> type [VARIABLES] ConstructorConstructor constructorConstructor boolean $anonymous1 $anonymous2 deserialized serialize serialized TypeToken type ObjectConstructor constructor Gson gson Class raw String $anonymous0 alternate name serializedName Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	100	100	1	replace	
32	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { Class<? super T> raw = type.getRawType(); if (!Object.class.isAssignableFrom(raw)) { return null; // it's a primitive! } ObjectConstructor<T> constructor = constructorConstructor.get(type); [BUGGY] [BUGGY] return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] create [RETURN_TYPE] <T>  Gson gson TypeToken<T> type [VARIABLES] ConstructorConstructor constructorConstructor boolean $anonymous1 $anonymous2 deserialized serialize serialized TypeToken type ObjectConstructor constructor Gson gson Class raw String $anonymous0 alternate name serializedName Excluder excluder Map boundFields FieldNamingStrategy fieldNamingPolicy  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	100	100	1	add	
33	[BUG] [BUGGY] final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType()); [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { [BUGGY] final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType()); [BUGGY]  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	106	106	1	replace	
34	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { [BUGGY] [BUGGY] final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	106	106	1	add	
35	[BUG] [BUGGY] JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  [BUGGY] JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); [BUGGY] TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	108	108	1	replace	
36	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  [BUGGY] [BUGGY] JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	108	108	1	add	
37	[BUG] [BUGGY] TypeAdapter<?> mapped = null; [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); [BUGGY] TypeAdapter<?> mapped = null; [BUGGY] if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	109	109	1	replace	
38	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); [BUGGY] [BUGGY] TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	109	109	1	add	
39	[BUG] [BUGGY] if (annotation != null) { [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; [BUGGY] if (annotation != null) { [BUGGY] mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	110	110	1	replace	
40	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; [BUGGY] [BUGGY] if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	110	110	1	add	
41	[BUG] [BUGGY] final boolean jsonAdapterPresent = mapped != null; [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } [BUGGY] final boolean jsonAdapterPresent = mapped != null; [BUGGY] if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	113	113	1	replace	
42	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } [BUGGY] [BUGGY] final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	113	113	1	add	
43	[BUG] [BUGGY] if (mapped == null) mapped = context.getAdapter(fieldType); [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; [BUGGY] if (mapped == null) mapped = context.getAdapter(fieldType); [BUGGY]  final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	114	114	1	replace	
44	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] final TypeToken<?> fieldType, boolean serialize, boolean deserialize) { final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; [BUGGY] [BUGGY] if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	114	114	1	add	
45	[BUG] [BUGGY] final TypeAdapter<?> typeAdapter = mapped; [FE] ComparisonFailure [CONTEXT] final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); [BUGGY] final TypeAdapter<?> typeAdapter = mapped; [BUGGY] return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); } @Override void read(JsonReader reader, Object value) [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	
46	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); [BUGGY] [BUGGY] final TypeAdapter<?> typeAdapter = mapped; return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); } @Override void read(JsonReader reader, Object value) [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	add	
47	[BUG] [BUGGY] return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { [FE] ComparisonFailure [CONTEXT]  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; [BUGGY] return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { [BUGGY] @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); } @Override void read(JsonReader reader, Object value) throws IOException, IllegalAccessException { [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	replace	
48	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT]  JsonAdapter annotation = field.getAnnotation(JsonAdapter.class); TypeAdapter<?> mapped = null; if (annotation != null) { mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation); } final boolean jsonAdapterPresent = mapped != null; if (mapped == null) mapped = context.getAdapter(fieldType); final TypeAdapter<?> typeAdapter = mapped; [BUGGY] [BUGGY] return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) { @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); t.write(writer, fieldValue); } @Override void read(JsonReader reader, Object value) throws IOException, IllegalAccessException { [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] createBoundField [RETURN_TYPE] ReflectiveTypeAdapterFactory$BoundField  Gson context Field field String name TypeToken<?> fieldType boolean serialize boolean deserialize [VARIABLES] Gson context String $anonymous0 alternate name serializedName JsonAdapter annotation Excluder excluder JsonWriter writer FieldNamingStrategy fieldNamingPolicy ConstructorConstructor constructorConstructor Field field boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken fieldType ObjectConstructor constructor TypeAdapter mapped t typeAdapter JsonReader reader Object fieldValue value Map boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	117	117	1	add	
49	[BUG] [BUGGY] Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { [BUGGY] Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); [BUGGY] if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	142	142	1	replace	
50	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { [BUGGY] [BUGGY] Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	142	142	1	add	
51	[BUG] [BUGGY] if (raw.isInterface()) { [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); [BUGGY] if (raw.isInterface()) { [BUGGY] return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	143	143	1	replace	
52	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); [BUGGY] [BUGGY] if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	143	143	1	add	
53	[BUG] [BUGGY] Type declaredType = type.getType(); [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } [BUGGY] Type declaredType = type.getType(); [BUGGY] while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	147	147	1	replace	
54	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } [BUGGY] [BUGGY] Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	147	147	1	add	
55	[BUG] [BUGGY] while (raw != Object.class) { [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); [BUGGY] while (raw != Object.class) { [BUGGY] Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	148	148	1	replace	
56	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); [BUGGY] [BUGGY] while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	148	148	1	add	
57	[BUG] [BUGGY] Field[] fields = raw.getDeclaredFields(); [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { [BUGGY] Field[] fields = raw.getDeclaredFields(); [BUGGY] for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	149	149	1	replace	
58	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { [BUGGY] [BUGGY] Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	149	149	1	add	
59	[BUG] [BUGGY] for (Field field : fields) { [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); [BUGGY] for (Field field : fields) { [BUGGY] boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	150	150	1	replace	
60	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); [BUGGY] [BUGGY] for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	150	150	1	add	
61	[BUG] [BUGGY] boolean serialize = excludeField(field, true); [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { [BUGGY] boolean serialize = excludeField(field, true); [BUGGY] boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	151	151	1	replace	
62	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) { Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { [BUGGY] [BUGGY] boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	151	151	1	add	
63	[BUG] [BUGGY] boolean deserialize = excludeField(field, false); [FE] ComparisonFailure [CONTEXT] Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); [BUGGY] boolean deserialize = excludeField(field, false); [BUGGY] if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	152	152	1	replace	
64	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] Map<String, BoundField> result = new LinkedHashMap<String, BoundField>(); if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); [BUGGY] [BUGGY] boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	152	152	1	add	
65	[BUG] [BUGGY] if (!serialize && !deserialize) { [FE] ComparisonFailure [CONTEXT] if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); [BUGGY] if (!serialize && !deserialize) { [BUGGY] continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	153	153	1	replace	
66	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] if (raw.isInterface()) { return result; } Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); [BUGGY] [BUGGY] if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	153	153	1	add	
67	[BUG] [BUGGY] field.setAccessible(true); [FE] ComparisonFailure [CONTEXT] Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } [BUGGY] field.setAccessible(true); [BUGGY] Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	156	156	1	replace	
68	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } [BUGGY] [BUGGY] field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	156	156	1	add	
69	[BUG] [BUGGY] Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); [FE] ComparisonFailure [CONTEXT] Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); [BUGGY] Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); [BUGGY] List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	157	157	1	replace	
70	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] Type declaredType = type.getType(); while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); [BUGGY] [BUGGY] Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	157	157	1	add	
71	[BUG] [BUGGY] List<String> fieldNames = getFieldNames(field); [FE] ComparisonFailure [CONTEXT] while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); [BUGGY] List<String> fieldNames = getFieldNames(field); [BUGGY] BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	158	158	1	replace	
72	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] while (raw != Object.class) { Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); [BUGGY] [BUGGY] List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	158	158	1	add	
73	[BUG] [BUGGY] BoundField previous = null; [FE] ComparisonFailure [CONTEXT] Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); [BUGGY] BoundField previous = null; [BUGGY] for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	159	159	1	replace	
74	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] Field[] fields = raw.getDeclaredFields(); for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); [BUGGY] [BUGGY] BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	159	159	1	add	
75	[BUG] [BUGGY] for (int i = 0; i < fieldNames.size(); ++i) { [FE] ComparisonFailure [CONTEXT] for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; [BUGGY] for (int i = 0; i < fieldNames.size(); ++i) { [BUGGY] String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	160	160	1	replace	
76	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] for (Field field : fields) { boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; [BUGGY] [BUGGY] for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	160	160	1	add	
77	[BUG] [BUGGY] String name = fieldNames.get(i); [FE] ComparisonFailure [CONTEXT] boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { [BUGGY] String name = fieldNames.get(i); [BUGGY] if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	161	161	1	replace	
78	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] boolean serialize = excludeField(field, true); boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { [BUGGY] [BUGGY] String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	161	161	1	add	
79	[BUG] [BUGGY] if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name,  TypeToken.get(fieldType), serialize, deserialize); [FE] ComparisonFailure [CONTEXT] boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); [BUGGY] if (i != 0) serialize = false; // only serialize the default name   BoundField boundField = createBoundField(context, field, name,       TypeToken.get(fieldType), serialize, deserialize); [BUGGY] BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	162	164	1	replace	
80	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] boolean deserialize = excludeField(field, false); if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); [BUGGY] [BUGGY] if (i != 0) serialize = false; // only serialize the default name   BoundField boundField = createBoundField(context, field, name,       TypeToken.get(fieldType), serialize, deserialize); BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	162	164	1	add	
81	[BUG] [BUGGY] BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); [FE] ComparisonFailure [CONTEXT] if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name [BUGGY] BoundField boundField = createBoundField(context, field, name,    TypeToken.get(fieldType), serialize, deserialize); [BUGGY] TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	163	164	1	replace	
82	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] if (!serialize && !deserialize) { continue; } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name [BUGGY] [BUGGY] BoundField boundField = createBoundField(context, field, name,    TypeToken.get(fieldType), serialize, deserialize); TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	163	164	1	add	
83	[BUG] [BUGGY] BoundField replaced = result.put(name, boundField); [FE] ComparisonFailure [CONTEXT] } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); [BUGGY] BoundField replaced = result.put(name, boundField); [BUGGY] if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	165	165	1	replace	
84	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] } field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); [BUGGY] [BUGGY] BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	165	165	1	add	
85	[BUG] [BUGGY] if (previous == null) previous = replaced; [FE] ComparisonFailure [CONTEXT] field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); [BUGGY] if (previous == null) previous = replaced; [BUGGY] } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); } return result; [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	166	166	1	replace	
86	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] field.setAccessible(true); Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType()); List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); [BUGGY] [BUGGY] if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); } return result; [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	166	166	1	add	
87	[BUG] [BUGGY] if (previous != null) { [FE] ComparisonFailure [CONTEXT] List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } [BUGGY] if (previous != null) { [BUGGY] throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); } return result; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	
88	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] List<String> fieldNames = getFieldNames(field); BoundField previous = null; for (int i = 0; i < fieldNames.size(); ++i) { String name = fieldNames.get(i); if (i != 0) serialize = false; // only serialize the default name BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } [BUGGY] [BUGGY] if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); } return result; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	
89	[BUG] [BUGGY] type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); [FE] ComparisonFailure [CONTEXT] BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } [BUGGY] type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); [BUGGY] raw = type.getRawType(); } return result; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	173	173	1	replace	
90	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] BoundField boundField = createBoundField(context, field, name, TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } [BUGGY] [BUGGY] type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); } return result; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	173	173	1	add	
91	[BUG] [BUGGY] raw = type.getRawType(); [FE] ComparisonFailure [CONTEXT] TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); [BUGGY] raw = type.getRawType(); [BUGGY] } return result; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	
92	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] TypeToken.get(fieldType), serialize, deserialize); BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); [BUGGY] [BUGGY] raw = type.getRawType(); } return result; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	add	
93	[BUG] [BUGGY] } [FE] ComparisonFailure [CONTEXT] BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); [BUGGY] } [BUGGY] return result; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	175	175	1	replace	
94	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] BoundField replaced = result.put(name, boundField); if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); [BUGGY] [BUGGY] } return result; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	175	175	1	add	
95	[BUG] [BUGGY] return result; [FE] ComparisonFailure [CONTEXT] if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); } [BUGGY] return result; [BUGGY] } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	176	176	1	replace	
96	[BUG] [BUGGY] [FE] ComparisonFailure [CONTEXT] if (previous == null) previous = replaced; } if (previous != null) { throw new IllegalArgumentException(declaredType + " declares multiple JSON fields named " + previous.name); } } type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass())); raw = type.getRawType(); } [BUGGY] [BUGGY] return result; } [CLASS] ReflectiveTypeAdapterFactory 1 BoundField Adapter [METHOD] getBoundFields [RETURN_TYPE] Map  Gson context TypeToken<?> type Class<?> raw [VARIABLES] Gson context String $anonymous0 alternate name serializedName Excluder excluder FieldNamingStrategy fieldNamingPolicy int i ConstructorConstructor constructorConstructor Field field Type declaredType fieldType boolean $anonymous1 $anonymous2 deserialize deserialized isPrimitive jsonAdapterPresent serialize serialized TypeToken type ObjectConstructor constructor Class raw List fieldNames Map boundFields result Field[] fields BoundField boundField previous replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	176	176	1	add	
