bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]      result.put(name,  type);  [CE]  cannot  find  symbol  name  [FE]    IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      result.put(name,  type);  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        result.put(name,  type);	  	non-compiled	[CE]  cannot  find  symbol  name	7	None	add
2	[BUG]  [BUGGY]      result.put(name,  fieldType);  [CE]  cannot  find  symbol  name  [FE]      IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      result.put(name,  fieldType);  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        result.put(name,  fieldType);	  	non-compiled	[CE]  cannot  find  symbol  name	7	None	add
3	[BUG]  [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [CE]  cannot  find  symbol  previous  [FE]        IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  previous.name);  }	  	non-compiled	[CE]  cannot  find  symbol  previous	7	None	add
4	[BUG]  [BUGGY]      Field[]  fields  =  type.getFields();  if(fields!=  null)  {  result  =  new  Field[fields.size()  ];  }  [CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)  [FE]          IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      Field[]  fields  =  type.getFields();  if(fields!=  null)  {  result  =  new  Field[fields.size()  ];  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        Field[]  fields  =  type.getFields();  if(fields!=  null)  {  result  =  new  Field[fields.size()  ];  }	  	non-compiled	[CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)	7	None	add
5	[BUG]  [BUGGY]      Field[]  fields  =  type.getFields();  if(fields  ==  null)  {  result  =  new  Field[fields.size()  ];  }  [CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)  [FE]            IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      Field[]  fields  =  type.getFields();  if(fields  ==  null)  {  result  =  new  Field[fields.size()  ];  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        Field[]  fields  =  type.getFields();  if(fields  ==  null)  {  result  =  new  Field[fields.size()  ];  }	  	non-compiled	[CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)	7	None	add
6	[BUG]  [BUGGY]      result.put(name,  boundField);  [CE]  cannot  find  symbol  name  [FE]              IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      result.put(name,  boundField);  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        result.put(name,  boundField);	  	non-compiled	[CE]  cannot  find  symbol  name	7	None	add
7	[BUG]  [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  type.name);  }  [CE]  cannot  find  symbol  name  [FE]                IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  type.name);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  type.name);  }	  	non-compiled	[CE]  cannot  find  symbol  name	7	None	add
8	[BUG]  [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldType.name);  }  [CE]  cannot  find  symbol  fieldType  [FE]                  IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldType.name);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldType.name);  }	  	non-compiled	[CE]  cannot  find  symbol  fieldType	7	None	add
9	[BUG]  [BUGGY]  result  =  declaredType.getRawType();  [CE]  cannot  find  symbol  [FE]                  ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  declaredType.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  declaredType.getRawType();	  result    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
10	[BUG]  [BUGGY]  result  =  previous.getRawType();  [CE]  cannot  find  symbol  previous  [FE]                    ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  previous.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  previous.getRawType();	  result    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol  previous	6	None	replace
11	[BUG]  [BUGGY]  result  =  context.getRawType();  [CE]  cannot  find  symbol  [FE]                      ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  context.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  context.getRawType();	  result    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
12	[BUG]  [BUGGY]  result  =  field.getRawType();  [CE]  cannot  find  symbol  field  [FE]                        ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  field.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  field.getRawType();	  result    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol  field	6	None	replace
13	[BUG]  [BUGGY]  result  =  first.getRawType();  [CE]  cannot  find  symbol  first  [FE]                          ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  first.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  first.getRawType();	  result    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol  first	6	None	replace
14	[BUG]  [BUGGY]  raw  =  declaredType.getRawClass();  [CE]  cannot  find  symbol  [FE]        ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  declaredType.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  declaredType.getRawClass();	  raw    =    fieldType.getRawClass();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
15	[BUG]  [BUGGY]  raw  =  context.getRawClass();  [CE]  cannot  find  symbol  [FE]          ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  context.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  context.getRawClass();	  raw    =    fieldType.getRawClass();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
16	[BUG]  [BUGGY]  raw  =  field.getRawClass();  [CE]  cannot  find  symbol  field  [FE]            ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  field.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  field.getRawClass();	  raw    =    fieldType.getRawClass();    	non-compiled	[CE]  cannot  find  symbol  field	10	None	replace
17	[BUG]  [BUGGY]  result  =  fieldType.getRawClass();  [CE]  cannot  find  symbol  fieldType  [FE]              ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  fieldType.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  fieldType.getRawClass();	  raw    =    fieldType.getRawClass();    	non-compiled	[CE]  cannot  find  symbol  fieldType	10	None	replace
18	[BUG]  [BUGGY]  raw  =  previous.getRawClass();  [CE]  cannot  find  symbol  previous  [FE]                ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  previous.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  previous.getRawClass();	  raw    =    fieldType.getRawClass();    	non-compiled	[CE]  cannot  find  symbol  previous	10	None	replace
19	[BUG]  [BUGGY]  raw  =  declaredType.getRawType();  [CE]  cannot  find  symbol  [FE]        ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  declaredType.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  declaredType.getRawType();	  raw    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol	1	None	replace
20	[BUG]  [BUGGY]  raw  =  previous.getRawType();  [CE]  cannot  find  symbol  previous  [FE]          ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  previous.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  previous.getRawType();	  raw    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol  previous	1	None	replace
21	[BUG]  [BUGGY]  result  =  type.getRawType().restrictByNotNullOrUndefined();  [CE]  cannot  find  symbol  [FE]            ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  type.getRawType().restrictByNotNullOrUndefined();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  type.getRawType().restrictByNotNullOrUndefined();	  result    =    type.getRawType();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
22	[BUG]  [BUGGY]  result  =  type.getRawType(),  fieldType);  [CE]  ';'  expected  [FE]              ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  type.getRawType(),  fieldType);  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  type.getRawType(),  fieldType);	  result    =    type.getRawType();    	non-compiled	[CE]  ';'  expected	3	None	replace
23	[BUG]  [BUGGY]  result  =  type.getRawType(),  raw.getGenericSuperclass());  [CE]  ';'  expected  [FE]                ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  type.getRawType(),  raw.getGenericSuperclass());  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  type.getRawType(),  raw.getGenericSuperclass());	  result    =    type.getRawType();    	non-compiled	[CE]  ';'  expected	3	None	replace
24	[BUG]  [BUGGY]  raw  =  boundField.getRawType();  [CE]  cannot  find  symbol  boundField  [FE]              ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  boundField.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  boundField.getRawType();	  raw    =    field.getRawType();    	non-compiled	[CE]  cannot  find  symbol  boundField	4	None	replace
25	[BUG]  [BUGGY]  raw  =  fieldType.getGenericSuperclass();  [CE]  cannot  find  symbol  fieldType  [FE]        ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  fieldType.getGenericSuperclass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  fieldType.getGenericSuperclass();	  raw    =    type.getGenericSuperclass();    	non-compiled	[CE]  cannot  find  symbol  fieldType	9	None	replace
26	[BUG]  [BUGGY]  raw  =  field.getGenericSuperclass();  [CE]  cannot  find  symbol  field  [FE]          ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  field.getGenericSuperclass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  field.getGenericSuperclass();	  raw    =    type.getGenericSuperclass();    	non-compiled	[CE]  cannot  find  symbol  field	9	None	replace
27	[BUG]  [BUGGY]  raw  =  context.getGenericSuperclass();  [CE]  cannot  find  symbol  [FE]            ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  context.getGenericSuperclass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  context.getGenericSuperclass();	  raw    =    type.getGenericSuperclass();    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
28	[BUG]  [BUGGY]  result  =  type.getGenericSuperclass();  [CE]  cannot  find  symbol  [FE]              ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  type.getGenericSuperclass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  type.getGenericSuperclass();	  raw    =    type.getGenericSuperclass();    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
29	[BUG]  [BUGGY]  raw  =  fields.getGenericSuperclass();  [CE]  cannot  find  symbol  [FE]                ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  fields.getGenericSuperclass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  fields.getGenericSuperclass();	  raw    =    type.getGenericSuperclass();    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
30	[BUG]  [BUGGY]  raw  =  type.getGenericSuperclass(),  boundField;  [CE]  ';'  expected  [FE]                  ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  type.getGenericSuperclass(),  boundField;  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  type.getGenericSuperclass(),  boundField;	  raw    =    type.getGenericSuperclass();    	non-compiled	[CE]  ';'  expected	9	None	replace
31	[BUG]  [BUGGY]  result  =  type.getRawClass();  [CE]  cannot  find  symbol  [FE]          ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  type.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  type.getRawClass();	  raw    =    type.getRawClass();    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
32	[BUG]  [BUGGY]  raw  =  type.getRawClass(),  fieldType;  [CE]  ';'  expected  [FE]            ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  type.getRawClass(),  fieldType;  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  type.getRawClass(),  fieldType;	  raw    =    type.getRawClass();    	non-compiled	[CE]  ';'  expected	2	None	replace
33	[BUG]  [BUGGY]  raw  =  this.context.getRawType();  [CE]  cannot  find  symbol  context  [FE]                ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  this.context.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  this.context.getRawType();	  raw    =    context.getRawType();    	non-compiled	[CE]  cannot  find  symbol  context	5	None	replace
34	[BUG]  [BUGGY]  raw  =  _context.getRawType();  [CE]  cannot  find  symbol  _context  [FE]                  ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  _context.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  _context.getRawType();	  raw    =    context.getRawType();    	non-compiled	[CE]  cannot  find  symbol  _context	5	None	replace
35	[BUG]  [BUGGY]  raw  =  fieldNamingPolicy.getRawType();  [CE]  cannot  find  symbol  [FE]                ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  fieldNamingPolicy.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  fieldNamingPolicy.getRawType();	  raw    =    context.getRawType();    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
36	[BUG]  [BUGGY]  raw  =  fieldNames.getRawType();  [CE]  cannot  find  symbol  fieldNames  [FE]                  ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  fieldNames.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  fieldNames.getRawType();	  raw    =    context.getRawType();    	non-compiled	[CE]  cannot  find  symbol  fieldNames	5	None	replace
37	[BUG]  [BUGGY]  raw  =  fields.getRawType();  [CE]  cannot  find  symbol  [FE]                    ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  fields.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  fields.getRawType();	  raw    =    context.getRawType();    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
38	[BUG]  [BUGGY]  raw  =  boundField.getRawClass();  [CE]  cannot  find  symbol  boundField  [FE]        ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  boundField.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  boundField.getRawClass();	  raw    =    fieldType.getRawClass();    	non-compiled	[CE]  cannot  find  symbol  boundField	10	None	replace
39	[BUG]  [BUGGY]  raw  =  name.getRawClass();  [CE]  cannot  find  symbol  name  [FE]          ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  name.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  name.getRawClass();	  raw    =    fieldType.getRawClass();    	non-compiled	[CE]  cannot  find  symbol  name	10	None	replace
40	[BUG]  [BUGGY]  result  =  type.getRawType(),  fieldType;  [CE]  ';'  expected  [FE]            ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  type.getRawType(),  fieldType;  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  type.getRawType(),  fieldType;	  result    =    type.getRawType();    	non-compiled	[CE]  ';'  expected	3	None	replace
41	[BUG]  [BUGGY]  result  =  type.getNativeType(UNKNOWN_TYPE);  [CE]  cannot  find  symbol  UNKNOWN_TYPE  [FE]              ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  type.getNativeType(UNKNOWN_TYPE);  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  type.getNativeType(UNKNOWN_TYPE);	  result    =    type.getRawType();    	non-compiled	[CE]  cannot  find  symbol  UNKNOWN_TYPE	3	None	replace
42	[BUG]  [BUGGY]  raw  =  result.getRawType();  [CE]  cannot  find  symbol  [FE]              ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  result.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  result.getRawType();	  raw    =    field.getRawType();    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
43	[BUG]  [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  field.name);  }  [CE]  cannot  find  symbol  field  [FE]    IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  field.name);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  field.name);  }	  	non-compiled	[CE]  cannot  find  symbol  field	7	None	add
44	[BUG]  [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  name);  }  [CE]  cannot  find  symbol  name  [FE]      IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  name);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  name);  }	  	non-compiled	[CE]  cannot  find  symbol  name	7	None	add
45	[BUG]  [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldType);  }  [CE]  cannot  find  symbol  fieldType  [FE]        IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldType);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        if(type!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldType);  }	  	non-compiled	[CE]  cannot  find  symbol  fieldType	7	None	add
46	[BUG]  [BUGGY]  raw  =  name.getRawType();  [CE]  cannot  find  symbol  name  [FE]        ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  name.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  name.getRawType();	  raw    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol  name	1	None	replace
47	[BUG]  [BUGGY]  raw  =  fieldNames.getGenericSuperclass();  [CE]  cannot  find  symbol  fieldNames  [FE]        ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  fieldNames.getGenericSuperclass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  fieldNames.getGenericSuperclass();	  raw    =    type.getGenericSuperclass();    	non-compiled	[CE]  cannot  find  symbol  fieldNames	9	None	replace
48	[BUG]  [BUGGY]  result  =  fieldType.getGenericSuperclass();  [CE]  cannot  find  symbol  fieldType  [FE]          ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  fieldType.getGenericSuperclass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  fieldType.getGenericSuperclass();	  raw    =    type.getGenericSuperclass();    	non-compiled	[CE]  cannot  find  symbol  fieldType	9	None	replace
49	[BUG]  [BUGGY]  result  =  boundField.getRawType();  [CE]  cannot  find  symbol  boundField  [FE]                  ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  boundField.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  boundField.getRawType();	  result    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol  boundField	6	None	replace
50	[BUG]  [BUGGY]  raw  =  fields.getRawClass();  [CE]  cannot  find  symbol  [FE]          ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  fields.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  fields.getRawClass();	  raw    =    type.getRawClass();    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
51	[BUG]  [BUGGY]  result  =  predecessor.getRawType();  [CE]  cannot  find  symbol  predecessor  [FE]                  ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  predecessor.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  predecessor.getRawType();	  result    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol  predecessor	6	None	replace
52	[BUG]  [BUGGY]  raw  =  replaced.getRawType();  [CE]  cannot  find  symbol  replaced  [FE]              ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  replaced.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  replaced.getRawType();	  raw    =    field.getRawType();    	non-compiled	[CE]  cannot  find  symbol  replaced	4	None	replace
53	[BUG]  [BUGGY]  raw  =  parent.getRawType();  [CE]  cannot  find  symbol  parent  [FE]        ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  parent.getRawType();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  parent.getRawType();	  raw    =    fieldType.getRawType();    	non-compiled	[CE]  cannot  find  symbol  parent	1	None	replace
54	[BUG]  [BUGGY]  result  =  new  TypeToken(type.getRawType(),  fieldType);  [CE]  cannot  find  symbol  fieldType  [FE]            ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  new  TypeToken(type.getRawType(),  fieldType);  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  new  TypeToken(type.getRawType(),  fieldType);	  result    =    type.getRawType();    	non-compiled	[CE]  cannot  find  symbol  fieldType	3	None	replace
55	[BUG]  [BUGGY]  result  =  new  TypeToken(type.getRawType());  [CE]  TypeToken(Type)  is  not  public  in  TypeToken;  cannot  be  accessed  from  outside  package  [FE]              ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  result  =  new  TypeToken(type.getRawType());  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	result  =  new  TypeToken(type.getRawType());	  result    =    type.getRawType();    	non-compiled	[CE]  TypeToken(Type)  is  not  public  in  TypeToken;  cannot  be  accessed  from  outside  package	3	None	replace
56	[BUG]  [BUGGY]  Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.length  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldName);  }  [CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)  [FE]    IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.length  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldName);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.length  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldName);  }	      	non-compiled	[CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)	8	None	replace
57	[BUG]  [BUGGY]  Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.size()  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldName);  }  [CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)  [FE]      IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.size()  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldName);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.size()  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldName);  }	      	non-compiled	[CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)	8	None	replace
58	[BUG]  [BUGGY]  Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.length  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  field.name);  }  [CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)  [FE]        IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.length  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  field.name);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.length  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  field.name);  }	      	non-compiled	[CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)	8	None	replace
59	[BUG]  [BUGGY]  Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.length  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldType);  }  [CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)  [FE]          IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.length  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldType);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.length  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  fieldType);  }	      	non-compiled	[CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)	8	None	replace
60	[BUG]  [BUGGY]  raw  =  fieldNames.getRawClass();  [CE]  cannot  find  symbol  fieldNames  [FE]          ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  fieldNames.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  fieldNames.getRawClass();	  raw    =    type.getRawClass();    	non-compiled	[CE]  cannot  find  symbol  fieldNames	2	None	replace
61	[BUG]  [BUGGY]  raw  =  fieldNamingPolicy.getGenericSuperclass();  [CE]  cannot  find  symbol  [FE]        ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  fieldNamingPolicy.getGenericSuperclass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  fieldNamingPolicy.getGenericSuperclass();	  raw    =    type.getGenericSuperclass();    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
62	[BUG]  [BUGGY]  raw  =  replaced.getRawClass();  [CE]  cannot  find  symbol  replaced  [FE]        ComparisonFailure    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]  raw  =  replaced.getRawClass();  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	raw  =  replaced.getRawClass();	  raw    =    fieldType.getRawClass();    	non-compiled	[CE]  cannot  find  symbol  replaced	10	None	replace
63	[BUG]  [BUGGY]      Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.size()  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  field.name);  }  [CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)  [FE]    IllegalArgumentException    [CONTEXT]    TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }  if  (previous  !=  null)  {  throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));    [BUGGY]      Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.size()  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  field.name);  }  [BUGGY]    }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	174	174	1	replace	        Field[]  fields  =  fieldType.getFields();  if(fields!=  null  ||  fields.size()  ==  0)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named   "  +  field.name);  }	  	non-compiled	[CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)	7	None	add
