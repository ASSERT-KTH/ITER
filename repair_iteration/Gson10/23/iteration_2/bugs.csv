bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  [CE]  variable  typeAdapter  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;	  	non-compiled	[CE]  variable  typeAdapter  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	13	None	add
2	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  mapped  :  mapped;  [CE]  variable  typeAdapter  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  mapped  :  mapped;	  	non-compiled	[CE]  variable  typeAdapter  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	13	None	add
3	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped  >>  null?  mapped  :  mapped;  [CE]  variable  typeAdapter  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped  >>  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    final  TypeAdapter  <?>  typeAdapter  =  mapped  >>  null?  mapped  :  mapped;	  	non-compiled	[CE]  variable  typeAdapter  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	13	None	add
4	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped  >=  null?  mapped  :  mapped;  [CE]  variable  typeAdapter  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped  >=  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    final  TypeAdapter  <?>  typeAdapter  =  mapped  >=  null?  mapped  :  mapped;	  	non-compiled	[CE]  variable  typeAdapter  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	13	None	add
5	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  [CE]  variable  typeAdapter  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;	  	non-compiled	[CE]  variable  typeAdapter  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	13	None	add
6	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped);  [CE]  ';'  expected  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped);	  	non-compiled	[CE]  ';'  expected	13	None	add
7	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  Final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  [CE]  ';'  expected  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  Final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    Final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;	  	non-compiled	[CE]  ';'  expected	13	None	add
8	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped  [Delete]  null?  mapped  :  mapped;  [CE]  ';'  expected  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped;  final  TypeAdapter  <?>  typeAdapter  =  mapped  [Delete]  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    final  TypeAdapter  <?>  typeAdapter  =  mapped  [Delete]  null?  mapped  :  mapped;	  	non-compiled	[CE]  ';'  expected	13	None	add
9	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.type;  [CE]  type  is  not  public  in  TypeToken;  cannot  be  accessed  from  outside  package  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.type;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.type;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.type;    	non-compiled	[CE]  type  is  not  public  in  TypeToken;  cannot  be  accessed  from  outside  package	1	None	replace
10	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.value;  [CE]  cannot  find  symbol  value  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.value;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.value;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.type;    	non-compiled	[CE]  cannot  find  symbol  value	1	None	replace
11	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context.type;  [CE]  cannot  find  symbol  type  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context.type;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  context.type;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.type;    	non-compiled	[CE]  cannot  find  symbol  type	1	None	replace
12	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.jsonAdapterPresent;  [CE]  cannot  find  symbol  jsonAdapterPresent  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.jsonAdapterPresent;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.jsonAdapterPresent;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.type;    	non-compiled	[CE]  cannot  find  symbol  jsonAdapterPresent	1	None	replace
13	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.jsonAdapterType;  [CE]  cannot  find  symbol  jsonAdapterType  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.jsonAdapterType;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.jsonAdapterType;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.type;    	non-compiled	[CE]  cannot  find  symbol  jsonAdapterType	1	None	replace
14	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.getTypeAdapter(mapped);  [CE]  boolean  cannot  be  dereferenced  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.getTypeAdapter(mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.getTypeAdapter(mapped);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(jsonAdapterPresent);    	non-compiled	[CE]  boolean  cannot  be  dereferenced	6	None	replace
15	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.getTypeAdapter(fieldType,  jsonAdapterPresent);  [CE]  cannot  find  symbol  [FE]                    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.getTypeAdapter(fieldType,  jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.getTypeAdapter(fieldType,  jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(jsonAdapterPresent);    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
16	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  field.getTypeAdapter(jsonAdapterPresent);  [CE]  cannot  find  symbol  [FE]                      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  field.getTypeAdapter(jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  field.getTypeAdapter(jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(jsonAdapterPresent);    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
17	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context.getTypeAdapter(jsonAdapterPresent);  [CE]  cannot  find  symbol  [FE]                        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context.getTypeAdapter(jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  context.getTypeAdapter(jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(jsonAdapterPresent);    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
18	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  mapped.getTypeAdapter(jsonAdapterPresent);  [CE]  ';'  expected  [FE]                          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  mapped.getTypeAdapter(jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  mapped.getTypeAdapter(jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(jsonAdapterPresent);    	non-compiled	[CE]  ';'  expected	6	None	replace
19	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getTypeAdapter(jsonAdapterPresent);  [CE]  cannot  find  symbol  [FE]                            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getTypeAdapter(jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.getTypeAdapter(jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(jsonAdapterPresent);    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
20	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getType());  [CE]  ';'  expected  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getType());  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getType());	  final    TypeAdapter    <?>    typeAdapter    =    mapped,    fieldType.getRawType());    	non-compiled	[CE]  ';'  expected	12	None	replace
21	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType,  mapped.getRawType());  [CE]  ';'  expected  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType,  mapped.getRawType());  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType,  mapped.getRawType());	  final    TypeAdapter    <?>    typeAdapter    =    mapped,    fieldType.getRawType());    	non-compiled	[CE]  ';'  expected	12	None	replace
22	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getRawType(),  jsonAdapterPresent);  [CE]  ';'  expected  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getRawType(),  jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getRawType(),  jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    mapped,    fieldType.getRawType());    	non-compiled	[CE]  ';'  expected	12	None	replace
23	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getReturnType());  [CE]  ';'  expected  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getReturnType());  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getReturnType());	  final    TypeAdapter    <?>    typeAdapter    =    mapped,    fieldType.getRawType());    	non-compiled	[CE]  ';'  expected	12	None	replace
24	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  fieldType.getRawType());  [CE]  ';'  expected  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  fieldType.getRawType());  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  fieldType.getRawType());	  final    TypeAdapter    <?>    typeAdapter    =    mapped,    fieldType.getRawType());    	non-compiled	[CE]  ';'  expected	12	None	replace
25	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getRawType();  [CE]  incompatible  types  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getRawType();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.getRawType();	  final    TypeAdapter    <?>    typeAdapter    =    mapped,    fieldType.getRawType());    	non-compiled	[CE]  incompatible  types	12	None	replace
26	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  fieldType,  mapped);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  fieldType,  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  fieldType,  mapped);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	3	None	replace
27	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  fieldType,  mapped,  jsonAdapterPresent);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  fieldType,  mapped,  jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  fieldType,  mapped,  jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	3	None	replace
28	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  fieldType,  jsonAdapterPresent,  mapped);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  fieldType,  jsonAdapterPresent,  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  fieldType,  jsonAdapterPresent,  mapped);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	3	None	replace
29	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  mapped,  fieldType);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  mapped,  fieldType);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructorConstructor,  mapped,  fieldType);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	3	None	replace
30	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(jsonAdapterPresent,  fieldType,  mapped);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]                    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(jsonAdapterPresent,  fieldType,  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(jsonAdapterPresent,  fieldType,  mapped);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	3	None	replace
31	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructor,  fieldType,  mapped,  jsonAdapterPresent);  [CE]  cannot  find  symbol  constructor  [FE]                      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructor,  fieldType,  mapped,  jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructor,  fieldType,  mapped,  jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    fieldType,    mapped);    	non-compiled	[CE]  cannot  find  symbol  constructor	3	None	replace
32	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  constructor,  fieldType,  mapped);  [CE]  cannot  find  symbol  constructor  [FE]                        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  constructor,  fieldType,  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  constructor,  fieldType,  mapped);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    fieldType,    mapped);    	non-compiled	[CE]  cannot  find  symbol  constructor	3	None	replace
33	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.type;  [CE]  boolean  cannot  be  dereferenced  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.type;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.type;	  final    TypeAdapter    <?>    typeAdapter    =    jsonAdapterPresent;    	non-compiled	[CE]  boolean  cannot  be  dereferenced	4	None	replace
34	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  context);  [CE]  ';'  expected  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  context);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  context);	  final    TypeAdapter    <?>    typeAdapter    =    jsonAdapterPresent;    	non-compiled	[CE]  ';'  expected	4	None	replace
35	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  fieldType;  [CE]  incompatible  types  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  fieldType;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  fieldType;	  final    TypeAdapter    <?>    typeAdapter    =    jsonAdapterPresent;    	non-compiled	[CE]  incompatible  types	4	None	replace
36	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  fieldType);  [CE]  ';'  expected  [FE]                    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  fieldType);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  fieldType);	  final    TypeAdapter    <?>    typeAdapter    =    jsonAdapterPresent;    	non-compiled	[CE]  ';'  expected	4	None	replace
37	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getTypeAdapter();  [CE]  cannot  find  symbol  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getTypeAdapter();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.getTypeAdapter();	  final    TypeAdapter    <?>    typeAdapter    =    fieldType;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
38	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.restrictByNotNullOrUndefined();  [CE]  cannot  find  symbol  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.restrictByNotNullOrUndefined();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.restrictByNotNullOrUndefined();	  final    TypeAdapter    <?>    typeAdapter    =    fieldType;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
39	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getType();  [CE]  incompatible  types  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getType();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.getType();	  final    TypeAdapter    <?>    typeAdapter    =    fieldType;    	non-compiled	[CE]  incompatible  types	9	None	replace
40	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.typeAdapter();  [CE]  cannot  find  symbol  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.typeAdapter();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.typeAdapter();	  final    TypeAdapter    <?>    typeAdapter    =    fieldType;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
41	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.typeAdapter;  [CE]  cannot  find  symbol  typeAdapter  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.typeAdapter;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.typeAdapter;	  final    TypeAdapter    <?>    typeAdapter    =    fieldType;    	non-compiled	[CE]  cannot  find  symbol  typeAdapter	9	None	replace
42	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context.getTypeAdapter(fieldType);  [CE]  cannot  find  symbol  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context.getTypeAdapter(fieldType);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  context.getTypeAdapter(fieldType);	  final    TypeAdapter    <?>    typeAdapter    =    fieldType;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
43	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapter();  [CE]  cannot  find  symbol  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapter();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapter();	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter();    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
44	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  field.getTypeAdapter();  [CE]  cannot  find  symbol  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  field.getTypeAdapter();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  field.getTypeAdapter();	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter();    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
45	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getTypeAdapter();  [CE]  ';'  expected  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getTypeAdapter();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getTypeAdapter();	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter();    	non-compiled	[CE]  ';'  expected	2	None	replace
46	[BUG]  [BUGGY]  mapped  =  field.getAnnotation(JsonAdapter.class);  [CE]  incompatible  types  [FE]                      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  mapped  =  field.getAnnotation(JsonAdapter.class);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	mapped  =  field.getAnnotation(JsonAdapter.class);	      	non-compiled	[CE]  incompatible  types	8	None	replace
47	[BUG]  [BUGGY]  TypeToken  type  =  jsonAdapterPresent.getType();  [CE]  boolean  cannot  be  dereferenced  [FE]                        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  type  =  jsonAdapterPresent.getType();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  type  =  jsonAdapterPresent.getType();	      	non-compiled	[CE]  boolean  cannot  be  dereferenced	8	None	replace
48	[BUG]  [BUGGY]  TypeToken  token  =  jsonAdapterPresent.getTypeToken();  [CE]  boolean  cannot  be  dereferenced  [FE]                          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  token  =  jsonAdapterPresent.getTypeToken();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  token  =  jsonAdapterPresent.getTypeToken();	      	non-compiled	[CE]  boolean  cannot  be  dereferenced	8	None	replace
49	[BUG]  [BUGGY]  JsonReader  writer  =  context.getJsonReader();  [CE]  cannot  find  symbol  [FE]                            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  JsonReader  writer  =  context.getJsonReader();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	JsonReader  writer  =  context.getJsonReader();	      	non-compiled	[CE]  cannot  find  symbol	8	None	replace
50	[BUG]  [BUGGY]  TypeToken  serialize  =  jsonAdapterPresent.getType();  [CE]  variable  serialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]                              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  serialize  =  jsonAdapterPresent.getType();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  serialize  =  jsonAdapterPresent.getType();	      	non-compiled	[CE]  variable  serialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	8	None	replace
51	[BUG]  [BUGGY]  TypeToken  type  =  jsonAdapterPresent;  [CE]  incompatible  types  [FE]                                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  type  =  jsonAdapterPresent;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  type  =  jsonAdapterPresent;	      	non-compiled	[CE]  incompatible  types	8	None	replace
52	[BUG]  [BUGGY]  TypeToken  token  =  jsonAdapterPresent;  [CE]  incompatible  types  [FE]                                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  token  =  jsonAdapterPresent;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  token  =  jsonAdapterPresent;	      	non-compiled	[CE]  incompatible  types	8	None	replace
53	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	add	final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  mapped  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	compilable	  [FE]  ComparisonFailure  	14	1	replace
54	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  mapped  :  mapped;  [FE]  ComparisonFailure  [FE]    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  mapped  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	compilable	  [FE]  ComparisonFailure  	14	1	replace
55	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped.type;  [CE]  cannot  find  symbol  type  [FE]      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped.type;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  mapped.type;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	non-compiled	[CE]  cannot  find  symbol  type	14	None	replace
56	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	add	final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	compilable	  [FE]  ComparisonFailure  	14	1	replace
57	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped  :  mapped;  [FE]  ComparisonFailure  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	compilable	  [FE]  ComparisonFailure  	14	1	replace
58	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped  >=  null?  mapped  :  mapped;  [CE]  bad  operand  types  for  binary  operator  '>='  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped  >=  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped  >=  null?  mapped  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>='	14	None	replace
59	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped  >>  null?  mapped  :  mapped;  [CE]  bad  operand  types  for  binary  operator  '>>'  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped  >>  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped  >>  null?  mapped  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '>>'	14	None	replace
60	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	add	final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  mapped  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	compilable	  [FE]  ComparisonFailure  	14	1	replace
61	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  mapped  :  mapped;  [FE]  ComparisonFailure  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  mapped  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  mapped  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	compilable	  [FE]  ComparisonFailure  	14	1	replace
62	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getTypeAdapter(mapped);  [CE]  cannot  find  symbol  [FE]                    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getTypeAdapter(mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.getTypeAdapter(mapped);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(fieldType);    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
63	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  field.getTypeAdapter(mapped);  [CE]  cannot  find  symbol  [FE]                      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  field.getTypeAdapter(mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  field.getTypeAdapter(mapped);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(fieldType);    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
64	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fields.getTypeAdapter(fieldType);  [CE]  cannot  find  symbol  fields  [FE]                        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fields.getTypeAdapter(fieldType);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fields.getTypeAdapter(fieldType);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(fieldType);    	non-compiled	[CE]  cannot  find  symbol  fields	7	None	replace
65	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped.getType()  :  mapped;  [CE]  cannot  find  symbol  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped.getType()  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped.getType()  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
66	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  mapped.getType()  :  mapped;  [CE]  cannot  find  symbol  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  mapped.getType()  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  mapped.getType()  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
67	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  fieldType.getType()  :  mapped;  [CE]  incompatible  types  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  fieldType.getType()  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped  ==  null?  fieldType.getType()  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  incompatible  types	11	None	replace
68	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  fieldType.getType()  :  mapped;  [CE]  incompatible  types  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  fieldType.getType()  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  fieldType.getType()  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  incompatible  types	11	None	replace
69	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fields!=  null?  fieldType.getType()  :  mapped;  [CE]  cannot  find  symbol  fields  [FE]                    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fields!=  null?  fieldType.getType()  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fields!=  null?  fieldType.getType()  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  cannot  find  symbol  fields	11	None	replace
70	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  context.getType()  :  mapped;  [CE]  cannot  find  symbol  [FE]                      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  context.getType()  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  context.getType()  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
71	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  constructorConstructor,  fieldType,  mapped);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  constructorConstructor,  fieldType,  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  constructorConstructor,  fieldType,  mapped);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    context,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	10	None	replace
72	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  fieldType,  constructorConstructor);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  fieldType,  constructorConstructor);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  fieldType,  constructorConstructor);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    context,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	10	None	replace
73	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(jsonAdapterPresent,  context,  fieldType,  mapped);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(jsonAdapterPresent,  context,  fieldType,  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(jsonAdapterPresent,  context,  fieldType,  mapped);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    context,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	10	None	replace
74	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  constructorConstructor,  mapped,  fieldType);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  constructorConstructor,  mapped,  fieldType);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(context,  constructorConstructor,  mapped,  fieldType);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    context,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	10	None	replace
75	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(fieldType,  context,  constructorConstructor,  mapped);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(fieldType,  context,  constructorConstructor,  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(fieldType,  context,  constructorConstructor,  mapped);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    context,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	10	None	replace
76	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapter(jsonAdapterPresent);  [CE]  cannot  find  symbol  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapter(jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapter(jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.typeAdapter;    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
77	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapter  ||  jsonAdapterPresent;  [CE]  cannot  find  symbol  typeAdapter  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapter  ||  jsonAdapterPresent;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapter  ||  jsonAdapterPresent;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.typeAdapter;    	non-compiled	[CE]  cannot  find  symbol  typeAdapter	5	None	replace
78	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapterFactory;  [CE]  cannot  find  symbol  typeAdapterFactory  [FE]                    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapterFactory;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAdapterFactory;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.typeAdapter;    	non-compiled	[CE]  cannot  find  symbol  typeAdapterFactory	5	None	replace
79	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context.typeAdapter;  [CE]  cannot  find  symbol  typeAdapter  [FE]                      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context.typeAdapter;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  context.typeAdapter;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.typeAdapter;    	non-compiled	[CE]  cannot  find  symbol  typeAdapter	5	None	replace
80	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.valueAdapter;  [CE]  cannot  find  symbol  valueAdapter  [FE]                        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.valueAdapter;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.valueAdapter;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.typeAdapter;    	non-compiled	[CE]  cannot  find  symbol  valueAdapter	5	None	replace
81	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.typeAdapter;  [CE]  boolean  cannot  be  dereferenced  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.typeAdapter;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.typeAdapter;	  final    TypeAdapter    <?>    typeAdapter    =    jsonAdapterPresent;    	non-compiled	[CE]  boolean  cannot  be  dereferenced	4	None	replace
82	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.getTypeAdapter();  [CE]  boolean  cannot  be  dereferenced  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.getTypeAdapter();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.getTypeAdapter();	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter();    	non-compiled	[CE]  boolean  cannot  be  dereferenced	2	None	replace
83	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context.getTypeAdapter();  [CE]  cannot  find  symbol  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context.getTypeAdapter();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  context.getTypeAdapter();	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter();    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
84	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  fieldType.getType()  :  jsonAdapterPresent;  [CE]  incompatible  types  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  fieldType.getType()  :  jsonAdapterPresent;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  fieldType.getType()  :  jsonAdapterPresent;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  incompatible  types	11	None	replace
85	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  fieldType.getType()  :  mapped;  [CE]  incompatible  types  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  fieldType.getType()  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType  ==  null?  fieldType.getType()  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  incompatible  types	11	None	replace
86	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fields.getType()!=  null?  fieldType.getType()  :  mapped;  [CE]  cannot  find  symbol  fields  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fields.getType()!=  null?  fieldType.getType()  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fields.getType()!=  null?  fieldType.getType()  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  cannot  find  symbol  fields	11	None	replace
87	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.findTypeAdapter(jsonAdapterPresent);  [CE]  cannot  find  symbol  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.findTypeAdapter(jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.findTypeAdapter(jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    fieldType;    	non-compiled	[CE]  cannot  find  symbol	9	None	replace
88	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context;  [CE]  incompatible  types  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  context;	  final    TypeAdapter    <?>    typeAdapter    =    fieldType;    	non-compiled	[CE]  incompatible  types	9	None	replace
89	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapter.getTypeAdapter(mapped);  [CE]  cannot  find  symbol  jsonAdapter  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapter.getTypeAdapter(mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapter.getTypeAdapter(mapped);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(jsonAdapterPresent);    	non-compiled	[CE]  cannot  find  symbol  jsonAdapter	6	None	replace
90	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.getTypeAdapter(context);  [CE]  boolean  cannot  be  dereferenced  [FE]                    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.getTypeAdapter(context);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent.getTypeAdapter(context);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(jsonAdapterPresent);    	non-compiled	[CE]  boolean  cannot  be  dereferenced	6	None	replace
91	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  jsonAdapterPresent;  [CE]  incompatible  types  [FE]    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  jsonAdapterPresent;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  jsonAdapterPresent;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	non-compiled	[CE]  incompatible  types	14	None	replace
92	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  context.getTypeAdapter(fieldType);  [CE]  cannot  find  symbol  [FE]      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  context.getTypeAdapter(fieldType);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  context.getTypeAdapter(fieldType);	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	non-compiled	[CE]  cannot  find  symbol	14	None	replace
93	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  fieldType;  [CE]  incompatible  types  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  fieldType;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped  :  fieldType;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	non-compiled	[CE]  incompatible  types	14	None	replace
94	[BUG]  [BUGGY]  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  jsonAdapterPresent);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]                      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	mapped  =  getTypeAdapter(constructorConstructor,  fieldType,  jsonAdapterPresent);	      	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	8	None	replace
95	[BUG]  [BUGGY]  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]                        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  jsonAdapterPresent);	      	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	8	None	replace
96	[BUG]  [BUGGY]  mapped  =  context.getTypeAdapter(fieldType,  jsonAdapterPresent);  [CE]  cannot  find  symbol  [FE]                          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  mapped  =  context.getTypeAdapter(fieldType,  jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	mapped  =  context.getTypeAdapter(fieldType,  jsonAdapterPresent);	      	non-compiled	[CE]  cannot  find  symbol	8	None	replace
97	[BUG]  [BUGGY]  JsonReader  writer  =  context.getAnnotation(JsonReader.class);  [CE]  cannot  find  symbol  [FE]                            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  JsonReader  writer  =  context.getAnnotation(JsonReader.class);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	JsonReader  writer  =  context.getAnnotation(JsonReader.class);	      	non-compiled	[CE]  cannot  find  symbol	8	None	replace
98	[BUG]  [BUGGY]  JsonReader  writer  =  context.getJsonReader(jsonAdapterPresent);  [CE]  cannot  find  symbol  [FE]                              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  JsonReader  writer  =  context.getJsonReader(jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	JsonReader  writer  =  context.getJsonReader(jsonAdapterPresent);	      	non-compiled	[CE]  cannot  find  symbol	8	None	replace
99	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context,  fieldType.getRawType());  [CE]  ';'  expected  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  context,  fieldType.getRawType());  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  context,  fieldType.getRawType());	  final    TypeAdapter    <?>    typeAdapter    =    mapped,    fieldType.getRawType());    	non-compiled	[CE]  ';'  expected	12	None	replace
100	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructor,  fieldType,  mapped);  [CE]  cannot  find  symbol  constructor  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructor,  fieldType,  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(constructor,  fieldType,  mapped);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    context,    fieldType,    mapped);    	non-compiled	[CE]  cannot  find  symbol  constructor	10	None	replace
101	[BUG]  [BUGGY]  final  TypeAdapter  <?>  fieldTypeAdapter  =  mapped.getTypeAdapter(fieldType);  [CE]  cannot  find  symbol  [FE]                    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  fieldTypeAdapter  =  mapped.getTypeAdapter(fieldType);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  fieldTypeAdapter  =  mapped.getTypeAdapter(fieldType);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(fieldType);    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
102	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldtype.getTypeAdapter(mapped);  [CE]  cannot  find  symbol  fieldtype  [FE]                      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldtype.getTypeAdapter(mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldtype.getTypeAdapter(mapped);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(fieldType);    	non-compiled	[CE]  cannot  find  symbol  fieldtype	7	None	replace
103	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  fieldType.getRawType()  :  mapped;  [CE]  incompatible  types  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  fieldType.getRawType()  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  fieldType.getRawType()  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  incompatible  types	11	None	replace
104	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped.getType()  :  fieldType;  [CE]  cannot  find  symbol  [FE]              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped.getType()  :  fieldType;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType!=  null?  mapped.getType()  :  fieldType;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
105	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getType()!=  null?  fieldType.getType()  :  mapped;  [CE]  incompatible  types  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fieldType.getType()!=  null?  fieldType.getType()  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fieldType.getType()!=  null?  fieldType.getType()  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    fieldType.getType()    :    mapped;    	non-compiled	[CE]  incompatible  types	11	None	replace
106	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getRawClass());  [CE]  ';'  expected  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getRawClass());  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getRawClass());	  final    TypeAdapter    <?>    typeAdapter    =    mapped,    fieldType.getRawType());    	non-compiled	[CE]  ';'  expected	12	None	replace
107	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getRawType()  ||  jsonAdapterPresent);  [CE]  ';'  expected  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getRawType()  ||  jsonAdapterPresent);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.getRawType()  ||  jsonAdapterPresent);	  final    TypeAdapter    <?>    typeAdapter    =    mapped,    fieldType.getRawType());    	non-compiled	[CE]  ';'  expected	12	None	replace
108	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(fieldType,  constructorConstructor,  mapped);  [CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(fieldType,  constructorConstructor,  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(fieldType,  constructorConstructor,  mapped);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    fieldType,    mapped);    	non-compiled	[CE]  method  getTypeAdapter  in  class  JsonAdapterAnnotationTypeAdapterFactory  cannot  be  applied  to  given  types;	3	None	replace
109	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.type  ||  jsonAdapterPresent;  [CE]  cannot  find  symbol  type  [FE]        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.type  ||  jsonAdapterPresent;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.type  ||  jsonAdapterPresent;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.type;    	non-compiled	[CE]  cannot  find  symbol  type	1	None	replace
110	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.type;  [CE]  ';'  expected  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.type;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.type;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.type;    	non-compiled	[CE]  ';'  expected	1	None	replace
111	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAccessor;  [CE]  cannot  find  symbol  typeAccessor  [FE]            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAccessor;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped.typeAccessor;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.type;    	non-compiled	[CE]  cannot  find  symbol  typeAccessor	1	None	replace
112	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.typeAdapter;  [CE]  ';'  expected  [FE]                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.typeAdapter;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped,  fieldType.typeAdapter;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.typeAdapter;    	non-compiled	[CE]  ';'  expected	5	None	replace
113	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  field.typeAdapter;  [CE]  cannot  find  symbol  typeAdapter  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  field.typeAdapter;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  field.typeAdapter;	  final    TypeAdapter    <?>    typeAdapter    =    mapped.typeAdapter;    	non-compiled	[CE]  cannot  find  symbol  typeAdapter	5	None	replace
114	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  field.getTypeAdapter(mapped);  [CE]  ';'  expected  [FE]                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  field.getTypeAdapter(mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  jsonAdapterPresent,  field.getTypeAdapter(mapped);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(jsonAdapterPresent);    	non-compiled	[CE]  ';'  expected	6	None	replace
115	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(compiler,  fieldType,  mapped);  [CE]  cannot  find  symbol  compiler  [FE]          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(compiler,  fieldType,  mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  getTypeAdapter(compiler,  fieldType,  mapped);	  final    TypeAdapter    <?>    typeAdapter    =    getTypeAdapter(constructorConstructor,    context,    fieldType,    mapped);    	non-compiled	[CE]  cannot  find  symbol  compiler	10	None	replace
116	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fields.getTypeAdapter(mapped);  [CE]  cannot  find  symbol  fields  [FE]                    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  fields.getTypeAdapter(mapped);  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  fields.getTypeAdapter(mapped);	  final    TypeAdapter    <?>    typeAdapter    =    mapped.getTypeAdapter(fieldType);    	non-compiled	[CE]  cannot  find  symbol  fields	7	None	replace
117	[BUG]  [BUGGY]  TypeToken  <?>  serialize  =  mapped.getType();  [CE]  variable  serialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]                      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  <?>  serialize  =  mapped.getType();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  <?>  serialize  =  mapped.getType();	      	non-compiled	[CE]  variable  serialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	8	None	replace
118	[BUG]  [BUGGY]  TypeToken  <?>  serialize  =  field.getRawType();  [CE]  variable  serialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]                        ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  <?>  serialize  =  field.getRawType();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  <?>  serialize  =  field.getRawType();	      	non-compiled	[CE]  variable  serialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	8	None	replace
119	[BUG]  [BUGGY]  TypeToken  <?>  deserialize  =  mapped.getType();  [CE]  variable  deserialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]                          ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  <?>  deserialize  =  mapped.getType();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  <?>  deserialize  =  mapped.getType();	      	non-compiled	[CE]  variable  deserialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	8	None	replace
120	[BUG]  [BUGGY]  TypeToken  <?>  serializedName  =  jsonAdapterPresent.getType();  [CE]  boolean  cannot  be  dereferenced  [FE]                            ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  <?>  serializedName  =  jsonAdapterPresent.getType();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  <?>  serializedName  =  jsonAdapterPresent.getType();	      	non-compiled	[CE]  boolean  cannot  be  dereferenced	8	None	replace
121	[BUG]  [BUGGY]  TypeToken  <?>  serialize  =  mapped.getRawType();  [CE]  variable  serialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]                              ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  <?>  serialize  =  mapped.getRawType();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  <?>  serialize  =  mapped.getRawType();	      	non-compiled	[CE]  variable  serialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	8	None	replace
122	[BUG]  [BUGGY]  TypeToken  <?>  serialize  =  jsonAdapterPresent;  [CE]  variable  serialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)  [FE]                                ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  <?>  serialize  =  jsonAdapterPresent;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  <?>  serialize  =  jsonAdapterPresent;	      	non-compiled	[CE]  variable  serialize  is  already  defined  in  method  createBoundField(Gson,Field,String,TypeToken<?>,boolean,boolean)	8	None	replace
123	[BUG]  [BUGGY]  TypeToken  <?>  serializedName  =  mapped.getType();  [CE]  cannot  find  symbol  [FE]                                  ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  TypeToken  <?>  serializedName  =  mapped.getType();  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	TypeToken  <?>  serializedName  =  mapped.getType();	      	non-compiled	[CE]  cannot  find  symbol	8	None	replace
124	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  fieldType  :  mapped;  [CE]  incompatible  types  [FE]    ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  fieldType  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  fieldType  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	non-compiled	[CE]  incompatible  types	14	None	replace
125	[BUG]  [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped.type  :  mapped;  [CE]  cannot  find  symbol  type  [FE]      ComparisonFailure    [CONTEXT]    final  boolean  isPrimitive  =  Primitives.isPrimitive(fieldType.getRawType());  JsonAdapter  annotation  =  field.getAnnotation(JsonAdapter.class);  TypeAdapter<?>  mapped  =  null;  if  (annotation  !=  null)  {  mapped  =  getTypeAdapter(constructorConstructor,  context,  fieldType,  annotation);  }  final  boolean  jsonAdapterPresent  =  mapped  !=  null;  if  (mapped  ==  null)  mapped  =  context.getAdapter(fieldType);    [BUGGY]  final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped.type  :  mapped;  [BUGGY]    return  new  ReflectiveTypeAdapterFactory.BoundField(name,  serialize,  deserialize)  {  @SuppressWarnings({   "unchecked   ",     "rawtypes   "})  //  the  type  adapter  and  field  type  always  agree  @Override  void  write(JsonWriter  writer,  Object  value)  throws  IOException,  IllegalAccessException  {  Object  fieldValue  =  field.get(value);  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  t.write(writer,  fieldValue);  }  @Override  void  read(JsonReader  reader,  Object  value)  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  createBoundField  [RETURN_TYPE]  ReflectiveTypeAdapterFactory$BoundField  Gson  context  Field  field  String  name  TypeToken<?>  fieldType  boolean  serialize  boolean  deserialize  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  JsonAdapter  annotation  Excluder  excluder  JsonWriter  writer  FieldNamingStrategy  fieldNamingPolicy  ConstructorConstructor  constructorConstructor  Field  field  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  fieldType  ObjectConstructor  constructor  TypeAdapter  mapped  t  typeAdapter  JsonReader  reader  Object  fieldValue  value  Map  boundFields  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	116	116	1	replace	final  TypeAdapter  <?>  typeAdapter  =  mapped!=  null?  mapped.type  :  mapped;	  final    TypeAdapter    <?>    typeAdapter    =    mapped!=    null?    mapped    :    mapped;    	non-compiled	[CE]  cannot  find  symbol  type	14	None	replace
