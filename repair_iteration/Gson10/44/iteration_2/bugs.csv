bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  if(previous!=  null  &&  fieldNames.size()  >  0)  {  [CE]  illegal  start  of  expression  [FE]    ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  if(previous!=  null  &&  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    fieldNames.size()    >    0)    {    if(previous!=  null  &&  fieldNames.size()  >  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	12	None	add
2	[BUG]  [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  if(previous  ==  null  &&  fieldNames.size()  >  0)  {  [CE]  illegal  start  of  expression  [FE]      ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  if(previous  ==  null  &&  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    fieldNames.size()    >    0)    {    if(previous  ==  null  &&  fieldNames.size()  >  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	12	None	add
3	[BUG]  [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  If(previous!=  null  &&  fieldNames.size()  >  0)  {  [CE]  ';'  expected  [FE]        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  If(previous!=  null  &&  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    fieldNames.size()    >    0)    {    If(previous!=  null  &&  fieldNames.size()  >  0)  {	  	non-compiled	[CE]  ';'  expected	12	None	add
4	[BUG]  [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  if(previous  >=  null  &&  fieldNames.size()  >  0)  {  [CE]  illegal  start  of  expression  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  if(previous  >=  null  &&  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    fieldNames.size()    >    0)    {    if(previous  >=  null  &&  fieldNames.size()  >  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	12	None	add
5	[BUG]  [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  if(previous  >>  null  &&  fieldNames.size()  >  0)  {  [CE]  illegal  start  of  expression  [FE]            ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  if(previous  >>  null  &&  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    fieldNames.size()    >    0)    {    if(previous  >>  null  &&  fieldNames.size()  >  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	12	None	add
6	[BUG]  [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  if(previous!=  null  &&  fields.size()  >  0)  {  [CE]  illegal  start  of  expression  [FE]              ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  0)  {  if(previous!=  null  &&  fields.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    fieldNames.size()    >    0)    {    if(previous!=  null  &&  fields.size()  >  0)  {	  	non-compiled	[CE]  illegal  start  of  expression	12	None	add
7	[BUG]  [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous!=  null  &&  previous.name!=  null)  {  [CE]  illegal  start  of  expression  [FE]    ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous!=  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    previous.name!=    null)    {    if(previous!=  null  &&  previous.name!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	10	None	add
8	[BUG]  [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous!=  null  &&  previous.name  ==  null)  {  [CE]  illegal  start  of  expression  [FE]      ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous!=  null  &&  previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    previous.name!=    null)    {    if(previous!=  null  &&  previous.name  ==  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	10	None	add
9	[BUG]  [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous  ==  null  &&  previous.name!=  null)  {  [CE]  illegal  start  of  expression  [FE]        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous  ==  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    previous.name!=    null)    {    if(previous  ==  null  &&  previous.name!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	10	None	add
10	[BUG]  [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  If(previous!=  null  &&  previous.name!=  null)  {  [CE]  ';'  expected  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  If(previous!=  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    previous.name!=    null)    {    If(previous!=  null  &&  previous.name!=  null)  {	  	non-compiled	[CE]  ';'  expected	10	None	add
11	[BUG]  [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous!=  null  &&  previous.name  >=  null)  {  [CE]  illegal  start  of  expression  [FE]            ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous!=  null  &&  previous.name  >=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    previous.name!=    null)    {    if(previous!=  null  &&  previous.name  >=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	10	None	add
12	[BUG]  [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous  >=  null  &&  previous.name!=  null)  {  [CE]  illegal  start  of  expression  [FE]              ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous  >=  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    previous.name!=    null)    {    if(previous  >=  null  &&  previous.name!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	10	None	add
13	[BUG]  [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous!=  null  &&  previous.name  >>  null)  {  [CE]  illegal  start  of  expression  [FE]                ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  previous.name!=  null)  {  if(previous!=  null  &&  previous.name  >>  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=    null    &&    previous.name!=    null)    {    if(previous!=  null  &&  previous.name  >>  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	10	None	add
14	[BUG]  [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  {  [CE]  illegal  start  of  expression  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous    ==    null)    {    if  (previous  ==  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
15	[BUG]  [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  [CE]  illegal  start  of  expression  [FE]      NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous    ==    null)    {    if  (previous  ==  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
16	[BUG]  [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [CE]  illegal  start  of  type  [FE]        NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous    ==    null)    {    if  (previous  ==  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }	  	non-compiled	[CE]  illegal  start  of  type	1	None	add
17	[BUG]  [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  [CE]  illegal  start  of  type  [FE]          NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous    ==    null)    {    if  (previous  ==  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);	  	non-compiled	[CE]  illegal  start  of  type	1	None	add
18	[BUG]  [BUGGY]  if  (previous  ==  null)  {  if  (previous!=  null)  {  [CE]  illegal  start  of  expression  [FE]            NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous  ==  null)  {  if  (previous!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous    ==    null)    {    if  (previous!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
19	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]              NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if    (previous    ==    null)    {    if  (previous  ==  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }	  	compilable	  [FE]  NullPointerException  	1	9	add
20	[BUG]  [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [FE]  NullPointerException  [FE]              NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous    ==    null)    {    if  (previous  ==  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }	  	compilable	  [FE]  NullPointerException  	1	9	add
21	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  ||  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous  ==  null  ||  previous.name!=  null)  {	  if(previous    [Delete]    null)    {    	compilable	  [FE]  NullPointerException  	9	9	replace
22	[BUG]  [BUGGY]  if(previous  ==  null  ||  previous.name!=  null)  {  [FE]  NullPointerException  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  ||  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous  ==  null  ||  previous.name!=  null)  {	  if(previous    [Delete]    null)    {    	compilable	  [FE]  NullPointerException  	9	9	replace
23	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]            ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous!=  null  ||  previous.name  ==  null)  {	  if(previous    [Delete]    null)    {    	compilable	  [FE]  NullPointerException  	9	9	replace
24	[BUG]  [BUGGY]  if(previous!=  null  ||  previous.name  ==  null)  {  [FE]  NullPointerException  [FE]            ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  ||  previous.name  ==  null)  {	  if(previous    [Delete]    null)    {    	compilable	  [FE]  NullPointerException  	9	9	replace
25	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]              ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous.name  ==  null)  {	  if(previous    [Delete]    null)    {    	compilable	  [FE]  NullPointerException  	9	9	replace
26	[BUG]  [BUGGY]  if(previous.name  ==  null)  {  [FE]  NullPointerException  [FE]              ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name  ==  null)  {	  if(previous    [Delete]    null)    {    	compilable	  [FE]  NullPointerException  	9	9	replace
27	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]    ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous  ==  null  &&  previous.name!=  null)  {	  if(previous!=    null    &&    previous.name!=    null)    {    	compilable	  [FE]  NullPointerException  	11	9	replace
28	[BUG]  [BUGGY]  if(previous  ==  null  &&  previous.name!=  null)  {  [FE]  NullPointerException  [FE]    ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous  ==  null  &&  previous.name!=  null)  {	  if(previous!=    null    &&    previous.name!=    null)    {    	compilable	  [FE]  NullPointerException  	11	9	replace
29	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]      ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(declaredType!=  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(declaredType!=  null  &&  previous.name!=  null)  {	  if(previous!=    null    &&    previous.name!=    null)    {    	compilable	  [FE]  NullPointerException  	11	9	replace
30	[BUG]  [BUGGY]  if(declaredType!=  null  &&  previous.name!=  null)  {  [FE]  NullPointerException  [FE]      ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(declaredType!=  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(declaredType!=  null  &&  previous.name!=  null)  {	  if(previous!=    null    &&    previous.name!=    null)    {    	compilable	  [FE]  NullPointerException  	11	9	replace
31	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(declaredType  ==  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(declaredType  ==  null  &&  previous.name!=  null)  {	  if(previous!=    null    &&    previous.name!=    null)    {    	compilable	  [FE]  ComparisonFailure  	11	1	replace
32	[BUG]  [BUGGY]  if(declaredType  ==  null  &&  previous.name!=  null)  {  [FE]  ComparisonFailure  [FE]        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(declaredType  ==  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(declaredType  ==  null  &&  previous.name!=  null)  {	  if(previous!=    null    &&    previous.name!=    null)    {    	compilable	  [FE]  ComparisonFailure  	11	1	replace
33	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous!=  null  &&  previous.name  ==  null)  {	  if(previous!=    null    &&    previous.name!=    null)    {    	compilable	  [FE]  ComparisonFailure  	11	1	replace
34	[BUG]  [BUGGY]  if(previous!=  null  &&  previous.name  ==  null)  {  [FE]  ComparisonFailure  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  &&  previous.name  ==  null)  {	  if(previous!=    null    &&    previous.name!=    null)    {    	compilable	  [FE]  ComparisonFailure  	11	1	replace
35	[BUG]  [BUGGY]  Field[]  fields  =  fieldNames.toArray(new  Field[fields.size()  ]);  [CE]  illegal  start  of  type  [FE]              ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  fieldNames.toArray(new  Field[fields.size()  ]);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  fieldNames.toArray(new  Field[fields.size()  ]);	      	non-compiled	[CE]  illegal  start  of  type	7	None	replace
36	[BUG]  [BUGGY]  Field[]  fields  =  boundFields.toArray(new  Field[fields.size()  ]);  [CE]  illegal  start  of  type  [FE]                ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  boundFields.toArray(new  Field[fields.size()  ]);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  boundFields.toArray(new  Field[fields.size()  ]);	      	non-compiled	[CE]  illegal  start  of  type	7	None	replace
37	[BUG]  [BUGGY]  Field[]  fields  =  boundField.getFields();  [CE]  illegal  start  of  type  [FE]                  ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  boundField.getFields();  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  boundField.getFields();	      	non-compiled	[CE]  illegal  start  of  type	7	None	replace
38	[BUG]  [BUGGY]  Field[]  fields  =  boundField.getFields();  if(fields!=  null)  {  for(int  i  =  0;  i  <  fields.size();  ++i)  {  throw  new  IllegalArgumentException( " ");  }  [CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)  [FE]                    ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  boundField.getFields();  if(fields!=  null)  {  for(int  i  =  0;  i  <  fields.size();  ++i)  {  throw  new  IllegalArgumentException( " ");  }  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  boundField.getFields();  if(fields!=  null)  {  for(int  i  =  0;  i  <  fields.size();  ++i)  {  throw  new  IllegalArgumentException( " ");  }	      	non-compiled	[CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)	7	None	replace
39	[BUG]  [BUGGY]  Field[]  fields  =  boundField.getFields();  for(int  i  =  0;  i  <  fields.size();  ++i)  {  String  name  =  fieldNames[i];  if(name!=  null)  {  throw  new  IllegalArgumentException(name  + "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)  [FE]                      ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  boundField.getFields();  for(int  i  =  0;  i  <  fields.size();  ++i)  {  String  name  =  fieldNames[i];  if(name!=  null)  {  throw  new  IllegalArgumentException(name  + "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  boundField.getFields();  for(int  i  =  0;  i  <  fields.size();  ++i)  {  String  name  =  fieldNames[i];  if(name!=  null)  {  throw  new  IllegalArgumentException(name  + "  declares  multiple  JSON  fields  named   "  +  previous.name);  }	      	non-compiled	[CE]  variable  fields  is  already  defined  in  method  getBoundFields(Gson,TypeToken<?>,Class<?>)	7	None	replace
40	[BUG]  [BUGGY]  Field[]  fields  =  boundField.getFields();  for(int  i  =  0;  i  <  fields.size();  ++i)  {  String  name  =  fieldNames[i];  if(name!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named  [CE]  unclosed  string  literal  [FE]                        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  boundField.getFields();  for(int  i  =  0;  i  <  fields.size();  ++i)  {  String  name  =  fieldNames[i];  if(name!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  boundField.getFields();  for(int  i  =  0;  i  <  fields.size();  ++i)  {  String  name  =  fieldNames[i];  if(name!=  null)  {  throw  new  IllegalArgumentException(declaredType  + "  declares  multiple  JSON  fields  named	      	non-compiled	[CE]  unclosed  string  literal	7	None	replace
41	[BUG]  [BUGGY]  Field[]  fields  =  boundField.getFields();  for(int  i  =  0;  i  <  fields.size();  ++i)  {  String  name  =  fieldNames[i];  if(name!=  null)  {  throw  new  IllegalArgumentException(name  + "  declares  multiple  JSON  fields  named  [CE]  unclosed  string  literal  [FE]                          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  boundField.getFields();  for(int  i  =  0;  i  <  fields.size();  ++i)  {  String  name  =  fieldNames[i];  if(name!=  null)  {  throw  new  IllegalArgumentException(name  + "  declares  multiple  JSON  fields  named  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  boundField.getFields();  for(int  i  =  0;  i  <  fields.size();  ++i)  {  String  name  =  fieldNames[i];  if(name!=  null)  {  throw  new  IllegalArgumentException(name  + "  declares  multiple  JSON  fields  named	      	non-compiled	[CE]  unclosed  string  literal	7	None	replace
42	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]    ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  &&  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous  ==  null  &&  fieldNames.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  NullPointerException  	13	9	replace
43	[BUG]  [BUGGY]  if(previous  ==  null  &&  fieldNames.size()  >  0)  {  [FE]  NullPointerException  [FE]    ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  &&  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous  ==  null  &&  fieldNames.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  NullPointerException  	13	9	replace
44	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]      ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous!=  null  ||  fieldNames.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  NullPointerException  	13	9	replace
45	[BUG]  [BUGGY]  if(previous!=  null  ||  fieldNames.size()  >  0)  {  [FE]  NullPointerException  [FE]      ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  ||  fieldNames.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  NullPointerException  	13	9	replace
46	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(fieldNames!=  null  &&  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(fieldNames!=  null  &&  fieldNames.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  NullPointerException  	13	9	replace
47	[BUG]  [BUGGY]  if(fieldNames!=  null  &&  fieldNames.size()  >  0)  {  [FE]  NullPointerException  [FE]        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(fieldNames!=  null  &&  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(fieldNames!=  null  &&  fieldNames.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  NullPointerException  	13	9	replace
48	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  ||  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous  ==  null  ||  fieldNames.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  NullPointerException  	13	9	replace
49	[BUG]  [BUGGY]  if(previous  ==  null  ||  fieldNames.size()  >  0)  {  [FE]  NullPointerException  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  ||  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous  ==  null  ||  fieldNames.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  NullPointerException  	13	9	replace
50	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]            ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  1)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous!=  null  &&  fieldNames.size()  >  1)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  ComparisonFailure  	13	1	replace
51	[BUG]  [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  1)  {  [FE]  ComparisonFailure  [FE]            ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.size()  >  1)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  &&  fieldNames.size()  >  1)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  ComparisonFailure  	13	1	replace
52	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]              ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(fieldNames!=  null  ||  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(fieldNames!=  null  ||  fieldNames.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  NullPointerException  	13	9	replace
53	[BUG]  [BUGGY]  if(fieldNames!=  null  ||  fieldNames.size()  >  0)  {  [FE]  NullPointerException  [FE]              ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(fieldNames!=  null  ||  fieldNames.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(fieldNames!=  null  ||  fieldNames.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  NullPointerException  	13	9	replace
54	[BUG]  [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  if  (previous!=  null  ||  previous.name!=  null)  {  [CE]  illegal  start  of  expression  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  if  (previous!=  null  ||  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous!=    null    ||    previous.name!=    null)    {    if  (previous!=  null  ||  previous.name!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
55	[BUG]  [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  if  (previous  ==  null  ||  previous.name!=  null)  {  [CE]  illegal  start  of  expression  [FE]      NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  if  (previous  ==  null  ||  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous!=    null    ||    previous.name!=    null)    {    if  (previous  ==  null  ||  previous.name!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
56	[BUG]  [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  if  (previous!=  null  ||  previous.name  ==  null)  {  [CE]  illegal  start  of  expression  [FE]        NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  if  (previous!=  null  ||  previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous!=    null    ||    previous.name!=    null)    {    if  (previous!=  null  ||  previous.name  ==  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
57	[BUG]  [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  If  (previous!=  null  ||  previous.name!=  null)  {  [CE]  ';'  expected  [FE]          NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  If  (previous!=  null  ||  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous!=    null    ||    previous.name!=    null)    {    If  (previous!=  null  ||  previous.name!=  null)  {	  	non-compiled	[CE]  ';'  expected	5	None	add
58	[BUG]  [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  if  (previous  >=  null  ||  previous.name!=  null)  {  [CE]  illegal  start  of  expression  [FE]            NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  if  (previous  >=  null  ||  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous!=    null    ||    previous.name!=    null)    {    if  (previous  >=  null  ||  previous.name!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
59	[BUG]  [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  if  (previous!=  null  ||  previous.name  >=  null)  {  [CE]  illegal  start  of  expression  [FE]              NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous!=  null  ||  previous.name!=  null)  {  if  (previous!=  null  ||  previous.name  >=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous!=    null    ||    previous.name!=    null)    {    if  (previous!=  null  ||  previous.name  >=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
60	[BUG]  [BUGGY]  if(previous.name!=  null)  {  if(previous.name!=  null)  {  [CE]  illegal  start  of  expression  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null)  {  if(previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=    null)    {    if(previous.name!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
61	[BUG]  [BUGGY]  if(previous.name!=  null)  {  if(previous.name  ==  null)  {  [CE]  illegal  start  of  expression  [FE]      NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null)  {  if(previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=    null)    {    if(previous.name  ==  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
62	[BUG]  [BUGGY]  if(previous.name!=  null)  {  If(previous.name!=  null)  {  [CE]  ';'  expected  [FE]        NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null)  {  If(previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=    null)    {    If(previous.name!=  null)  {	  	non-compiled	[CE]  ';'  expected	3	None	add
63	[BUG]  [BUGGY]  if(previous.name!=  null)  {  if(previous.name  >=  null)  {  [CE]  illegal  start  of  expression  [FE]          NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null)  {  if(previous.name  >=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=    null)    {    if(previous.name  >=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
64	[BUG]  [BUGGY]  if(previous.name!=  null)  {  if(previous.name  >>  null)  {  [CE]  illegal  start  of  expression  [FE]            NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null)  {  if(previous.name  >>  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=    null)    {    if(previous.name  >>  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
65	[BUG]  [BUGGY]  if(previous.name!=  null)  {  if(previous.name  [BUGGY]  null)  {  [CE]  ')'  expected  [FE]              NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null)  {  if(previous.name  [BUGGY]  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=    null)    {    if(previous.name  [BUGGY]  null)  {	  	non-compiled	[CE]  ')'  expected	3	None	add
66	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null  ||  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous.name!=  null  ||  previous.name!=  null)  {	  if(previous.name!=    null)    {    	compilable	  [FE]  NullPointerException  	4	9	replace
67	[BUG]  [BUGGY]  if(previous.name!=  null  ||  previous.name!=  null)  {  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null  ||  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=  null  ||  previous.name!=  null)  {	  if(previous.name!=    null)    {    	compilable	  [FE]  NullPointerException  	4	9	replace
68	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null  ||  previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous.name!=  null  ||  previous.name  ==  null)  {	  if(previous.name!=    null)    {    	compilable	  [FE]  NullPointerException  	4	9	replace
69	[BUG]  [BUGGY]  if(previous.name!=  null  ||  previous.name  ==  null)  {  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null  ||  previous.name  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=  null  ||  previous.name  ==  null)  {	  if(previous.name!=    null)    {    	compilable	  [FE]  NullPointerException  	4	9	replace
70	[BUG]  [BUGGY]  if(previous.name!=  null)  {  if(previous.name!=  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  [CE]  illegal  start  of  expression  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null)  {  if(previous.name!=  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=    null)    {    if(previous.name!=  null)  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
71	[BUG]  [BUGGY]  if(previous.name!=  null)  {  if(previous.name!=  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  [CE]  illegal  start  of  type  [FE]      NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null)  {  if(previous.name!=  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=    null)    {    if(previous.name!=  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);	  	non-compiled	[CE]  illegal  start  of  type	3	None	add
72	[BUG]  [BUGGY]  if(previous.name!=  null)  {  if(previous.name!=  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [CE]  illegal  start  of  type  [FE]        NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null)  {  if(previous.name!=  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=    null)    {    if(previous.name!=  null)  <  throw  new  IllegalArgumentException(declaredType  +   "  declares  multiple  JSON  fields  named   "  +  previous.name);  }	  	non-compiled	[CE]  illegal  start  of  type	3	None	add
73	[BUG]  [BUGGY]  Field[]  fields  =  boundFields.toArray(new  Field[fieldNames.size()  ]);  [CE]  illegal  start  of  type  [FE]              ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  boundFields.toArray(new  Field[fieldNames.size()  ]);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  boundFields.toArray(new  Field[fieldNames.size()  ]);	      	non-compiled	[CE]  illegal  start  of  type	7	None	replace
74	[BUG]  [BUGGY]  Field[]  raw  =  fieldNames.toArray(new  Field[fieldNames.size()  ]);  [CE]  illegal  start  of  type  [FE]                ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  raw  =  fieldNames.toArray(new  Field[fieldNames.size()  ]);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  raw  =  fieldNames.toArray(new  Field[fieldNames.size()  ]);	      	non-compiled	[CE]  illegal  start  of  type	7	None	replace
75	[BUG]  [BUGGY]  Field[]  fields  =  fieldNames.toArray(new  Field[fieldNames.size()  ]);  [CE]  illegal  start  of  type  [FE]                  ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  fieldNames.toArray(new  Field[fieldNames.size()  ]);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  fieldNames.toArray(new  Field[fieldNames.size()  ]);	      	non-compiled	[CE]  illegal  start  of  type	7	None	replace
76	[BUG]  [BUGGY]  Field[]  raw  =  fieldNames.toArray(new  Field[fields.size()  ]);  [CE]  illegal  start  of  type  [FE]                    ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  raw  =  fieldNames.toArray(new  Field[fields.size()  ]);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  raw  =  fieldNames.toArray(new  Field[fields.size()  ]);	      	non-compiled	[CE]  illegal  start  of  type	7	None	replace
77	[BUG]  [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null  ||  previous.name!=  null)  {  [CE]  illegal  start  of  expression  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null  ||  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous    ==    null)    {    if  (previous  ==  null  ||  previous.name!=  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
78	[BUG]  [BUGGY]  if  (previous  ==  null)  {  If  (previous  ==  null)  {  [CE]  ';'  expected  [FE]      NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous  ==  null)  {  If  (previous  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous    ==    null)    {    If  (previous  ==  null)  {	  	non-compiled	[CE]  ';'  expected	1	None	add
79	[BUG]  [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null  ||  declaredType  ==  null)  {  [CE]  illegal  start  of  expression  [FE]        NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if  (previous  ==  null)  {  if  (previous  ==  null  ||  declaredType  ==  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if    (previous    ==    null)    {    if  (previous  ==  null  ||  declaredType  ==  null)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
80	[BUG]  [BUGGY]  if(previous!=  null  &&  fields.size()  >  0)  {  [CE]  cannot  find  symbol  [FE]    ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fields.size()  >  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  &&  fields.size()  >  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	non-compiled	[CE]  cannot  find  symbol	13	None	replace
81	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]      ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.size()  ==  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous!=  null  &&  fieldNames.size()  ==  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  ComparisonFailure  	13	1	replace
82	[BUG]  [BUGGY]  if(previous!=  null  &&  fieldNames.size()  ==  0)  {  [FE]  ComparisonFailure  [FE]      ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.size()  ==  0)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  &&  fieldNames.size()  ==  0)  {	  if(previous!=    null    &&    fieldNames.size()    >    0)    {    	compilable	  [FE]  ComparisonFailure  	13	1	replace
83	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  raw.getGenericSuperclass()!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous!=  null  ||  raw.getGenericSuperclass()!=  null)  {	  if(previous    >=    null)    {    	compilable	  [FE]  NullPointerException  	8	9	replace
84	[BUG]  [BUGGY]  if(previous!=  null  ||  raw.getGenericSuperclass()!=  null)  {  [FE]  NullPointerException  [FE]        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  raw.getGenericSuperclass()!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  ||  raw.getGenericSuperclass()!=  null)  {	  if(previous    >=    null)    {    	compilable	  [FE]  NullPointerException  	8	9	replace
85	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  fieldNames.contains(previous.name))  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous!=  null  ||  fieldNames.contains(previous.name))  {	  if(previous    >=    null)    {    	compilable	  [FE]  NullPointerException  	8	9	replace
86	[BUG]  [BUGGY]  if(previous!=  null  ||  fieldNames.contains(previous.name))  {  [FE]  NullPointerException  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  fieldNames.contains(previous.name))  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  ||  fieldNames.contains(previous.name))  {	  if(previous    >=    null)    {    	compilable	  [FE]  NullPointerException  	8	9	replace
87	[BUG]  [BUGGY]  if(previous!=  null  ||  fieldNames.containsKey(previous.name))  {  [CE]  cannot  find  symbol  [FE]            ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  fieldNames.containsKey(previous.name))  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  ||  fieldNames.containsKey(previous.name))  {	  if(previous    >=    null)    {    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
88	[BUG]  [BUGGY]  if(previous!=  null  ||  type.getGenericSuperclass()!=  null)  {  [CE]  cannot  find  symbol  [FE]              ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  type.getGenericSuperclass()!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  ||  type.getGenericSuperclass()!=  null)  {	  if(previous    >=    null)    {    	non-compiled	[CE]  cannot  find  symbol	8	None	replace
89	[BUG]  [BUGGY]  if(previous.name!=  null)  {  for(previous.name!=  null)  {  [CE]  not  a  statement  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null)  {  for(previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=    null)    {    for(previous.name!=  null)  {	  	non-compiled	[CE]  not  a  statement	3	None	add
90	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.contains(field))  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous!=  null  &&  fieldNames.contains(field))  {	  if(previous    >=    null)    {    	compilable	  [FE]  ComparisonFailure  	8	1	replace
91	[BUG]  [BUGGY]  if(previous!=  null  &&  fieldNames.contains(field))  {  [FE]  ComparisonFailure  [FE]        ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.contains(field))  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  &&  fieldNames.contains(field))  {	  if(previous    >=    null)    {    	compilable	  [FE]  ComparisonFailure  	8	1	replace
92	[BUG]  [BUGGY]  [FE]  ComparisonFailure  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.isEmpty())  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous!=  null  &&  fieldNames.isEmpty())  {	  if(previous    >=    null)    {    	compilable	  [FE]  ComparisonFailure  	8	1	replace
93	[BUG]  [BUGGY]  if(previous!=  null  &&  fieldNames.isEmpty())  {  [FE]  ComparisonFailure  [FE]          ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  fieldNames.isEmpty())  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  &&  fieldNames.isEmpty())  {	  if(previous    >=    null)    {    	compilable	  [FE]  ComparisonFailure  	8	1	replace
94	[BUG]  [BUGGY]  if(previous!=  null  ||  original.name!=  null)  {  [CE]  cannot  find  symbol  original  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  ||  original.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  ||  original.name!=  null)  {	  if    (previous!=    null    ||    previous.name!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  original	6	None	replace
95	[BUG]  [BUGGY]  if(previous  ==  null  ||!previous.name.equals(field.getGenericSuperclass()))  {  [CE]  cannot  find  symbol  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  ||!previous.name.equals(field.getGenericSuperclass()))  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous  ==  null  ||!previous.name.equals(field.getGenericSuperclass()))  {	  if    (previous    ==    null)    {    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
96	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  ||  fieldNames.contains(previous.name))  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous  ==  null  ||  fieldNames.contains(previous.name))  {	  if    (previous    ==    null)    {    	compilable	  [FE]  NullPointerException  	2	9	replace
97	[BUG]  [BUGGY]  if(previous  ==  null  ||  fieldNames.contains(previous.name))  {  [FE]  NullPointerException  [FE]      NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous  ==  null  ||  fieldNames.contains(previous.name))  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous  ==  null  ||  fieldNames.contains(previous.name))  {	  if    (previous    ==    null)    {    	compilable	  [FE]  NullPointerException  	2	9	replace
98	[BUG]  [BUGGY]  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	add	if(previous.name!=  null  &&  previous.name!=  null)  {	  if(previous.name!=    null)    {    	compilable	  [FE]  NullPointerException  	4	9	replace
99	[BUG]  [BUGGY]  if(previous.name!=  null  &&  previous.name!=  null)  {  [FE]  NullPointerException  [FE]    NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null  &&  previous.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=  null  &&  previous.name!=  null)  {	  if(previous.name!=    null)    {    	compilable	  [FE]  NullPointerException  	4	9	replace
100	[BUG]  [BUGGY]  if(previous.name!=  null  &&  original.name!=  null)  {  [CE]  cannot  find  symbol  original  [FE]      NullPointerException    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous.name!=  null  &&  original.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous.name!=  null  &&  original.name!=  null)  {	  if(previous.name!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  original	4	None	replace
101	[BUG]  [BUGGY]  if(previous!=  null  &&  original.name!=  null)  {  [CE]  cannot  find  symbol  original  [FE]    ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  if(previous!=  null  &&  original.name!=  null)  {  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	if(previous!=  null  &&  original.name!=  null)  {	  if(previous!=    null    &&    previous.name!=    null)    {    	non-compiled	[CE]  cannot  find  symbol  original	11	None	replace
102	[BUG]  [BUGGY]  Field[]  fields  =  fieldNames.toArray(replaced);  [CE]  illegal  start  of  type  [FE]              ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  fieldNames.toArray(replaced);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  fieldNames.toArray(replaced);	      	non-compiled	[CE]  illegal  start  of  type	7	None	replace
103	[BUG]  [BUGGY]  Field[]  fields  =  fieldNames.toArray(removed);  [CE]  illegal  start  of  type  [FE]                ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  fields  =  fieldNames.toArray(removed);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  fields  =  fieldNames.toArray(removed);	      	non-compiled	[CE]  illegal  start  of  type	7	None	replace
104	[BUG]  [BUGGY]  Field[]  raw  =  fieldNames.toArray(replaced);  [CE]  illegal  start  of  type  [FE]                  ComparisonFailure    [CONTEXT]    List<String>  fieldNames  =  getFieldNames(field);  BoundField  previous  =  null;  for  (int  i  =  0;  i  <  fieldNames.size();  ++i)  {  String  name  =  fieldNames.get(i);  if  (i  !=  0)  serialize  =  false;  //  only  serialize  the  default  name  BoundField  boundField  =  createBoundField(context,  field,  name,  TypeToken.get(fieldType),  serialize,  deserialize);  BoundField  replaced  =  result.put(name,  boundField);  if  (previous  ==  null)  previous  =  replaced;  }    [BUGGY]  Field[]  raw  =  fieldNames.toArray(replaced);  [BUGGY]    throw  new  IllegalArgumentException(declaredType  +     "  declares  multiple  JSON  fields  named     "  +  previous.name);  }  }  type  =  TypeToken.get($Gson$Types.resolve(type.getType(),  raw,  raw.getGenericSuperclass()));  raw  =  type.getRawType();  }  return  result;  }  [CLASS]  ReflectiveTypeAdapterFactory  1  BoundField  Adapter  [METHOD]  getBoundFields  [RETURN_TYPE]  Map  Gson  context  TypeToken<?>  type  Class<?>  raw  [VARIABLES]  Gson  context  String  $anonymous0  alternate  name  serializedName  Excluder  excluder  FieldNamingStrategy  fieldNamingPolicy  int  i  ConstructorConstructor  constructorConstructor  Field  field  Type  declaredType  fieldType  boolean  $anonymous1  $anonymous2  deserialize  deserialized  isPrimitive  jsonAdapterPresent  serialize  serialized  TypeToken  type  ObjectConstructor  constructor  Class  raw  List  fieldNames  Map  boundFields  result  Field[]  fields  BoundField  boundField  previous  replaced  	projects/Gson10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java	0.3333333333333333	168	168	1	replace	Field[]  raw  =  fieldNames.toArray(replaced);	      	non-compiled	[CE]  illegal  start  of  type	7	None	replace
