bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] headers.remove(keyword); [FE] NegativeArraySizeException [CONTEXT] if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL [BUGGY] headers.remove(keyword); [BUGGY] } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	472	472	1	replace	
2	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL [BUGGY] [BUGGY] headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.7071067811865475	472	472	1	add	
3	[BUG] [BUGGY] paxHeaders(); [FE] NegativeArraySizeException [CONTEXT] return null; } currEntry.setName(zipEncoding.decode(longNameData)); } if (currEntry.isGlobalPaxHeader()){ // Process Global Pax headers readGlobalPaxHeaders(); } if (currEntry.isPaxHeader()){ // Process Pax headers [BUGGY] paxHeaders(); [BUGGY] } else if (!globalPaxHeaders.isEmpty()) { applyPaxHeadersToCurrentEntry(globalPaxHeaders); } if (currEntry.isOldGNUSparse()){ // Process sparse files readOldGNUSparse(); }    [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5773502691896258	319	319	1	replace	
4	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] return null; } currEntry.setName(zipEncoding.decode(longNameData)); } if (currEntry.isGlobalPaxHeader()){ // Process Global Pax headers readGlobalPaxHeaders(); } if (currEntry.isPaxHeader()){ // Process Pax headers [BUGGY] [BUGGY] paxHeaders(); } else if (!globalPaxHeaders.isEmpty()) { applyPaxHeadersToCurrentEntry(globalPaxHeaders); } if (currEntry.isOldGNUSparse()){ // Process sparse files readOldGNUSparse(); }    [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5773502691896258	319	319	1	add	
5	[BUG] [BUGGY] final Map<String, String> headers = parsePaxHeaders(this); [FE] NegativeArraySizeException [CONTEXT] private void paxHeaders() throws IOException{ [BUGGY] final Map<String, String> headers = parsePaxHeaders(this); [BUGGY] getNextEntry(); // Get the actual file entry applyPaxHeadersToCurrentEntry(headers); } [CLASS] TarArchiveInputStream [METHOD] paxHeaders [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize length markLimit readNow recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5773502691896258	444	444	1	replace	
6	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] private void paxHeaders() throws IOException{ [BUGGY] [BUGGY] final Map<String, String> headers = parsePaxHeaders(this); getNextEntry(); // Get the actual file entry applyPaxHeadersToCurrentEntry(headers); } [CLASS] TarArchiveInputStream [METHOD] paxHeaders [RETURN_TYPE] void  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize length markLimit readNow recordSize long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.5773502691896258	444	444	1	add	
7	[BUG] [BUGGY] if (isDirectory()) { [FE] NegativeArraySizeException [CONTEXT] public int available() throws IOException { [BUGGY] if (isDirectory()) { [BUGGY] return 0; } if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	184	184	1	replace	
8	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] public int available() throws IOException { [BUGGY] [BUGGY] if (isDirectory()) { return 0; } if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	184	184	1	add	
9	[BUG] [BUGGY] if (entrySize - entryOffset > Integer.MAX_VALUE) { [FE] NegativeArraySizeException [CONTEXT] public int available() throws IOException { if (isDirectory()) { return 0; } [BUGGY] if (entrySize - entryOffset > Integer.MAX_VALUE) { [BUGGY] return Integer.MAX_VALUE; } return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	187	187	1	replace	
10	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] public int available() throws IOException { if (isDirectory()) { return 0; } [BUGGY] [BUGGY] if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	187	187	1	add	
11	[BUG] [BUGGY] return (int) (entrySize - entryOffset); [FE] NegativeArraySizeException [CONTEXT] public int available() throws IOException { if (isDirectory()) { return 0; } if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } [BUGGY] return (int) (entrySize - entryOffset); [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	190	190	1	replace	
12	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] public int available() throws IOException { if (isDirectory()) { return 0; } if (entrySize - entryOffset > Integer.MAX_VALUE) { return Integer.MAX_VALUE; } [BUGGY] [BUGGY] return (int) (entrySize - entryOffset); } [CLASS] TarArchiveInputStream [METHOD] available [RETURN_TYPE] int  [VARIABLES] byte[] SMALL_BUF boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize recordSize long entryOffset entrySize TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	190	190	1	add	
13	[BUG] [BUGGY] if (currEntry == null) { [FE] NegativeArraySizeException [CONTEXT] public int read(final byte[] buf, final int offset, int numToRead) throws IOException { int totalRead = 0; if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { return -1; } [BUGGY] if (currEntry == null) { [BUGGY] throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	648	648	1	replace	
14	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] public int read(final byte[] buf, final int offset, int numToRead) throws IOException { int totalRead = 0; if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { return -1; } [BUGGY] [BUGGY] if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	648	648	1	add	
15	[BUG] [BUGGY] numToRead = Math.min(numToRead, available()); [FE] NegativeArraySizeException [CONTEXT] int totalRead = 0; if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } [BUGGY] numToRead = Math.min(numToRead, available()); [BUGGY]  totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	652	652	1	replace	
16	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] int totalRead = 0; if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } [BUGGY] [BUGGY] numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	652	652	1	add	
17	[BUG] [BUGGY] totalRead = is.read(buf, offset, numToRead); [FE] NegativeArraySizeException [CONTEXT] if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); [BUGGY] totalRead = is.read(buf, offset, numToRead); [BUGGY]  if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	654	654	1	replace	
18	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); [BUGGY] [BUGGY] totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	654	654	1	add	
19	[BUG] [BUGGY] if (totalRead == -1) { [FE] NegativeArraySizeException [CONTEXT] } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [BUGGY] if (totalRead == -1) { [BUGGY] if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } return totalRead; [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	656	656	1	replace	
20	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [BUGGY] [BUGGY] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } return totalRead; [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	656	656	1	add	
21	[BUG] [BUGGY] count(totalRead); [FE] NegativeArraySizeException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { [BUGGY] count(totalRead); [BUGGY] entryOffset += totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	662	662	1	replace	
22	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { [BUGGY] [BUGGY] count(totalRead); entryOffset += totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	662	662	1	add	
23	[BUG] [BUGGY] entryOffset += totalRead; [FE] NegativeArraySizeException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); [BUGGY] entryOffset += totalRead; [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	663	663	1	replace	
24	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); [BUGGY] [BUGGY] entryOffset += totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	663	663	1	add	
25	[BUG] [BUGGY] return totalRead; [FE] NegativeArraySizeException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } [BUGGY] return totalRead; [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	666	666	1	replace	
26	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (totalRead == -1) { if (numToRead > 0) { throw new IOException("Truncated TAR archive"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } [BUGGY] [BUGGY] return totalRead; } [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.3779644730092272	666	666	1	add	
27	[BUG] [BUGGY] final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders); [FE] NegativeArraySizeException [CONTEXT] throws IOException { [BUGGY] final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders); [BUGGY]  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	454	454	1	replace	
28	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] throws IOException { [BUGGY] [BUGGY] final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	454	454	1	add	
29	[BUG] [BUGGY] int len = 0; [FE] NegativeArraySizeException [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; [BUGGY] int len = 0; [BUGGY] int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	458	458	1	replace	
30	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; [BUGGY] [BUGGY] int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	458	458	1	add	
31	[BUG] [BUGGY] int read = 0; [FE] NegativeArraySizeException [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; [BUGGY] int read = 0; [BUGGY] while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	459	459	1	replace	
32	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; [BUGGY] [BUGGY] int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	459	459	1	add	
33	[BUG] [BUGGY] while((ch = i.read()) != -1) { [FE] NegativeArraySizeException [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; int read = 0; [BUGGY] while((ch = i.read()) != -1) { [BUGGY] read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	460	460	1	replace	
34	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; int read = 0; [BUGGY] [BUGGY] while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	460	460	1	add	
35	[BUG] [BUGGY] read++; [FE] NegativeArraySizeException [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { [BUGGY] read++; [BUGGY] if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	461	461	1	replace	
36	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { [BUGGY] [BUGGY] read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	461	461	1	add	
37	[BUG] [BUGGY] if (ch == ' '){ [FE] NegativeArraySizeException [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; [BUGGY] if (ch == ' '){ [BUGGY]  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	462	462	1	replace	
38	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] throws IOException { final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; [BUGGY] [BUGGY] if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	462	462	1	add	
39	[BUG] [BUGGY] final ByteArrayOutputStream coll = new ByteArrayOutputStream(); [FE] NegativeArraySizeException [CONTEXT] final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  [BUGGY] final ByteArrayOutputStream coll = new ByteArrayOutputStream(); [BUGGY] while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	464	464	1	replace	
40	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  [BUGGY] [BUGGY] final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	464	464	1	add	
41	[BUG] [BUGGY] while((ch = i.read()) != -1) { [FE] NegativeArraySizeException [CONTEXT]  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); [BUGGY] while((ch = i.read()) != -1) { [BUGGY] read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	465	465	1	replace	
42	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT]  while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); [BUGGY] [BUGGY] while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	465	465	1	add	
43	[BUG] [BUGGY] read++; [FE] NegativeArraySizeException [CONTEXT] while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { [BUGGY] read++; [BUGGY] if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	466	466	1	replace	
44	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] while(true){ // get length int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { [BUGGY] [BUGGY] read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	466	466	1	add	
45	[BUG] [BUGGY] if (ch == '='){ // end of keyword  final String keyword = coll.toString(CharsetNames.UTF_8); [FE] NegativeArraySizeException [CONTEXT] int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; [BUGGY] if (ch == '='){ // end of keyword       final String keyword = coll.toString(CharsetNames.UTF_8); [BUGGY] final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	467	468	1	replace	
46	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] int ch; int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; [BUGGY] [BUGGY] if (ch == '='){ // end of keyword       final String keyword = coll.toString(CharsetNames.UTF_8); final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	467	468	1	add	
47	[BUG] [BUGGY] final String keyword = coll.toString(CharsetNames.UTF_8); [FE] NegativeArraySizeException [CONTEXT] int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword [BUGGY] final String keyword = coll.toString(CharsetNames.UTF_8); [BUGGY]  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	468	468	1	replace	
48	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] int len = 0; int read = 0; while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword [BUGGY] [BUGGY] final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	468	468	1	add	
49	[BUG] [BUGGY] final int restLen = len - read; [FE] NegativeArraySizeException [CONTEXT] while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  [BUGGY] final int restLen = len - read; [BUGGY] if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	470	470	1	replace	
50	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] while((ch = i.read()) != -1) { read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  [BUGGY] [BUGGY] final int restLen = len - read; if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	470	470	1	add	
51	[BUG] [BUGGY] if (restLen == 1) { // only NL  headers.remove(keyword); [FE] NegativeArraySizeException [CONTEXT] read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; [BUGGY] if (restLen == 1) { // only NL        headers.remove(keyword); [BUGGY] headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	471	472	1	replace	
52	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] read++; if (ch == ' '){  final ByteArrayOutputStream coll = new ByteArrayOutputStream(); while((ch = i.read()) != -1) { read++; if (ch == '='){ // end of keyword final String keyword = coll.toString(CharsetNames.UTF_8);  final int restLen = len - read; [BUGGY] [BUGGY] if (restLen == 1) { // only NL        headers.remove(keyword); headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	471	472	1	add	
53	[BUG] [BUGGY] final byte[] rest = new byte[restLen]; [FE] NegativeArraySizeException [CONTEXT] if (restLen == 1) { // only NL headers.remove(keyword); } else { [BUGGY] final byte[] rest = new byte[restLen]; [BUGGY] final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  final String value = new String(rest, 0, [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	474	474	1	replace	
54	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (restLen == 1) { // only NL headers.remove(keyword); } else { [BUGGY] [BUGGY] final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  final String value = new String(rest, 0, [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	474	474	1	add	
55	[BUG] [BUGGY] final int got = IOUtils.readFully(i, rest); [FE] NegativeArraySizeException [CONTEXT] if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; [BUGGY] final int got = IOUtils.readFully(i, rest); [BUGGY] if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	475	475	1	replace	
56	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; [BUGGY] [BUGGY] final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	475	475	1	add	
57	[BUG] [BUGGY] if (got != restLen) { [FE] NegativeArraySizeException [CONTEXT] if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); [BUGGY] if (got != restLen) { [BUGGY] throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	476	476	1	replace	
58	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (restLen == 1) { // only NL headers.remove(keyword); } else { final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); [BUGGY] [BUGGY] if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	476	476	1	add	
59	[BUG] [BUGGY] final String value = new String(rest, 0,    restLen - 1, CharsetNames.UTF_8); [FE] NegativeArraySizeException [CONTEXT] final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  [BUGGY] final String value = new String(rest, 0,               restLen - 1, CharsetNames.UTF_8); [BUGGY] restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	484	485	1	replace	
60	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] final byte[] rest = new byte[restLen]; final int got = IOUtils.readFully(i, rest); if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  [BUGGY] [BUGGY] final String value = new String(rest, 0,               restLen - 1, CharsetNames.UTF_8); restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	484	485	1	add	
61	[BUG] [BUGGY] headers.put(keyword, value); [FE] NegativeArraySizeException [CONTEXT] if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); [BUGGY] headers.put(keyword, value); [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	486	486	1	replace	
62	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (got != restLen) { throw new IOException("Failed to read " + "Paxheader. Expected " + restLen + " bytes, read " + got); }  final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); [BUGGY] [BUGGY] headers.put(keyword, value); } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	486	486	1	add	
63	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] + "Paxheader. Expected " + restLen + " bytes, read " + got); }  final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	488	488	1	replace	
64	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] + "Paxheader. Expected " + restLen + " bytes, read " + got); }  final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	488	488	1	add	
65	[BUG] [BUGGY] coll.write((byte) ch); [FE] NegativeArraySizeException [CONTEXT] + " bytes, read " + got); }  final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); } break; } [BUGGY] coll.write((byte) ch); [BUGGY] } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	490	490	1	replace	
66	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] + " bytes, read " + got); }  final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); } break; } [BUGGY] [BUGGY] coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	490	490	1	add	
67	[BUG] [BUGGY] len *= 10; [FE] NegativeArraySizeException [CONTEXT] final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); } break; } coll.write((byte) ch); } break; // Processed single header } [BUGGY] len *= 10; [BUGGY] len += ch - '0'; } if (ch == -1){ // EOF break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	494	494	1	replace	
68	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); } break; } coll.write((byte) ch); } break; // Processed single header } [BUGGY] [BUGGY] len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	494	494	1	add	
69	[BUG] [BUGGY] len += ch - '0'; [FE] NegativeArraySizeException [CONTEXT] restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); } break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; [BUGGY] len += ch - '0'; [BUGGY] } if (ch == -1){ // EOF break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	495	495	1	replace	
70	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] restLen - 1, CharsetNames.UTF_8); headers.put(keyword, value); } break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; [BUGGY] [BUGGY] len += ch - '0'; } if (ch == -1){ // EOF break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	495	495	1	add	
71	[BUG] [BUGGY] if (ch == -1){ // EOF break; [FE] NegativeArraySizeException [CONTEXT] } break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } [BUGGY] if (ch == -1){ // EOF    break; [BUGGY] break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	497	498	1	replace	
72	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] } break; } coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } [BUGGY] [BUGGY] if (ch == -1){ // EOF    break; break; } } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	497	498	1	add	
73	[BUG] [BUGGY] } [FE] NegativeArraySizeException [CONTEXT] coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } [BUGGY] } [BUGGY] return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	500	500	1	replace	
74	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] coll.write((byte) ch); } break; // Processed single header } len *= 10; len += ch - '0'; } if (ch == -1){ // EOF break; } [BUGGY] [BUGGY] } return headers; } [CLASS] TarArchiveInputStream [METHOD] parsePaxHeaders [RETURN_TYPE] Map  InputStream i [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding keyword value ByteArrayOutputStream coll Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.35355339059327373	500	500	1	add	
75	[BUG] [BUGGY] return currEntry != null && currEntry.isDirectory(); [FE] NegativeArraySizeException [CONTEXT] private boolean isDirectory() { [BUGGY] return currEntry != null && currEntry.isDirectory(); [BUGGY] } [CLASS] TarArchiveInputStream [METHOD] isDirectory [RETURN_TYPE] boolean  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.31622776601683794	586	586	1	replace	
76	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] private boolean isDirectory() { [BUGGY] [BUGGY] return currEntry != null && currEntry.isDirectory(); } [CLASS] TarArchiveInputStream [METHOD] isDirectory [RETURN_TYPE] boolean  [VARIABLES] byte[] SMALL_BUF headerBuf l longLinkData longNameData record rest boolean hasHitEOF ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit read readNow recordSize restLen long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.31622776601683794	586	586	1	add	
77	[BUG] [BUGGY] int totalRead = 0; [FE] NegativeArraySizeException [CONTEXT] public int read(final byte[] buf, final int offset, int numToRead) throws IOException { [BUGGY] int totalRead = 0; [BUGGY]  if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.31622776601683794	642	642	1	replace	
78	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] public int read(final byte[] buf, final int offset, int numToRead) throws IOException { [BUGGY] [BUGGY] int totalRead = 0; if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.31622776601683794	642	642	1	add	
79	[BUG] [BUGGY] if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { [FE] NegativeArraySizeException [CONTEXT] public int read(final byte[] buf, final int offset, int numToRead) throws IOException { int totalRead = 0; [BUGGY] if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { [BUGGY] return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.31622776601683794	644	644	1	replace	
80	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] public int read(final byte[] buf, final int offset, int numToRead) throws IOException { int totalRead = 0; [BUGGY] [BUGGY] if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException("No current tar entry"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); [CLASS] TarArchiveInputStream [METHOD] read [RETURN_TYPE] int  final byte[] buf final int offset int numToRead [VARIABLES] byte[] SMALL_BUF buf headerBuf l longLinkData longNameData record rest boolean hasHitEOF marked shouldReset ZipEncoding zipEncoding InputStream i is String encoding key keyword val value Map globalPaxHeaders headers int SMALL_BUFFER_SIZE blockSize ch got len length markLimit numToRead offset read readNow recordSize restLen totalRead long available entryOffset entrySize n numRecords padding skipped TarArchiveEntry currEntry  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.31622776601683794	644	644	1	add	
81	[BUG] [BUGGY] if (hasHitEOF) { [FE] NegativeArraySizeException [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { [BUGGY] if (hasHitEOF) { [BUGGY] return null; } if (currEntry != null) {  IOUtils.skip(this, Long.MAX_VALUE);  skipRecordPadding(); } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	263	263	1	replace	
82	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { [BUGGY] [BUGGY] if (hasHitEOF) { return null; } if (currEntry != null) {  IOUtils.skip(this, Long.MAX_VALUE);  skipRecordPadding(); } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	263	263	1	add	
83	[BUG] [BUGGY] if (currEntry != null) { [FE] NegativeArraySizeException [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } [BUGGY] if (currEntry != null) { [BUGGY]  IOUtils.skip(this, Long.MAX_VALUE);  skipRecordPadding(); } final byte[] headerBuf = getRecord(); if (headerBuf == null) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	267	267	1	replace	
84	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } [BUGGY] [BUGGY] if (currEntry != null) {  IOUtils.skip(this, Long.MAX_VALUE);  skipRecordPadding(); } final byte[] headerBuf = getRecord(); if (headerBuf == null) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	267	267	1	add	
85	[BUG] [BUGGY] final byte[] headerBuf = getRecord(); [FE] NegativeArraySizeException [CONTEXT] } if (currEntry != null) {  IOUtils.skip(this, Long.MAX_VALUE);  skipRecordPadding(); } [BUGGY] final byte[] headerBuf = getRecord(); [BUGGY]  if (headerBuf == null) {  currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	275	275	1	replace	
86	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] } if (currEntry != null) {  IOUtils.skip(this, Long.MAX_VALUE);  skipRecordPadding(); } [BUGGY] [BUGGY] final byte[] headerBuf = getRecord(); if (headerBuf == null) {  currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	275	275	1	add	
87	[BUG] [BUGGY] if (headerBuf == null) { [FE] NegativeArraySizeException [CONTEXT] if (currEntry != null) {  IOUtils.skip(this, Long.MAX_VALUE);  skipRecordPadding(); } final byte[] headerBuf = getRecord(); [BUGGY] if (headerBuf == null) { [BUGGY]  currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	277	277	1	replace	
88	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (currEntry != null) {  IOUtils.skip(this, Long.MAX_VALUE);  skipRecordPadding(); } final byte[] headerBuf = getRecord(); [BUGGY] [BUGGY] if (headerBuf == null) {  currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	277	277	1	add	
89	[BUG] [BUGGY] currEntry = new TarArchiveEntry(headerBuf, zipEncoding); [FE] NegativeArraySizeException [CONTEXT] final byte[] headerBuf = getRecord(); if (headerBuf == null) {  currEntry = null; return null; } try { [BUGGY] currEntry = new TarArchiveEntry(headerBuf, zipEncoding); [BUGGY] } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { final byte[] longLinkData = getLongNameData(); if (longLinkData == null) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	284	284	1	replace	
90	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] final byte[] headerBuf = getRecord(); if (headerBuf == null) {  currEntry = null; return null; } try { [BUGGY] [BUGGY] currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { final byte[] longLinkData = getLongNameData(); if (longLinkData == null) { [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	284	284	1	add	
91	[BUG] [BUGGY] } [FE] NegativeArraySizeException [CONTEXT] if (headerBuf == null) {  currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); [BUGGY] } [BUGGY]  entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { final byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	287	287	1	replace	
92	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] if (headerBuf == null) {  currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); [BUGGY] [BUGGY] } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { final byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	287	287	1	add	
93	[BUG] [BUGGY] entryOffset = 0; [FE] NegativeArraySizeException [CONTEXT] currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); } [BUGGY] entryOffset = 0; [BUGGY] entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { final byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	289	289	1	replace	
94	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] currEntry = null; return null; } try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); } [BUGGY] [BUGGY] entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { final byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	289	289	1	add	
95	[BUG] [BUGGY] entrySize = currEntry.getSize(); [FE] NegativeArraySizeException [CONTEXT] return null; } try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); } entryOffset = 0; [BUGGY] entrySize = currEntry.getSize(); [BUGGY]  if (currEntry.isGNULongLinkEntry()) { final byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(zipEncoding.decode(longLinkData)); [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	290	290	1	replace	
96	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] return null; } try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); } entryOffset = 0; [BUGGY] [BUGGY] entrySize = currEntry.getSize(); if (currEntry.isGNULongLinkEntry()) { final byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(zipEncoding.decode(longLinkData)); [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	290	290	1	add	
97	[BUG] [BUGGY] if (currEntry.isGNULongLinkEntry()) { [FE] NegativeArraySizeException [CONTEXT] try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); } entryOffset = 0; entrySize = currEntry.getSize(); [BUGGY] if (currEntry.isGNULongLinkEntry()) { [BUGGY] final byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(zipEncoding.decode(longLinkData)); }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	292	292	1	replace	
98	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] try { currEntry = new TarArchiveEntry(headerBuf, zipEncoding); } catch (final IllegalArgumentException e) { throw new IOException("Error detected parsing the header", e); } entryOffset = 0; entrySize = currEntry.getSize(); [BUGGY] [BUGGY] if (currEntry.isGNULongLinkEntry()) { final byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(zipEncoding.decode(longLinkData)); }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	292	292	1	add	
99	[BUG] [BUGGY] if (currEntry.isGNULongNameEntry()) { [FE] NegativeArraySizeException [CONTEXT] final byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(zipEncoding.decode(longLinkData)); } [BUGGY] if (currEntry.isGNULongNameEntry()) { [BUGGY] final byte[] longNameData = getLongNameData(); if (longNameData == null) {    return null; } currEntry.setName(zipEncoding.decode(longNameData)); }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	303	303	1	replace	
100	[BUG] [BUGGY] [FE] NegativeArraySizeException [CONTEXT] final byte[] longLinkData = getLongNameData(); if (longLinkData == null) {    return null; } currEntry.setLinkName(zipEncoding.decode(longLinkData)); } [BUGGY] [BUGGY] if (currEntry.isGNULongNameEntry()) { final byte[] longNameData = getLongNameData(); if (longNameData == null) {    return null; } currEntry.setName(zipEncoding.decode(longNameData)); }  [CLASS] TarArchiveInputStream [METHOD] getNextTarEntry [RETURN_TYPE] TarArchiveEntry  [VARIABLES] byte[] SMALL_BUF headerBuf longLinkData longNameData boolean hasHitEOF ZipEncoding zipEncoding InputStream is String encoding Map globalPaxHeaders int SMALL_BUFFER_SIZE blockSize markLimit recordSize long available entryOffset entrySize n skipped TarArchiveEntry currEntry IllegalArgumentException e  	projects/Compress37/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java	0.30151134457776363	303	303	1	add	
