bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  4]);  [CE]  no  suitable  method  found  for  max(double)  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  4]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  4]);	      sigmaLow    =    Math.max(work[i    +    2]);    	non-compiled	[CE]  no  suitable  method  found  for  max(double)	20	None	replace
2	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  2],  work[i  +  4]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	sigmaLow  =  Math.max(work[i  +  2],  work[i  +  4]);	      sigmaLow    =    Math.max(work[i    +    2]);    	compilable	  [FE]  AssertionFailedError  	20	1	replace
3	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  2],  work[i  +  4]);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  2],  work[i  +  4]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  2],  work[i  +  4]);	      sigmaLow    =    Math.max(work[i    +    2]);    	compilable	  [FE]  AssertionFailedError  	20	1	replace
4	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  2],  work[i  +  3]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	sigmaLow  =  Math.max(work[i  +  2],  work[i  +  3]);	      sigmaLow    =    Math.max(work[i    +    2]);    	compilable	  [FE]  AssertionFailedError  	20	1	replace
5	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  2],  work[i  +  3]);  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  2],  work[i  +  3]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  2],  work[i  +  3]);	      sigmaLow    =    Math.max(work[i    +    2]);    	compilable	  [FE]  AssertionFailedError  	20	1	replace
6	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  3]);  [CE]  no  suitable  method  found  for  max(double)  [FE]                AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  3]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  3]);	      sigmaLow    =    Math.max(work[i    +    2]);    	non-compiled	[CE]  no  suitable  method  found  for  max(double)	20	None	replace
7	[BUG]  [BUGGY]  i0  =  1  +  work[i  *  4];  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  *  4];  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  *  4];	  i0    =    1    +    work[i    /    4];    	non-compiled	[CE]  possible  loss  of  precision	18	None	replace
8	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        work[i    +    2]    =    work[i    +    2];    work[i  +  2]  =  work[i  +  2];	  	compilable	  [FE]  AssertionFailedError  	5	1	add
9	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    2];    work[i  +  2]  =  work[i  +  2];	  	compilable	  [FE]  AssertionFailedError  	5	1	add
10	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        work[i    +    2]    =    work[i    +    2];    work[i  +  2]  =  work[i  +  2];  i0  =  1  +  i  /  4;	  	compilable	  [FE]  AssertionFailedError  	5	1	add
11	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  i0  =  1  +  i  /  4;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    2];    work[i  +  2]  =  work[i  +  2];  i0  =  1  +  i  /  4;	  	compilable	  [FE]  AssertionFailedError  	5	1	add
12	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  i0  =  1  +  i  /  4;  break;  [CE]  unreachable  statement  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  i0  =  1  +  i  /  4;  break;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    2];    work[i  +  2]  =  work[i  +  2];  i0  =  1  +  i  /  4;  break;	  	non-compiled	[CE]  unreachable  statement	5	None	add
13	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  }  i0  =  1  +  i  /  4;  break;  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  }  i0  =  1  +  i  /  4;  break;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    2];    work[i  +  2]  =  work[i  +  2];  }  i0  =  1  +  i  /  4;  break;	  	non-compiled	[CE]  class,  interface,  or  enum  expected	5	None	add
14	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  }  i0  =  1  +  i  /  4;  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  2]  =  work[i  +  2];  }  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    2];    work[i  +  2]  =  work[i  +  2];  }  i0  =  1  +  i  /  4;	  	non-compiled	[CE]  class,  interface,  or  enum  expected	5	None	add
15	[BUG]  [BUGGY]  timeout  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  *  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0  =  1  +  i  *  2;	  i0    =    1    +    i    /    2;    timeout    	compilable	timeout	10	1	replace
16	[BUG]  [BUGGY]  i0  =  1  +  i  *  2;  timeout  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  *  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  i  *  2;	  i0    =    1    +    i    /    2;    timeout    	compilable	timeout	10	1	replace
17	[BUG]  [BUGGY]  sigmaLow  =  Math.max(sigmaMin,  work[i  +  3]);  [CE]  cannot  find  symbol  sigmaMin  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(sigmaMin,  work[i  +  3]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(sigmaMin,  work[i  +  3]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    3]);    	non-compiled	[CE]  cannot  find  symbol  sigmaMin	15	None	replace
18	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  offDiagMin);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  offDiagMin);	      sigmaLow    =    Math.max(work[i    +    1]    +    work[i    +    2]);    	compilable	  [FE]  AssertionFailedError  	19	1	replace
19	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  offDiagMin);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  offDiagMin);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  offDiagMin);	      sigmaLow    =    Math.max(work[i    +    1]    +    work[i    +    2]);    	compilable	  [FE]  AssertionFailedError  	19	1	replace
20	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  offDiagMax);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  offDiagMax);	      sigmaLow    =    Math.max(work[i    +    1]    +    work[i    +    2]);    	compilable	  [FE]  AssertionFailedError  	19	1	replace
21	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  offDiagMax);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  offDiagMax);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  offDiagMax);	      sigmaLow    =    Math.max(work[i    +    1]    +    work[i    +    2]);    	compilable	  [FE]  AssertionFailedError  	19	1	replace
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1  +  i  /  3;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0    =    1    +    i    /    3;    i0  =  1  +  i  /  3;	  timeout    	compilable	  [FE]  AssertionFailedError  	11	1	add
23	[BUG]  [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1  +  i  /  3;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1  +  i  /  3;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    3;    i0  =  1  +  i  /  3;	  timeout    	compilable	  [FE]  AssertionFailedError  	11	1	add
24	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  i0  =  2  +  i  /  3;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0    =    1    +    i    /    3;    i0  =  2  +  i  /  3;	  timeout    	compilable	  [FE]  AssertionFailedError  	11	1	add
25	[BUG]  [BUGGY]  i0  =  1  +  i  /  3;  i0  =  2  +  i  /  3;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  i0  =  2  +  i  /  3;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    3;    i0  =  2  +  i  /  3;	  timeout    	compilable	  [FE]  AssertionFailedError  	11	1	add
26	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1  +  i  /  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0    =    1    +    i    /    3;    i0  =  1  +  i  /  2;	  timeout    	compilable	  [FE]  AssertionFailedError  	11	1	add
27	[BUG]  [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1  +  i  /  2;  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1  +  i  /  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    3;    i0  =  1  +  i  /  2;	  timeout    	compilable	  [FE]  AssertionFailedError  	11	1	add
28	[BUG]  [BUGGY]  i0  =  1  +  i  /  3;  i0  =  (1  +  i  /  3;  [CE]  ')'  expected  [FE]                AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  i0  =  (1  +  i  /  3;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    3;    i0  =  (1  +  i  /  3;	  timeout    	non-compiled	[CE]  ')'  expected	11	None	add
29	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  3]  =  work[i  +  3];  work[i  +  3]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        work[i    +    3]    =    work[i    +    3];    work[i  +  3]  =  work[i  +  3];	  	compilable	  [FE]  AssertionFailedError  	21	1	add
30	[BUG]  [BUGGY]      work[i  +  3]  =  work[i  +  3];  work[i  +  3]  =  work[i  +  3];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  3]  =  work[i  +  3];  work[i  +  3]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    3]    =    work[i    +    3];    work[i  +  3]  =  work[i  +  3];	  	compilable	  [FE]  AssertionFailedError  	21	1	add
31	[BUG]  [BUGGY]      work[i  +  3]  =  work[i  +  3];  Work[i  +  3]  =  work[i  +  3];  [CE]  cannot  find  symbol  Work  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  3]  =  work[i  +  3];  Work[i  +  3]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    3]    =    work[i    +    3];    Work[i  +  3]  =  work[i  +  3];	  	non-compiled	[CE]  cannot  find  symbol  Work	21	None	add
32	[BUG]  [BUGGY]      work[i  +  3]  =  work[i  +  3];  job[i  +  3]  =  work[i  +  3];  [CE]  cannot  find  symbol  job  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  3]  =  work[i  +  3];  job[i  +  3]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    3]    =    work[i    +    3];    job[i  +  3]  =  work[i  +  3];	  	non-compiled	[CE]  cannot  find  symbol  job	21	None	add
33	[BUG]  [BUGGY]      work[i  +  3]  =  work[i  +  3];  works[i  +  3]  =  work[i  +  3];  [CE]  cannot  find  symbol  works  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  3]  =  work[i  +  3];  works[i  +  3]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    3]    =    work[i    +    3];    works[i  +  3]  =  work[i  +  3];	  	non-compiled	[CE]  cannot  find  symbol  works	21	None	add
34	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  3];  work[i  +  2]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        work[i    +    2]    =    work[i    +    3];    work[i  +  2]  =  work[i  +  3];	  	compilable	  [FE]  AssertionFailedError  	2	1	add
35	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  3];  work[i  +  2]  =  work[i  +  3];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  3];  work[i  +  2]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    3];    work[i  +  2]  =  work[i  +  3];	  	compilable	  [FE]  AssertionFailedError  	2	1	add
36	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  3];  work[i  +  2]  =  work[i  +  3];  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        work[i    +    2]    =    work[i    +    3];    work[i  +  2]  =  work[i  +  3];  i0  =  1  +  i  /  4;	  	compilable	  [FE]  AssertionFailedError  	2	1	add
37	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  3];  work[i  +  2]  =  work[i  +  3];  i0  =  1  +  i  /  4;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  3];  work[i  +  2]  =  work[i  +  3];  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    3];    work[i  +  2]  =  work[i  +  3];  i0  =  1  +  i  /  4;	  	compilable	  [FE]  AssertionFailedError  	2	1	add
38	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  3];  work[i  +  2]  =  work[i  +  3];  i0  =  1  +  i  /  4;  break;  [CE]  unreachable  statement  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  3];  work[i  +  2]  =  work[i  +  3];  i0  =  1  +  i  /  4;  break;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    3];    work[i  +  2]  =  work[i  +  3];  i0  =  1  +  i  /  4;  break;	  	non-compiled	[CE]  unreachable  statement	2	None	add
39	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  3];  work[i  +  2]  =  work[i  +  3];  }  i0  =  1  +  i  /  4;  break;  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  3];  work[i  +  2]  =  work[i  +  3];  }  i0  =  1  +  i  /  4;  break;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    3];    work[i  +  2]  =  work[i  +  3];  }  i0  =  1  +  i  /  4;  break;	  	non-compiled	[CE]  class,  interface,  or  enum  expected	2	None	add
40	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  3];  Work[i  +  2]  =  work[i  +  3];  [CE]  cannot  find  symbol  Work  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  3];  Work[i  +  2]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    3];    Work[i  +  2]  =  work[i  +  3];	  	non-compiled	[CE]  cannot  find  symbol  Work	2	None	add
41	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  3]  =  work[i  +  4];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	work[i  +  3]  =  work[i  +  4];	      work[i    +    3]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	22	1	replace
42	[BUG]  [BUGGY]  work[i  +  3]  =  work[i  +  4];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  3]  =  work[i  +  4];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	work[i  +  3]  =  work[i  +  4];	      work[i    +    3]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	22	1	replace
43	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  3]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	work[i  +  3]  =  work[i  +  2];	      work[i    +    3]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	22	1	replace
44	[BUG]  [BUGGY]  work[i  +  3]  =  work[i  +  2];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  3]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	work[i  +  3]  =  work[i  +  2];	      work[i    +    3]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	22	1	replace
45	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  1]  =  work[i  +  1];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	work[i  +  1]  =  work[i  +  1];	      work[i    +    3]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	22	1	replace
46	[BUG]  [BUGGY]  work[i  +  1]  =  work[i  +  1];  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  1]  =  work[i  +  1];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	work[i  +  1]  =  work[i  +  1];	      work[i    +    3]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	22	1	replace
47	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  2]  =  work[i  +  4];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	work[i  +  2]  =  work[i  +  4];	      work[i    +    2]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	3	1	replace
48	[BUG]  [BUGGY]  work[i  +  2]  =  work[i  +  4];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  2]  =  work[i  +  4];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	work[i  +  2]  =  work[i  +  4];	      work[i    +    2]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	3	1	replace
49	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  2]  =  work[i  +  6];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	work[i  +  2]  =  work[i  +  6];	      work[i    +    2]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	3	1	replace
50	[BUG]  [BUGGY]  work[i  +  2]  =  work[i  +  6];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  2]  =  work[i  +  6];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	work[i  +  2]  =  work[i  +  6];	      work[i    +    2]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	3	1	replace
51	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  2]  =  work[4];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	work[i  +  2]  =  work[4];	      work[i    +    2]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	3	1	replace
52	[BUG]  [BUGGY]  work[i  +  2]  =  work[4];  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  2]  =  work[4];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	work[i  +  2]  =  work[4];	      work[i    +    2]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	3	1	replace
53	[BUG]  [BUGGY]  i0  =  1  +  work[i  +  2]  /  4;  [CE]  possible  loss  of  precision  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  +  2]  /  4;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  +  2]  /  4;	  i0    =    1    +    work[i    -    2]    /    4;    	non-compiled	[CE]  possible  loss  of  precision	16	None	replace
54	[BUG]  [BUGGY]  i0  =  1  +  work[i  -  2]  /  3;  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  -  2]  /  3;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  -  2]  /  3;	  i0    =    1    +    work[i    -    2]    /    4;    	non-compiled	[CE]  possible  loss  of  precision	16	None	replace
55	[BUG]  [BUGGY]  i0  =  1  +  work[i  -  2]  *  4;  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  -  2]  *  4;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  -  2]  *  4;	  i0    =    1    +    work[i    -    2]    /    4;    	non-compiled	[CE]  possible  loss  of  precision	16	None	replace
56	[BUG]  [BUGGY]  i0  =  1  +  work[i  *  2];  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  *  2];  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  *  2];	  i0    =    1    +    work[i    /    2];    	non-compiled	[CE]  possible  loss  of  precision	17	None	replace
57	[BUG]  [BUGGY]  i0  =  1  +  work[i  +  2];  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  +  2];  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  +  2];	  i0    =    1    +    work[i    /    2];    	non-compiled	[CE]  possible  loss  of  precision	17	None	replace
58	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      i0  =  1  +  i  /  4;  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        i0    =    1    +    i    /    4;    i0  =  1  +  i  /  4;	  	compilable	  [FE]  AssertionFailedError  	7	1	add
59	[BUG]  [BUGGY]      i0  =  1  +  i  /  4;  i0  =  1  +  i  /  4;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      i0  =  1  +  i  /  4;  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        i0    =    1    +    i    /    4;    i0  =  1  +  i  /  4;	  	compilable	  [FE]  AssertionFailedError  	7	1	add
60	[BUG]  [BUGGY]      i0  =  1  +  i  /  4;  int  i0  =  1  +  i  /  4;  [CE]  variable  i0  is  already  defined  in  method  processGeneralBlock(int)  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      i0  =  1  +  i  /  4;  int  i0  =  1  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        i0    =    1    +    i    /    4;    int  i0  =  1  +  i  /  4;	  	non-compiled	[CE]  variable  i0  is  already  defined  in  method  processGeneralBlock(int)	7	None	add
61	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      i0  =  1  +  i  /  4;  i0  =  2  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        i0    =    1    +    i    /    4;    i0  =  2  +  i  /  4;	  	compilable	  [FE]  AssertionFailedError  	7	1	add
62	[BUG]  [BUGGY]      i0  =  1  +  i  /  4;  i0  =  2  +  i  /  4;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      i0  =  1  +  i  /  4;  i0  =  2  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        i0    =    1    +    i    /    4;    i0  =  2  +  i  /  4;	  	compilable	  [FE]  AssertionFailedError  	7	1	add
63	[BUG]  [BUGGY]      i0  =  1  +  i  /  4;  i0  =  1)  +  i  /  4;  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      i0  =  1  +  i  /  4;  i0  =  1)  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        i0    =    1    +    i    /    4;    i0  =  1)  +  i  /  4;	  	non-compiled	[CE]  ';'  expected	7	None	add
64	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  4]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	work[i  +  4]  =  work[i  +  2];	      work[i    +    2]    =    work[i    +    2];    	compilable	  [FE]  AssertionFailedError  	6	1	replace
65	[BUG]  [BUGGY]  work[i  +  4]  =  work[i  +  2];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  4]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	work[i  +  4]  =  work[i  +  2];	      work[i    +    2]    =    work[i    +    2];    	compilable	  [FE]  AssertionFailedError  	6	1	replace
66	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]);  [CE]  no  suitable  method  found  for  max(double)  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  1]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    1]);    	non-compiled	[CE]  no  suitable  method  found  for  max(double)	14	None	replace
67	[BUG]  [BUGGY]  sigmaLow  =  Math.max(sigmaMin,  work[i  +  1]);  [CE]  cannot  find  symbol  sigmaMin  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(sigmaMin,  work[i  +  1]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(sigmaMin,  work[i  +  1]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    1]);    	non-compiled	[CE]  cannot  find  symbol  sigmaMin	14	None	replace
68	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  2;  i0  =  1  +  i  /  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0    =    1    +    i    /    2;    i0  =  1  +  i  /  2;	  timeout    	compilable	  [FE]  AssertionFailedError  	9	1	add
69	[BUG]  [BUGGY]  i0  =  1  +  i  /  2;  i0  =  1  +  i  /  2;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  2;  i0  =  1  +  i  /  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    2;    i0  =  1  +  i  /  2;	  timeout    	compilable	  [FE]  AssertionFailedError  	9	1	add
70	[BUG]  [BUGGY]  i0  =  1  +  i  /  2;  int  i0  =  1  +  i  /  2;  [CE]  variable  i0  is  already  defined  in  method  processGeneralBlock(int)  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  2;  int  i0  =  1  +  i  /  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    2;    int  i0  =  1  +  i  /  2;	  timeout    	non-compiled	[CE]  variable  i0  is  already  defined  in  method  processGeneralBlock(int)	9	None	add
71	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  2;  i0  =  1  +  i  /  3;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0    =    1    +    i    /    2;    i0  =  1  +  i  /  3;	  timeout    	compilable	  [FE]  AssertionFailedError  	9	1	add
72	[BUG]  [BUGGY]  i0  =  1  +  i  /  2;  i0  =  1  +  i  /  3;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  2;  i0  =  1  +  i  /  3;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    2;    i0  =  1  +  i  /  3;	  timeout    	compilable	  [FE]  AssertionFailedError  	9	1	add
73	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  2;  i0  =  2  +  i  /  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0    =    1    +    i    /    2;    i0  =  2  +  i  /  2;	  timeout    	compilable	  [FE]  AssertionFailedError  	9	1	add
74	[BUG]  [BUGGY]  i0  =  1  +  i  /  2;  i0  =  2  +  i  /  2;  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  2;  i0  =  2  +  i  /  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    2;    i0  =  2  +  i  /  2;	  timeout    	compilable	  [FE]  AssertionFailedError  	9	1	add
75	[BUG]  [BUGGY]  sigmaLow  =  Math.max(sigmaMin,  work[i  +  2]);  [CE]  cannot  find  symbol  sigmaMin  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(sigmaMin,  work[i  +  2]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(sigmaMin,  work[i  +  2]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    2]);    	non-compiled	[CE]  cannot  find  symbol  sigmaMin	13	None	replace
76	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i,  work[i  +  1]);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i,  work[i  +  1]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i,  work[i  +  1]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    1]);    	non-compiled	[CE]  ']'  expected	14	None	replace
77	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i0,  work[i  +  1]);  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i0,  work[i  +  1]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i0,  work[i  +  1]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    1]);    	non-compiled	[CE]  ']'  expected	14	None	replace
78	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work,  work[i  +  1]);  [CE]  no  suitable  method  found  for  max(double[],double)  [FE]              AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work,  work[i  +  1]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work,  work[i  +  1]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    1]);    	non-compiled	[CE]  no  suitable  method  found  for  max(double[],double)	14	None	replace
79	[BUG]  [BUGGY]  i0  =  1  +  work[i  -  2];  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  -  2];  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  -  2];	  i0    =    1    +    work[i    /    2];    	non-compiled	[CE]  possible  loss  of  precision	17	None	replace
80	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  3];  works[i  +  2]  =  work[i  +  3];  [CE]  cannot  find  symbol  works  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  3];  works[i  +  2]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    3];    works[i  +  2]  =  work[i  +  3];	  	non-compiled	[CE]  cannot  find  symbol  works	2	None	add
81	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  3];  Arbeit[i  +  2]  =  work[i  +  3];  [CE]  cannot  find  symbol  Arbeit  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  3];  Arbeit[i  +  2]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    3];    Arbeit[i  +  2]  =  work[i  +  3];	  	non-compiled	[CE]  cannot  find  symbol  Arbeit	2	None	add
82	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  i0);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  i0);	      sigmaLow    =    Math.max(work[i    +    1]    +    work[i    +    2]);    	compilable	  [FE]  AssertionFailedError  	19	1	replace
83	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  i0);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  i0);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2],  i0);	      sigmaLow    =    Math.max(work[i    +    1]    +    work[i    +    2]);    	compilable	  [FE]  AssertionFailedError  	19	1	replace
84	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  2];  Work[i  +  2]  =  work[i  +  2];  [CE]  cannot  find  symbol  Work  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  Work[i  +  2]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    2];    Work[i  +  2]  =  work[i  +  2];	  	non-compiled	[CE]  cannot  find  symbol  Work	5	None	add
85	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  3]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        work[i    +    2]    =    work[i    +    2];    work[i  +  3]  =  work[i  +  2];	  	compilable	  [FE]  AssertionFailedError  	5	1	add
86	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  3]  =  work[i  +  2];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  3]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    2];    work[i  +  3]  =  work[i  +  2];	  	compilable	  [FE]  AssertionFailedError  	5	1	add
87	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  2];  works[i  +  2]  =  work[i  +  2];  [CE]  cannot  find  symbol  works  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  works[i  +  2]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    2];    works[i  +  2]  =  work[i  +  2];	  	non-compiled	[CE]  cannot  find  symbol  works	5	None	add
88	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i,  work[i  +  3]);  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i,  work[i  +  3]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i,  work[i  +  3]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    3]);    	non-compiled	[CE]  ']'  expected	15	None	replace
89	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  2]  +  work[i  +  3]);  [CE]  no  suitable  method  found  for  max(double)  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  2]  +  work[i  +  3]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  2]  +  work[i  +  3]);	      sigmaLow    =    Math.max(work[i    +    2]);    	non-compiled	[CE]  no  suitable  method  found  for  max(double)	20	None	replace
90	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  2]  +  work[i  +  4]);  [CE]  no  suitable  method  found  for  max(double)  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  2]  +  work[i  +  4]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  2]  +  work[i  +  4]);	      sigmaLow    =    Math.max(work[i    +    2]);    	non-compiled	[CE]  no  suitable  method  found  for  max(double)	20	None	replace
91	[BUG]  [BUGGY]      i0  =  1  +  i  /  4;  I0  =  1  +  i  /  4;  [CE]  cannot  find  symbol  I0  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      i0  =  1  +  i  /  4;  I0  =  1  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        i0    =    1    +    i    /    4;    I0  =  1  +  i  /  4;	  	non-compiled	[CE]  cannot  find  symbol  I0	7	None	add
92	[BUG]  [BUGGY]  i0  =  1  +  work[i  -  4];  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  -  4];  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  -  4];	  i0    =    1    +    work[i    /    4];    	non-compiled	[CE]  possible  loss  of  precision	18	None	replace
93	[BUG]  [BUGGY]  i0  =  1  +  i  /  2;  i0  =  1)  +  i  /  2;  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  2;  i0  =  1)  +  i  /  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    2;    i0  =  1)  +  i  /  2;	  timeout    	non-compiled	[CE]  ';'  expected	9	None	add
94	[BUG]  [BUGGY]  i0  =  1  +  work[i  /  3];  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  /  3];  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  /  3];	  i0    =    1    +    i    /    3;    timeout    	non-compiled	[CE]  possible  loss  of  precision	12	None	replace
95	[BUG]  [BUGGY]  i0  =  1  +  i  /  3;  break;  [CE]  unreachable  statement  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  break;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  i  /  3;  break;	      i0    =    1    +    i    /    4;    break;    	non-compiled	[CE]  unreachable  statement	1	None	replace
96	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i,  work[i  +  2]);  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i,  work[i  +  2]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i,  work[i  +  2]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    2]);    	non-compiled	[CE]  ']'  expected	13	None	replace
97	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work,  work[i  +  2]);  [CE]  no  suitable  method  found  for  max(double[],double)  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work,  work[i  +  2]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work,  work[i  +  2]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    2]);    	non-compiled	[CE]  no  suitable  method  found  for  max(double[],double)	13	None	replace
98	[BUG]  [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1)  +  i  /  3;  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1)  +  i  /  3;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    3;    i0  =  1)  +  i  /  3;	  timeout    	non-compiled	[CE]  ';'  expected	11	None	add
99	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1  +  i  /  4;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0    =    1    +    i    /    3;    i0  =  1  +  i  /  4;	  timeout    	compilable	  [FE]  AssertionFailedError  	11	1	add
100	[BUG]  [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1  +  i  /  4;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  3;  i0  =  1  +  i  /  4;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    3;    i0  =  1  +  i  /  4;	  timeout    	compilable	  [FE]  AssertionFailedError  	11	1	add
101	[BUG]  [BUGGY]  i0  =  1  +  work[i  -  2]  /  2;  [CE]  possible  loss  of  precision  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  -  2]  /  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  -  2]  /  2;	  i0    =    1    +    i    /    2;    timeout    	non-compiled	[CE]  possible  loss  of  precision	10	None	replace
102	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  2]  =  work[i  /  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	work[i  +  2]  =  work[i  /  3];	      work[i    +    2]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	3	1	replace
103	[BUG]  [BUGGY]  work[i  +  2]  =  work[i  /  3];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  2]  =  work[i  /  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	work[i  +  2]  =  work[i  /  3];	      work[i    +    2]    =    work[i    +    3];    	compilable	  [FE]  AssertionFailedError  	3	1	replace
104	[BUG]  [BUGGY]  i0  =  1  +  i  /  2;  i0  =  (1  +  i  /  2;  [CE]  ')'  expected  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  /  2;  i0  =  (1  +  i  /  2;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0    =    1    +    i    /    2;    i0  =  (1  +  i  /  2;	  timeout    	non-compiled	[CE]  ')'  expected	9	None	add
105	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  1]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        work[i    +    2]    =    work[i    +    2];    work[i  +  1]  =  work[i  +  2];	  	compilable	  [FE]  AssertionFailedError  	5	1	add
106	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  1]  =  work[i  +  2];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  2];  work[i  +  1]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    2];    work[i  +  1]  =  work[i  +  2];	  	compilable	  [FE]  AssertionFailedError  	5	1	add
107	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      i0  =  1  +  i  /  4;  i0  =  3  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        i0    =    1    +    i    /    4;    i0  =  3  +  i  /  4;	  	compilable	  [FE]  AssertionFailedError  	7	1	add
108	[BUG]  [BUGGY]      i0  =  1  +  i  /  4;  i0  =  3  +  i  /  4;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      i0  =  1  +  i  /  4;  i0  =  3  +  i  /  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        i0    =    1    +    i    /    4;    i0  =  3  +  i  /  4;	  	compilable	  [FE]  AssertionFailedError  	7	1	add
109	[BUG]  [BUGGY]  i0  =  1  +  work[i  -  3];  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  work[i  -  3];  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  work[i  -  3];	  i0    =    1    +    i    /    3;    timeout    	non-compiled	[CE]  possible  loss  of  precision	12	None	replace
110	[BUG]  [BUGGY]  i0  =  work[i  +  1];  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  work[i  +  1];  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  work[i  +  1];	  i0    =    1    +    work[i    /    4];    	non-compiled	[CE]  possible  loss  of  precision	18	None	replace
111	[BUG]  [BUGGY]  i0  =  work[i  +  2];  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  work[i  +  2];  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  work[i  +  2];	  i0    =    1    +    work[i    /    2];    	non-compiled	[CE]  possible  loss  of  precision	17	None	replace
112	[BUG]  [BUGGY]      work[i  +  3]  =  work[i  +  3];  work[i  +  3]  =  work[i  +  3].;  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  3]  =  work[i  +  3];  work[i  +  3]  =  work[i  +  3].;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    3]    =    work[i    +    3];    work[i  +  3]  =  work[i  +  3].;	  	non-compiled	[CE]  <identifier>  expected	21	None	add
113	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  3]  =  work[i  +  3];  work[i  +  4]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	        work[i    +    3]    =    work[i    +    3];    work[i  +  4]  =  work[i  +  3];	  	compilable	  [FE]  AssertionFailedError  	21	1	add
114	[BUG]  [BUGGY]      work[i  +  3]  =  work[i  +  3];  work[i  +  4]  =  work[i  +  3];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  3]  =  work[i  +  3];  work[i  +  4]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    3]    =    work[i    +    3];    work[i  +  4]  =  work[i  +  3];	  	compilable	  [FE]  AssertionFailedError  	21	1	add
115	[BUG]  [BUGGY]      work[i  +  2]  =  work[i  +  3];  job[i  +  2]  =  work[i  +  3];  [CE]  cannot  find  symbol  job  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]      work[i  +  2]  =  work[i  +  3];  job[i  +  2]  =  work[i  +  3];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	        work[i    +    2]    =    work[i    +    3];    job[i  +  2]  =  work[i  +  3];	  	non-compiled	[CE]  cannot  find  symbol  job	2	None	add
116	[BUG]  [BUGGY]  sigmaMax  =  Math.max(work[i,  work[i  +  1]);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaMax  =  Math.max(work[i,  work[i  +  1]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaMax  =  Math.max(work[i,  work[i  +  1]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    1]);    	non-compiled	[CE]  ']'  expected	14	None	replace
117	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work,  work[i  +  3]);  [CE]  no  suitable  method  found  for  max(double[],double)  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work,  work[i  +  3]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work,  work[i  +  3]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    3]);    	non-compiled	[CE]  no  suitable  method  found  for  max(double[],double)	15	None	replace
118	[BUG]  [BUGGY]  sigmaLow  =  Math.max(workMin,  work[i  +  3]);  [CE]  cannot  find  symbol  workMin  [FE]              AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(workMin,  work[i  +  3]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(workMin,  work[i  +  3]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    3]);    	non-compiled	[CE]  cannot  find  symbol  workMin	15	None	replace
119	[BUG]  [BUGGY]  timeout  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  -  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	i0  =  1  +  i  -  4;	      i0    =    1    +    i    /    4;    	compilable	timeout	8	1	replace
120	[BUG]  [BUGGY]  i0  =  1  +  i  -  4;  timeout  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  1  +  i  -  4;  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  1  +  i  -  4;	      i0    =    1    +    i    /    4;    	compilable	timeout	8	1	replace
121	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  3]);  [CE]  no  suitable  method  found  for  max(double)  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  3]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  3]);	      sigmaLow    =    Math.max(work[i    +    1]    +    work[i    +    2]);    	non-compiled	[CE]  no  suitable  method  found  for  max(double)	19	None	replace
122	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  1,  work[i  +  2]);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  1,  work[i  +  2]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  1,  work[i  +  2]);	      sigmaLow    =    Math.max(work[i    +    1]    +    work[i    +    2]);    	non-compiled	[CE]  ']'  expected	19	None	replace
123	[BUG]  [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2]  *  n0);  [CE]  no  suitable  method  found  for  max(double)  [FE]            AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2]  *  n0);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(work[i  +  1]  +  work[i  +  2]  *  n0);	      sigmaLow    =    Math.max(work[i    +    1]    +    work[i    +    2]);    	non-compiled	[CE]  no  suitable  method  found  for  max(double)	19	None	replace
124	[BUG]  [BUGGY]  sigmaLow  =  Math.max(workMin,  work[i  +  2]);  [CE]  cannot  find  symbol  workMin  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  sigmaLow  =  Math.max(workMin,  work[i  +  2]);  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	sigmaLow  =  Math.max(workMin,  work[i  +  2]);	      sigmaLow    =    Math.max(sigmaMax,    work[i    +    2]);    	non-compiled	[CE]  cannot  find  symbol  workMin	13	None	replace
125	[BUG]  [BUGGY]  i0  =  work[i  +  2]  /  4;  [CE]  possible  loss  of  precision  [FE]        AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  i0  =  work[i  +  2]  /  4;  [BUGGY]    break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	i0  =  work[i  +  2]  /  4;	  i0    =    1    +    work[i    -    2]    /    4;    	non-compiled	[CE]  possible  loss  of  precision	16	None	replace
126	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  1]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	work[i  +  1]  =  work[i  +  2];	      work[i    +    2]    =    work[i    +    2];    	compilable	  [FE]  AssertionFailedError  	6	1	replace
127	[BUG]  [BUGGY]  work[i  +  1]  =  work[i  +  2];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    sigmaLow  =  0;  double  offDiagMin  =  (i0  ==  n0)  ?  0  :  work[4  *  n0  -  6];  double  offDiagMax  =  0;  double  diagMax=  work[4  *  n0  -  4];  double  diagMin=  diagMax;  i0  =  0;  for  (int  i  =  4  *  (n0  -  2);  i  >=  0;  i  -=  4)  {  if  (work[i  +  2]  <=  0)  {    [BUGGY]  work[i  +  1]  =  work[i  +  2];  [BUGGY]    i0  =  1  +  i  /  4;  break;  }  if  (diagMin  >=  4  *  offDiagMax)  {  diagMin=  Math.min(diagMin,  work[i  +  4]);  offDiagMax  =  Math.max(offDiagMax,  work[i  +  2]);  }  diagMax=  Math.max(diagMax,  work[i]  +  work[i  +  2]);  offDiagMin  =  Math.min(offDiagMin,  work[i  +  2]);  }  work[4  *  n0  -  2]  =  offDiagMin;  [CLASS]  EigenDecompositionImpl  Solver  [METHOD]  processGeneralBlock  [RETURN_TYPE]  void  final  int  n  [VARIABLES]  boolean  double[]  b  bp  imagEigenvalues  invI  main  range  realEigenvalues  secondary  squaredSecondary  vData  vK  work  ArrayRealVector[]  eigenvectors  RealMatrix  b  cachedD  cachedV  cachedVt  matrix  double  TOLERANCE  TOLERANCE_2  absDCurrent  absDPrevious  alpha  b  b2  beta  c  d  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  delta  determinant  diagMax  diagMin  e12  eCurrent  eMax  eMin  ePrevious  ei  eps  g  invIJ  lambda  largestRoot  lower  lowerSpectra  max  mij  minPivot  mji  offDiagMax  offDiagMin  oneFourth  p  previousEMin  q  q0  q1  q1q2Me22  q2  qMax  r  radius  s  sigma  sigmaLow  splitTolerance  sqrtMq  sumOffDiag  t  tau  theta  threeFourth  tmp  upper  upperSpectra  z0  z1  z2  int  begin  columns  end  fourI  i  i0  index  j  k  lowerStart  m  maxIter  n  n0  nColB  oneFourthCount  pingPong  rows  split  tType  threeFourthCount  upperStart  TriDiagonalTransformer  transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	work[i  +  1]  =  work[i  +  2];	      work[i    +    2]    =    work[i    +    2];    	compilable	  [FE]  AssertionFailedError  	6	1	replace
