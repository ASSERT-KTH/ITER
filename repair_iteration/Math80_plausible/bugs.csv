bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] i0 = 1 + i / 4; [FE] AssertionFailedError [CONTEXT] sigmaLow = 0;  double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax= work[4 * n0 - 4]; double diagMin= diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { [BUGGY] i0 = 1 + i / 4; [BUGGY] break; } if (diagMin >= 4 * offDiagMax) { diagMin= Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax= Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin; [CLASS] EigenDecompositionImpl Solver [METHOD] processGeneralBlock [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	replace	
2	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] sigmaLow = 0;  double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax= work[4 * n0 - 4]; double diagMin= diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { [BUGGY] [BUGGY] i0 = 1 + i / 4; break; } if (diagMin >= 4 * offDiagMax) { diagMin= Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax= Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin; [CLASS] EigenDecompositionImpl Solver [METHOD] processGeneralBlock [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	871	871	1	add	
3	[BUG] [BUGGY] break; [FE] AssertionFailedError [CONTEXT]  double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax= work[4 * n0 - 4]; double diagMin= diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { i0 = 1 + i / 4; [BUGGY] break; [BUGGY] } if (diagMin >= 4 * offDiagMax) { diagMin= Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax= Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin;  [CLASS] EigenDecompositionImpl Solver [METHOD] processGeneralBlock [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	replace	
4	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax= work[4 * n0 - 4]; double diagMin= diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { i0 = 1 + i / 4; [BUGGY] [BUGGY] break; } if (diagMin >= 4 * offDiagMax) { diagMin= Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax= Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin;  [CLASS] EigenDecompositionImpl Solver [METHOD] processGeneralBlock [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	872	872	1	add	
5	[BUG] [BUGGY] work[i + 2] = -0.0; [FE] AssertionFailedError [CONTEXT] private void initialSplits(final int n) { pingPong = 0; for (int k = 0; k < 2; ++k) {  double d = work[4 * (n - 1) + pingPong]; for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) { if (work[i + 2] <= TOLERANCE_2 * d) { [BUGGY] work[i + 2] = -0.0; [BUGGY] d = work[i]; } else { d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	replace	
6	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private void initialSplits(final int n) { pingPong = 0; for (int k = 0; k < 2; ++k) {  double d = work[4 * (n - 1) + pingPong]; for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) { if (work[i + 2] <= TOLERANCE_2 * d) { [BUGGY] [BUGGY] work[i + 2] = -0.0; d = work[i]; } else { d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	944	944	1	add	
7	[BUG] [BUGGY] d = work[i]; [FE] AssertionFailedError [CONTEXT] private void initialSplits(final int n) { pingPong = 0; for (int k = 0; k < 2; ++k) {  double d = work[4 * (n - 1) + pingPong]; for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) { if (work[i + 2] <= TOLERANCE_2 * d) { work[i + 2] = -0.0; [BUGGY] d = work[i]; [BUGGY] } else { d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	replace	
8	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private void initialSplits(final int n) { pingPong = 0; for (int k = 0; k < 2; ++k) {  double d = work[4 * (n - 1) + pingPong]; for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) { if (work[i + 2] <= TOLERANCE_2 * d) { work[i + 2] = -0.0; [BUGGY] [BUGGY] d = work[i]; } else { d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	945	945	1	add	
9	[BUG] [BUGGY] work[i] = -0.0; [FE] AssertionFailedError [CONTEXT] d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { [BUGGY] work[i] = -0.0; [BUGGY] work[j] = d; work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	replace	
10	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] d *= work[i] / (d + work[i + 2]); } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { [BUGGY] [BUGGY] work[i] = -0.0; work[j] = d; work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	957	957	1	add	
11	[BUG] [BUGGY] work[j] = d; [FE] AssertionFailedError [CONTEXT] } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; [BUGGY] work[j] = d; [BUGGY] work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	replace	
12	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; [BUGGY] [BUGGY] work[j] = d; work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	958	958	1	add	
13	[BUG] [BUGGY] work[j + 2] = 0.0; [FE] AssertionFailedError [CONTEXT] }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; work[j] = d; [BUGGY] work[j + 2] = 0.0; [BUGGY] d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; } [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	replace	
14	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] }  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; work[j] = d; [BUGGY] [BUGGY] work[j + 2] = 0.0; d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; } [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	959	959	1	add	
15	[BUG] [BUGGY] d = work[i + 2]; [FE] AssertionFailedError [CONTEXT]  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; work[j] = d; work[j + 2] = 0.0; [BUGGY] d = work[i + 2]; [BUGGY] } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; } } [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	replace	
16	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  d = work[pingPong]; for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) { final int j = i - 2 * pingPong - 1; work[j] = d + work[i]; if (work[i] <= TOLERANCE_2 * d) { work[i] = -0.0; work[j] = d; work[j + 2] = 0.0; [BUGGY] [BUGGY] d = work[i + 2]; } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) && (MathUtils.SAFE_MIN * work[j] < work[i + 2])) { final double tmp = work[i + 2] / work[j]; work[j + 2] = work[i] * tmp; d *= tmp; } else { work[j + 2] = work[i + 2] * (work[i] / work[j]); d *= work[i + 2] / work[j]; } } [CLASS] EigenDecompositionImpl Solver [METHOD] initialSplits [RETURN_TYPE] void  final int n [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns end fourI i i0 index j k lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	960	960	1	add	
17	[BUG] [BUGGY] dMin2 = Math.min(dMin2, work[l - 1]); [FE] AssertionFailedError [CONTEXT] } } final int l = 4 * deflatedEnd + pingPong - 1;  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { [BUGGY] dMin2 = Math.min(dMin2, work[l - 1]); [BUGGY] work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } } [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	replace	
18	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } } final int l = 4 * deflatedEnd + pingPong - 1;  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { [BUGGY] [BUGGY] dMin2 = Math.min(dMin2, work[l - 1]); work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } } [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1055	1055	1	add	
19	[BUG] [BUGGY] work[l - 1] =  Math.min(work[l - 1],    Math.min(work[3 + pingPong], work[7 + pingPong])); [FE] AssertionFailedError [CONTEXT] } } final int l = 4 * deflatedEnd + pingPong - 1;  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { dMin2 = Math.min(dMin2, work[l - 1]); [BUGGY] work[l - 1] =     Math.min(work[l - 1],               Math.min(work[3 + pingPong], work[7 + pingPong])); [BUGGY] Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } }  [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	replace	
20	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } } final int l = 4 * deflatedEnd + pingPong - 1;  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { dMin2 = Math.min(dMin2, work[l - 1]); [BUGGY] [BUGGY] work[l - 1] =     Math.min(work[l - 1],               Math.min(work[3 + pingPong], work[7 + pingPong])); Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } }  [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1056	1058	1	add	
21	[BUG] [BUGGY] work[l - 2 * pingPong] =  Math.min(work[l - 2 * pingPong],    Math.min(work[6 + pingPong], work[6 + pingPong])); [FE] AssertionFailedError [CONTEXT] final int l = 4 * deflatedEnd + pingPong - 1;  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { dMin2 = Math.min(dMin2, work[l - 1]); work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); [BUGGY] work[l - 2 * pingPong] =     Math.min(work[l - 2 * pingPong],               Math.min(work[6 + pingPong], work[6 + pingPong])); [BUGGY] Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } } if ((dMin < 0) || (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1], Math.min(work[l - 9], [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1059	1061	1	replace	
22	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] final int l = 4 * deflatedEnd + pingPong - 1;  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { dMin2 = Math.min(dMin2, work[l - 1]); work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); [BUGGY] [BUGGY] work[l - 2 * pingPong] =     Math.min(work[l - 2 * pingPong],               Math.min(work[6 + pingPong], work[6 + pingPong])); Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } } if ((dMin < 0) || (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1], Math.min(work[l - 9], [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1059	1061	1	add	
23	[BUG] [BUGGY] qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); [FE] AssertionFailedError [CONTEXT]  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { dMin2 = Math.min(dMin2, work[l - 1]); work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); [BUGGY] qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); [BUGGY] dMin= -0.0; } } if ((dMin < 0) || (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1], Math.min(work[l - 9], dMin2 + work[l - 2 * pingPong])))) {  computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1062	1062	1	replace	
24	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { dMin2 = Math.min(dMin2, work[l - 1]); work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); [BUGGY] [BUGGY] qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); dMin= -0.0; } } if ((dMin < 0) || (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1], Math.min(work[l - 9], dMin2 + work[l - 2 * pingPong])))) {  computeShiftIncrement(start, deflatedEnd, end - deflatedEnd); [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1062	1062	1	add	
25	[BUG] [BUGGY] dMin= -0.0; [FE] AssertionFailedError [CONTEXT] if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { dMin2 = Math.min(dMin2, work[l - 1]); work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); [BUGGY] dMin= -0.0; [BUGGY] } } if ((dMin < 0) || (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1], Math.min(work[l - 9], dMin2 + work[l - 2 * pingPong])))) {  computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);  [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1063	1063	1	replace	
26	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] if ((dMin <= 0) || (deflatedEnd < end)) { if (flipIfWarranted(deflatedEnd, 1)) { dMin2 = Math.min(dMin2, work[l - 1]); work[l - 1] = Math.min(work[l - 1], Math.min(work[3 + pingPong], work[7 + pingPong])); work[l - 2 * pingPong] = Math.min(work[l - 2 * pingPong], Math.min(work[6 + pingPong], work[6 + pingPong])); qMax= Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong])); [BUGGY] [BUGGY] dMin= -0.0; } } if ((dMin < 0) || (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1], Math.min(work[l - 9], dMin2 + work[l - 2 * pingPong])))) {  computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);  [CLASS] EigenDecompositionImpl Solver [METHOD] goodStep [RETURN_TYPE] int  final int start final int end [VARIABLES] boolean deflating loop double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1063	1063	1	add	
27	[BUG] [BUGGY] int j = 4 * n - 1; [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  [BUGGY] int j = 4 * n - 1; [BUGGY] for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1135	1135	1	replace	
28	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  [BUGGY] [BUGGY] int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1135	1135	1	add	
29	[BUG] [BUGGY] for (int i = 0; i < j; i += 4) { [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; [BUGGY] for (int i = 0; i < j; i += 4) { [BUGGY] for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1136	1136	1	replace	
30	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; [BUGGY] [BUGGY] for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1136	1136	1	add	
31	[BUG] [BUGGY] for (int k = 0; k < 4; k += step) { [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { [BUGGY] for (int k = 0; k < 4; k += step) { [BUGGY] final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1137	1137	1	replace	
32	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { [BUGGY] [BUGGY] for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1137	1137	1	add	
33	[BUG] [BUGGY] final double tmp = work[i + k]; [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { [BUGGY] final double tmp = work[i + k]; [BUGGY] work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1138	1138	1	replace	
34	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { [BUGGY] [BUGGY] final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1138	1138	1	add	
35	[BUG] [BUGGY] work[i + k] = work[j - k]; [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; [BUGGY] work[i + k] = work[j - k]; [BUGGY] work[j - k] = tmp; } j -= 4; } return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1139	1139	1	replace	
36	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; [BUGGY] [BUGGY] work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1139	1139	1	add	
37	[BUG] [BUGGY] work[j - k] = tmp; [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; [BUGGY] work[j - k] = tmp; [BUGGY] } j -= 4; } return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1140	1140	1	replace	
38	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; [BUGGY] [BUGGY] work[j - k] = tmp; } j -= 4; } return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1140	1140	1	add	
39	[BUG] [BUGGY] j -= 4; [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } [BUGGY] j -= 4; [BUGGY] } return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1142	1142	1	replace	
40	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } [BUGGY] [BUGGY] j -= 4; } return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1142	1142	1	add	
41	[BUG] [BUGGY] return true; [FE] AssertionFailedError [CONTEXT]  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } [BUGGY] return true; [BUGGY] } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1144	1144	1	replace	
42	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } [BUGGY] [BUGGY] return true; } return false; } [CLASS] EigenDecompositionImpl Solver [METHOD] flipIfWarranted [RETURN_TYPE] boolean  final int n final int step [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eps g invIJ lambda largestRoot lower lowerSpectra max mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns deflatedEnd end fourI i i0 index j k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1144	1144	1	add	
43	[BUG] [BUGGY] work[j4] = 0.0; [FE] AssertionFailedError [CONTEXT] } }  dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; if (work[j4 - 2] == 0.0) { [BUGGY] work[j4] = 0.0; [BUGGY] dN1= work[j4p2 + 2]; dMin = dN1; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN1 = dN2 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); [CLASS] EigenDecompositionImpl Solver [METHOD] dqd [RETURN_TYPE] void  final int start final int end [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious absoluteTolerance alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant di diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eiM1 eps g invIJ lambda largestRoot left lower lowerSpectra margin max middle mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius range ratio relativeTolerance right s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tNorm tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns count deflatedEnd end fourI i i0 index j j4 j4p2 k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1384	1384	1	replace	
44	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] } }  dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; if (work[j4 - 2] == 0.0) { [BUGGY] [BUGGY] work[j4] = 0.0; dN1= work[j4p2 + 2]; dMin = dN1; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN1 = dN2 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); [CLASS] EigenDecompositionImpl Solver [METHOD] dqd [RETURN_TYPE] void  final int start final int end [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious absoluteTolerance alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant di diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eiM1 eps g invIJ lambda largestRoot left lower lowerSpectra margin max middle mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius range ratio relativeTolerance right s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tNorm tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns count deflatedEnd end fourI i i0 index j j4 j4p2 k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1384	1384	1	add	
45	[BUG] [BUGGY] dN1= work[j4p2 + 2]; [FE] AssertionFailedError [CONTEXT] }  dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; [BUGGY] dN1= work[j4p2 + 2]; [BUGGY] dMin = dN1; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN1 = dN2 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]); [CLASS] EigenDecompositionImpl Solver [METHOD] dqd [RETURN_TYPE] void  final int start final int end [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious absoluteTolerance alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant di diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eiM1 eps g invIJ lambda largestRoot left lower lowerSpectra margin max middle mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius range ratio relativeTolerance right s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tNorm tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns count deflatedEnd end fourI i i0 index j j4 j4p2 k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1385	1385	1	replace	
46	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT] }  dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; [BUGGY] [BUGGY] dN1= work[j4p2 + 2]; dMin = dN1; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN1 = dN2 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]); [CLASS] EigenDecompositionImpl Solver [METHOD] dqd [RETURN_TYPE] void  final int start final int end [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious absoluteTolerance alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant di diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eiM1 eps g invIJ lambda largestRoot left lower lowerSpectra margin max middle mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius range ratio relativeTolerance right s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tNorm tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns count deflatedEnd end fourI i i0 index j j4 j4p2 k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1385	1385	1	add	
47	[BUG] [BUGGY] dMin = dN1; [FE] AssertionFailedError [CONTEXT]  dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; dN1= work[j4p2 + 2]; [BUGGY] dMin = dN1; [BUGGY] eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN1 = dN2 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]); } [CLASS] EigenDecompositionImpl Solver [METHOD] dqd [RETURN_TYPE] void  final int start final int end [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious absoluteTolerance alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant di diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eiM1 eps g invIJ lambda largestRoot left lower lowerSpectra margin max middle mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius range ratio relativeTolerance right s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tNorm tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns count deflatedEnd end fourI i i0 index j j4 j4p2 k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1386	1386	1	replace	
48	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; dN1= work[j4p2 + 2]; [BUGGY] [BUGGY] dMin = dN1; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN1 = dN2 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]); } [CLASS] EigenDecompositionImpl Solver [METHOD] dqd [RETURN_TYPE] void  final int start final int end [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious absoluteTolerance alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant di diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eiM1 eps g invIJ lambda largestRoot left lower lowerSpectra margin max middle mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius range ratio relativeTolerance right s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tNorm tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns count deflatedEnd end fourI i i0 index j j4 j4p2 k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1386	1386	1	add	
49	[BUG] [BUGGY] eMin = 0.0; [FE] AssertionFailedError [CONTEXT]  dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; dN1= work[j4p2 + 2]; dMin = dN1; [BUGGY] eMin = 0.0; [BUGGY] } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN1 = dN2 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]); } dMin = Math.min(dMin, dN1); [CLASS] EigenDecompositionImpl Solver [METHOD] dqd [RETURN_TYPE] void  final int start final int end [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious absoluteTolerance alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant di diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eiM1 eps g invIJ lambda largestRoot left lower lowerSpectra margin max middle mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius range ratio relativeTolerance right s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tNorm tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns count deflatedEnd end fourI i i0 index j j4 j4p2 k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1387	1387	1	replace	
50	[BUG] [BUGGY] [FE] AssertionFailedError [CONTEXT]  dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; dN1= work[j4p2 + 2]; dMin = dN1; [BUGGY] [BUGGY] eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN1 = dN2 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]); } dMin = Math.min(dMin, dN1); [CLASS] EigenDecompositionImpl Solver [METHOD] dqd [RETURN_TYPE] void  final int start final int end [VARIABLES] boolean double[] b bp imagEigenvalues invI main range realEigenvalues secondary squaredSecondary vData vK work ArrayRealVector[] eigenvectors RealMatrix b cachedD cachedV cachedVt matrix double TOLERANCE TOLERANCE_2 absDCurrent absDPrevious absoluteTolerance alpha b b2 beta c d dCurrent dMin dMin1 dMin2 dN dN1 dN2 delta determinant di diagMax diagMin e12 eCurrent eMax eMin ePrevious ei eiM1 eps g invIJ lambda largestRoot left lower lowerSpectra margin max middle mij minPivot mji offDiagMax offDiagMin oneFourth p previousEMin q q0 q1 q1q2Me22 q2 qMax r radius range ratio relativeTolerance right s sigma sigmaLow splitTolerance sqrtMq sumOffDiag t tNorm tau theta threeFourth tmp upper upperSpectra z0 z1 z2 int begin columns count deflatedEnd end fourI i i0 index j j4 j4p2 k l lowerStart m maxIter n n0 nColB oneFourthCount pingPong rows split start step tType threeFourthCount upperStart TriDiagonalTransformer transformer  	projects/Math80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java	1.0	1387	1387	1	add	
