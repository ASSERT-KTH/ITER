bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  compiler.getOutEdges();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  compiler.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  compiler.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    node.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	5	None	replace
2	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDeadExprStatements();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDeadExprStatements();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDeadExprStatements();	  List    <    DiGraphEdge    <    Node,Branch    >=    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
3	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDeadExprStatement();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDeadExprStatement();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDeadExprStatement();	  List    <    DiGraphEdge    <    Node,Branch    >=    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
4	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getCfgEdges();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getCfgEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getCfgEdges();	  List    <    DiGraphEdge    <    Node,Branch    >=    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
5	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getCfgNode();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getCfgNode();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getCfgNode();	  List    <    DiGraphEdge    <    Node,Branch    >=    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	2	None	replace
6	[BUG]  [BUGGY]  OutEdges  <  Node,Branch  >>  outEdges  =  n.getOutEdges();  [CE]  not  a  statement  [FE]        AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  OutEdges  <  Node,Branch  >>  outEdges  =  n.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	OutEdges  <  Node,Branch  >>  outEdges  =  n.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  not  a  statement	1	None	replace
7	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch!=  outEdges  =  n.getOutEdges();  [CE]  >  expected  [FE]          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch!=  outEdges  =  n.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch!=  outEdges  =  n.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  >  expected	1	None	replace
8	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  n.getInEdges();  [CE]  >  expected  [FE]                    AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  n.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  n.getInEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    n.getInEdges();    	non-compiled	[CE]  >  expected	7	None	replace
9	[BUG]  [BUGGY]  OutEdges  <  Node,Branch  >>  outEdges  =  n.getInEdges();  [CE]  not  a  statement  [FE]                      AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  OutEdges  <  Node,Branch  >>  outEdges  =  n.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	OutEdges  <  Node,Branch  >>  outEdges  =  n.getInEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    n.getInEdges();    	non-compiled	[CE]  not  a  statement	7	None	replace
10	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  [Delete]  outEdges  =  n.getInEdges();  [CE]  ']'  expected  [FE]                        AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  [Delete]  outEdges  =  n.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  [Delete]  outEdges  =  n.getInEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    n.getInEdges();    	non-compiled	[CE]  ']'  expected	7	None	replace
11	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  first.getInEdges();  [CE]  cannot  find  symbol  first  [FE]                          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  first.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  first.getInEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    n.getInEdges();    	non-compiled	[CE]  cannot  find  symbol  first	7	None	replace
12	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch!=  outEdges  =  n.getInEdges();  [CE]  >  expected  [FE]                            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch!=  outEdges  =  n.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch!=  outEdges  =  n.getInEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    n.getInEdges();    	non-compiled	[CE]  >  expected	7	None	replace
13	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges.getOutEdges();  [CE]  ';'  expected  [FE]                  AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    first.getOutEdges();    	non-compiled	[CE]  ';'  expected	6	None	replace
14	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  nextCfgNode.getOutEdges();  [CE]  cannot  find  symbol  nextCfgNode  [FE]            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  nextCfgNode.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  nextCfgNode.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    curCfgNode.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol  nextCfgNode	3	None	replace
15	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  firstCfgNode.getOutEdges();  [CE]  cannot  find  symbol  firstCfgNode  [FE]              AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  firstCfgNode.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  firstCfgNode.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    curCfgNode.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol  firstCfgNode	3	None	replace
16	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  cfgStack.getOutEdges();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  cfgStack.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  cfgStack.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    curCfgNode.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
17	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  node.getInEdges();  [CE]  cannot  find  symbol  node  [FE]    AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  node.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  node.getInEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    	non-compiled	[CE]  cannot  find  symbol  node	10	None	replace
18	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  [CE]  variable  outEdges  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)  [FE]    AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();	  	non-compiled	[CE]  variable  outEdges  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)	9	None	add
19	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  gNode.getInEdges();  [CE]  >  expected  [FE]      AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  gNode.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  gNode.getInEdges();	  	non-compiled	[CE]  >  expected	9	None	add
20	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  [Delete]  outEdges  =  gNode.getInEdges();  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  [Delete]  outEdges  =  gNode.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    List  <  DiGraphEdge  <  Node,Branch  [Delete]  outEdges  =  gNode.getInEdges();	  	non-compiled	[CE]  ']'  expected	9	None	add
21	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >>  gNode.getInEdges();  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >>  gNode.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    List  <  DiGraphEdge  <  Node,Branch  >>  gNode.getInEdges();	  	non-compiled	[CE]  ';'  expected	9	None	add
22	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch!=  outEdges  =  gNode.getInEdges();  [CE]  >  expected  [FE]            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch!=  outEdges  =  gNode.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    List  <  DiGraphEdge  <  Node,Branch!=  outEdges  =  gNode.getInEdges();	  	non-compiled	[CE]  >  expected	9	None	add
23	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  ==  outEdges  =  gNode.getInEdges();  [CE]  >  expected  [FE]              AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  ==  outEdges  =  gNode.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    List  <  DiGraphEdge  <  Node,Branch  ==  outEdges  =  gNode.getInEdges();	  	non-compiled	[CE]  >  expected	9	None	add
24	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  Collection  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  Collection  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    Collection  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();	  	non-compiled	[CE]  cannot  find  symbol	9	None	add
25	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >=  gNode.getInEdges();  [CE]  >  expected  [FE]                  AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >=  gNode.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    List  <  DiGraphEdge  <  Node,Branch  >=  gNode.getInEdges();	  	non-compiled	[CE]  >  expected	9	None	add
26	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getInEdges();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getInEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
27	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  getOutEdges();  [CE]  >  expected  [FE]            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    getOutEdges();    	non-compiled	[CE]  >  expected	11	None	replace
28	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getDeadExprStatements();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getDeadExprStatements();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getDeadExprStatements();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
29	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getCfgStack();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getCfgStack();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getCfgStack();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
30	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getOutEdges(n);  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getOutEdges(n);  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getOutEdges(n);	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
31	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getConstEdges();  [CE]  cannot  find  symbol  [FE]                    AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getConstEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getConstEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
32	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  n.outEdges  =  this.outEdges.getOutEdges();  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  n.outEdges  =  this.outEdges.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  n.outEdges  =  this.outEdges.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    this.outEdges.getOutEdges();    	non-compiled	[CE]  ';'  expected	12	None	replace
33	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.outEdges.getOutEdges();  [CE]  cannot  find  symbol  outEdges  [FE]          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.outEdges.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.outEdges.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    this.outEdges.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol  outEdges	12	None	replace
34	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  this.outEdges.getOutEdges();  [CE]  >  expected  [FE]            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  this.outEdges.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >=  outEdges  =  this.outEdges.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    this.outEdges.getOutEdges();    	non-compiled	[CE]  >  expected	12	None	replace
35	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >=  outEdges.getOutEdges();  [CE]  >  expected  [FE]              AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >=  outEdges.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >=  outEdges.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    this.outEdges.getOutEdges();    	non-compiled	[CE]  >  expected	12	None	replace
36	[BUG]  [BUGGY]  Node  outEdges  =  n.getFirstChild();  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Node  outEdges  =  n.getFirstChild();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Node  outEdges  =  n.getFirstChild();	      	non-compiled	[CE]  cannot  find  symbol	8	None	replace
37	[BUG]  [BUGGY]  Node  n  =  n.getFirstChild();  [CE]  variable  n  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)  [FE]                        AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Node  n  =  n.getFirstChild();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Node  n  =  n.getFirstChild();	      	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)	8	None	replace
38	[BUG]  [BUGGY]  Node  n  =  first.getNext();  [CE]  variable  n  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)  [FE]                          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Node  n  =  first.getNext();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Node  n  =  first.getNext();	      	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)	8	None	replace
39	[BUG]  [BUGGY]  Node  firstCfgNode  =  n.getLastChild();  [CE]  cannot  find  symbol  outEdges  [FE]                            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Node  firstCfgNode  =  n.getLastChild();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Node  firstCfgNode  =  n.getLastChild();	      	non-compiled	[CE]  cannot  find  symbol  outEdges	8	None	replace
40	[BUG]  [BUGGY]  Node  firstCfgNode  =  n.getFirstChild();  [CE]  cannot  find  symbol  outEdges  [FE]                              AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Node  firstCfgNode  =  n.getFirstChild();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Node  firstCfgNode  =  n.getFirstChild();	      	non-compiled	[CE]  cannot  find  symbol  outEdges	8	None	replace
41	[BUG]  [BUGGY]  Node  n  =  first.getFirstChild();  [CE]  variable  n  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)  [FE]                                AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Node  n  =  first.getFirstChild();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Node  n  =  first.getFirstChild();	      	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)	8	None	replace
42	[BUG]  [BUGGY]  Node  first  =  n.getFirstChild();  [CE]  cannot  find  symbol  outEdges  [FE]                                  AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Node  first  =  n.getFirstChild();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Node  first  =  n.getFirstChild();	      	non-compiled	[CE]  cannot  find  symbol  outEdges	8	None	replace
43	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getConditionalBranch();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getConditionalBranch();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getConditionalBranch();	  List    <    DiGraphEdge    <    Node,Branch    [Delete]    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
44	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  curCfg.getOutEdges();  [CE]  no  suitable  method  found  for  getOutEdges()  [FE]                AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  curCfg.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  curCfg.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    node.getOutEdges();    	non-compiled	[CE]  no  suitable  method  found  for  getOutEdges()	5	None	replace
45	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  nodes.getOutEdges();  [CE]  cannot  find  symbol  nodes  [FE]                  AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  nodes.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  nodes.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    first.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol  nodes	6	None	replace
46	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >>  OutEdges  =  gNode.getInEdges();  [CE]  variable  outEdges  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)  [FE]    AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >>  OutEdges  =  gNode.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    List  <  DiGraphEdge  <  Node,Branch  >>  OutEdges  =  gNode.getInEdges();	  	non-compiled	[CE]  variable  outEdges  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)	9	None	add
47	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getOutEdges();  [CE]  variable  outEdges  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)  [FE]      AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getInEdges();  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getOutEdges();	  	non-compiled	[CE]  variable  outEdges  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)	9	None	add
48	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDestination();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDestination();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDestination();	  List    <    DiGraphEdge    <    Node,Branch    [Delete]    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
49	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getLeastSupertype(n.getOutEdges());  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getLeastSupertype(n.getOutEdges());  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getLeastSupertype(n.getOutEdges());	  List    <    DiGraphEdge    <    Node,Branch    [Delete]    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
50	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getDeadExprStatements();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getDeadExprStatements();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getDeadExprStatements();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
51	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getDestination();  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getDestination();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getDestination();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
52	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getConditionExpressions();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getConditionExpressions();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getConditionExpressions();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
53	[BUG]  [BUGGY]  Preconditions.checkState(outEdges.size()  ==  1);  [CE]  cannot  find  symbol  outEdges  [FE]                      AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Preconditions.checkState(outEdges.size()  ==  1);  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Preconditions.checkState(outEdges.size()  ==  1);	      	non-compiled	[CE]  cannot  find  symbol  outEdges	8	None	replace
54	[BUG]  [BUGGY]  Node  outEdges  =  n.getChildren();  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Node  outEdges  =  n.getChildren();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Node  outEdges  =  n.getChildren();	      	non-compiled	[CE]  cannot  find  symbol	8	None	replace
55	[BUG]  [BUGGY]  Node  n  =  outEdges.get(0);  [CE]  variable  n  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)  [FE]                          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Node  n  =  outEdges.get(0);  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Node  n  =  outEdges.get(0);	      	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)	8	None	replace
56	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  outEdges.getOutEdges();  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  outEdges.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  outEdges.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    first.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	6	None	replace
57	[BUG]  [BUGGY]  List  <  Node>  outEdges  =  n.getEdges();  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  Node>  outEdges  =  n.getEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  Node>  outEdges  =  n.getEdges();	      	non-compiled	[CE]  cannot  find  symbol	8	None	replace
58	[BUG]  [BUGGY]  List  <  Node>  outEdges  =  n.getChildren();  [CE]  cannot  find  symbol  [FE]                        AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  Node>  outEdges  =  n.getChildren();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  Node>  outEdges  =  n.getChildren();	      	non-compiled	[CE]  cannot  find  symbol	8	None	replace
59	[BUG]  [BUGGY]  Node  n  =  outEdges.get(0).getDestination();  [CE]  variable  n  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)  [FE]                          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  Node  n  =  outEdges.get(0).getDestination();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	Node  n  =  outEdges.get(0).getDestination();	      	non-compiled	[CE]  variable  n  is  already  defined  in  method  tryRemoveUnconditionalBranching(Node)	8	None	replace
60	[BUG]  [BUGGY]  OutEdges  outEdges  =  n.getOutEdges();  [CE]  cannot  find  symbol  [FE]                            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  OutEdges  outEdges  =  n.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	OutEdges  outEdges  =  n.getOutEdges();	      	non-compiled	[CE]  cannot  find  symbol	8	None	replace
61	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getAllEdges();  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getAllEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  gNode.getAllEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    gNode.getInEdges();    	non-compiled	[CE]  cannot  find  symbol	10	None	replace
62	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getCfgNode().getOutEdges();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getCfgNode().getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  getCfgNode().getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    curCfgNode.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	3	None	replace
63	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  list.getOutEdges();  [CE]  cannot  find  symbol  list  [FE]                AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  list.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  list.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    node.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol  list	5	None	replace
64	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  mergeOutEdges(n);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  mergeOutEdges(n);  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  mergeOutEdges(n);	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
65	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  mergeOutEdges();  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  mergeOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  mergeOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	11	None	replace
66	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  allEdges.getOutEdges();  [CE]  cannot  find  symbol  allEdges  [FE]        AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  allEdges.getOutEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  allEdges.getOutEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    this.outEdges.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol  allEdges	12	None	replace
67	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getContainingFunction();  [CE]  cannot  find  symbol  [FE]              AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getContainingFunction();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getContainingFunction();	  List    <    DiGraphEdge    <    Node,Branch    [Delete]    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
68	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDeepestStatements();  [CE]  cannot  find  symbol  [FE]                AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDeepestStatements();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getDeepestStatements();	  List    <    DiGraphEdge    <    Node,Branch    [Delete]    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
69	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getCfg();  [CE]  cannot  find  symbol  [FE]                  AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getCfg();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  n.getCfg();	  List    <    DiGraphEdge    <    Node,Branch    [Delete]    outEdges    =    n.getOutEdges();    	non-compiled	[CE]  cannot  find  symbol	4	None	replace
70	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  this.outEdges.getInEdges();  [CE]  cannot  find  symbol  outEdges  [FE]                    AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  this.outEdges.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  this.outEdges.getInEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    n.getInEdges();    	non-compiled	[CE]  cannot  find  symbol  outEdges	7	None	replace
71	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  outEdges.getInEdges();  [CE]  cannot  find  symbol  [FE]                      AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  outEdges.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  outEdges.getInEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    n.getInEdges();    	non-compiled	[CE]  cannot  find  symbol	7	None	replace
72	[BUG]  [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  list.getInEdges();  [CE]  cannot  find  symbol  list  [FE]                        AssertionFailedError    [CONTEXT]    case  Token.RETURN:  if  (n.hasChildren())  {  break;  }  case  Token.BREAK:  case  Token.CONTINUE:        [BUGGY]  List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  list.getInEdges();  [BUGGY]    if  (outEdges.size()  ==  1  &&  (n.getNext()  ==  null  ||  n.getNext().getType()  ==  Token.FUNCTION))  {  Preconditions.checkState(outEdges.get(0).getValue()  ==  Branch.UNCOND);  Node  fallThrough  =  tryRemoveUnconditionalBranching(computeFollowing(n));  Node  nextCfgNode  =  outEdges.get(0).getDestination().getValue();  if  (nextCfgNode  ==  fallThrough)  {  removeDeadExprStatementSafely(n);  return  fallThrough;  [CLASS]  UnreachableCodeElimination  [METHOD]  tryRemoveUnconditionalBranching  [RETURN_TYPE]  Node  Node  n  [VARIABLES]  AbstractCompiler  compiler  DiGraphNode  gNode  boolean  removeNoOpStatements  ControlFlowGraph  curCfg  Node  fallThrough  first  n  nextCfgNode  List  outEdges  Logger  logger  Deque  cfgStack  	projects/Closure85/src/com/google/javascript/jscomp/UnreachableCodeElimination.java	0.4472135954999579	177	177	2	replace	List  <  DiGraphEdge  <  Node,Branch  >>  outEdges  =  list.getInEdges();	  List    <    DiGraphEdge    <    Node,Branch    >>    outEdges    =    n.getInEdges();    	non-compiled	[CE]  cannot  find  symbol  list	7	None	replace
