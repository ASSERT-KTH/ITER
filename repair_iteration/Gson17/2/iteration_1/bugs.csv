bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  [FE]  JsonParseException  [FE]    JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]  if  (in.peek()  ==  JsonToken.STRING)  {  [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	add	if  (in.peek()  ==  JsonToken.STRING)  {	if  (in.peek()  !=  JsonToken.STRING)  {  	compilable	  [FE]  JsonParseException  	3	5	replace
2	[BUG]  [BUGGY]  if  (in.peek()  ==  JsonToken.STRING)  {  [FE]  JsonParseException  [FE]    JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]  if  (in.peek()  ==  JsonToken.STRING)  {  [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	replace	if  (in.peek()  ==  JsonToken.STRING)  {	if  (in.peek()  !=  JsonToken.STRING)  {  	compilable	  [FE]  JsonParseException  	3	5	replace
3	[BUG]  [BUGGY]  if  (in.nextString()!=  JsonToken.STRING)  {  [CE]  incomparable  types:  String  and  JsonToken  [FE]      JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]  if  (in.nextString()!=  JsonToken.STRING)  {  [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	replace	if  (in.nextString()!=  JsonToken.STRING)  {	if  (in.peek()  !=  JsonToken.STRING)  {  	non-compiled	[CE]  incomparable  types:  String  and  JsonToken	3	None	replace
4	[BUG]  [BUGGY]  if(in.peek()!=  JsonToken.VALUE_STRING)  {  [CE]  cannot  find  symbol  VALUE_STRING  [FE]        JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]  if(in.peek()!=  JsonToken.VALUE_STRING)  {  [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	replace	if(in.peek()!=  JsonToken.VALUE_STRING)  {	if  (in.peek()  !=  JsonToken.STRING)  {  	non-compiled	[CE]  cannot  find  symbol  VALUE_STRING	3	None	replace
5	[BUG]  [BUGGY]  if(in.peek()  ==  JsonToken.VALUE_STRING)  {  [CE]  cannot  find  symbol  VALUE_STRING  [FE]          JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]  if(in.peek()  ==  JsonToken.VALUE_STRING)  {  [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	replace	if(in.peek()  ==  JsonToken.VALUE_STRING)  {	if  (in.peek()  !=  JsonToken.STRING)  {  	non-compiled	[CE]  cannot  find  symbol  VALUE_STRING	3	None	replace
6	[BUG]  [BUGGY]    [CE]  illegal  start  of  type  [FE]            JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]    [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	replace	  	if  (in.peek()  !=  JsonToken.STRING)  {  	non-compiled	[CE]  illegal  start  of  type	3	None	replace
7	[BUG]  [BUGGY]  [FE]  JsonParseException  [FE]    JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]  if  (in  ==  null  ||  in.peek()!=  JsonToken.STRING)  {  [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	add	if  (in  ==  null  ||  in.peek()!=  JsonToken.STRING)  {	if  (in.peek()  !=  JsonToken.STRING)  {  	compilable	  [FE]  JsonParseException  	3	2	replace
8	[BUG]  [BUGGY]  if  (in  ==  null  ||  in.peek()!=  JsonToken.STRING)  {  [FE]  JsonParseException  [FE]    JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]  if  (in  ==  null  ||  in.peek()!=  JsonToken.STRING)  {  [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	replace	if  (in  ==  null  ||  in.peek()!=  JsonToken.STRING)  {	if  (in.peek()  !=  JsonToken.STRING)  {  	compilable	  [FE]  JsonParseException  	3	2	replace
9	[BUG]  [BUGGY]  [FE]  JsonParseException  [FE]      JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]  if  (in!=  null  ||  in.peek()!=  JsonToken.STRING)  {  [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	add	if  (in!=  null  ||  in.peek()!=  JsonToken.STRING)  {	if  (in.peek()  !=  JsonToken.STRING)  {  	compilable	  [FE]  JsonParseException  	3	6	replace
10	[BUG]  [BUGGY]  if  (in!=  null  ||  in.peek()!=  JsonToken.STRING)  {  [FE]  JsonParseException  [FE]      JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]  if  (in!=  null  ||  in.peek()!=  JsonToken.STRING)  {  [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	replace	if  (in!=  null  ||  in.peek()!=  JsonToken.STRING)  {	if  (in.peek()  !=  JsonToken.STRING)  {  	compilable	  [FE]  JsonParseException  	3	6	replace
11	[BUG]  [BUGGY]  if(in.next()!=  JsonToken.STRING)  {  [CE]  cannot  find  symbol  [FE]    JsonParseException  [CONTEXT]  public  Date  read(JsonReader  in)  throws  IOException  {  [BUGGY]  if(in.next()!=  JsonToken.STRING)  {  [BUGGY]  throw  new  JsonParseException( "The  date  should  be  a  string  value ");  }  Date  date  =  deserializeToDate(in.nextString());  if  (dateType  ==  Date.class)  {  return  date;  }  else  if  (dateType  ==  Timestamp.class)  {  return  new  Timestamp(date.getTime());  }  else  if  (dateType  ==  java.sql.Date.class)  {  return  new  java.sql.Date(date.getTime());  }  else  {  [CLASS]  DefaultDateTypeAdapter  [METHOD]  read  [RETURN_TYPE]  Date  JsonReader  in  [VARIABLES]  JsonReader  in  Class  dateType  String  SIMPLE_NAME  dateFormatAsString  datePattern  boolean  Date  date  DateFormat  enUsFormat  localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	replace	if(in.next()!=  JsonToken.STRING)  {	if  (in.peek()  !=  JsonToken.STRING)  {  	non-compiled	[CE]  cannot  find  symbol	3	None	replace
