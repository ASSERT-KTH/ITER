bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	failing_test_number	action	patch
1	[BUG] [BUGGY] throw new JsonParseException("The date should be a string value"); [FE] JsonParseException [CONTEXT] public Date read(JsonReader in) throws IOException { if (in.peek() != JsonToken.STRING) { [BUGGY] throw new JsonParseException("The date should be a string value"); [BUGGY] } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else {  [CLASS] DefaultDateTypeAdapter [METHOD] read [RETURN_TYPE] Date  JsonReader in [VARIABLES] JsonReader in Class dateType String SIMPLE_NAME dateFormatAsString datePattern boolean Date date DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	1.0	100	100	2	replace	
2	[BUG] [BUGGY] [FE] JsonParseException [CONTEXT] public Date read(JsonReader in) throws IOException { if (in.peek() != JsonToken.STRING) { [BUGGY] [BUGGY] throw new JsonParseException("The date should be a string value"); } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else {  [CLASS] DefaultDateTypeAdapter [METHOD] read [RETURN_TYPE] Date  JsonReader in [VARIABLES] JsonReader in Class dateType String SIMPLE_NAME dateFormatAsString datePattern boolean Date date DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	1.0	100	100	2	add	
3	[BUG] [BUGGY] if (in.peek() != JsonToken.STRING) { [FE] JsonParseException [CONTEXT] public Date read(JsonReader in) throws IOException { [BUGGY] if (in.peek() != JsonToken.STRING) { [BUGGY] throw new JsonParseException("The date should be a string value"); } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { [CLASS] DefaultDateTypeAdapter [METHOD] read [RETURN_TYPE] Date  JsonReader in [VARIABLES] JsonReader in Class dateType String SIMPLE_NAME dateFormatAsString datePattern boolean Date date DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	replace	
4	[BUG] [BUGGY] [FE] JsonParseException [CONTEXT] public Date read(JsonReader in) throws IOException { [BUGGY] [BUGGY] if (in.peek() != JsonToken.STRING) { throw new JsonParseException("The date should be a string value"); } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { [CLASS] DefaultDateTypeAdapter [METHOD] read [RETURN_TYPE] Date  JsonReader in [VARIABLES] JsonReader in Class dateType String SIMPLE_NAME dateFormatAsString datePattern boolean Date date DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5773502691896258	99	99	2	add	
5	[BUG] [BUGGY] this(dateType, DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US), DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)); [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(Class<? extends Date> dateType) { [BUGGY] this(dateType,  DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),    DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)); [BUGGY] DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US), DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)); } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] Class)  Date> dateType [VARIABLES] Class dateType String SIMPLE_NAME boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5	49	51	2	replace	
6	[BUG] [BUGGY] [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(Class<? extends Date> dateType) { [BUGGY] [BUGGY] this(dateType,  DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),    DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)); DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US), DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)); } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] Class)  Date> dateType [VARIABLES] Class dateType String SIMPLE_NAME boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5	49	51	2	add	
7	[BUG] [BUGGY] } [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(Class<? extends Date> dateType) { this(dateType, DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US), DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)); [BUGGY] } [BUGGY]  [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] Class)  Date> dateType [VARIABLES] Class dateType String SIMPLE_NAME boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5	52	52	2	replace	
8	[BUG] [BUGGY] [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(Class<? extends Date> dateType) { this(dateType, DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US), DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT)); [BUGGY] [BUGGY] } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] Class)  Date> dateType [VARIABLES] Class dateType String SIMPLE_NAME boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.5	52	52	2	add	
9	[BUG] [BUGGY] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { [FE] JsonParseException [CONTEXT] [BUGGY] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { [BUGGY] if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } this.dateType = dateType; this.enUsFormat = enUsFormat; this.localFormat = localFormat; } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	74	74	2	replace	
10	[BUG] [BUGGY] [FE] JsonParseException [CONTEXT] [BUGGY] [BUGGY] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } this.dateType = dateType; this.enUsFormat = enUsFormat; this.localFormat = localFormat; } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	74	74	2	add	
11	[BUG] [BUGGY] if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { [BUGGY] if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { [BUGGY] throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } this.dateType = dateType; this.enUsFormat = enUsFormat; this.localFormat = localFormat; } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	75	75	2	replace	
12	[BUG] [BUGGY] [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { [BUGGY] [BUGGY] if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } this.dateType = dateType; this.enUsFormat = enUsFormat; this.localFormat = localFormat; } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	75	75	2	add	
13	[BUG] [BUGGY] this.dateType = dateType; [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } [BUGGY] this.dateType = dateType; [BUGGY] this.enUsFormat = enUsFormat; this.localFormat = localFormat; } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	78	78	2	replace	
14	[BUG] [BUGGY] [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } [BUGGY] [BUGGY] this.dateType = dateType; this.enUsFormat = enUsFormat; this.localFormat = localFormat; } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	78	78	2	add	
15	[BUG] [BUGGY] this.enUsFormat = enUsFormat; [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } this.dateType = dateType; [BUGGY] this.enUsFormat = enUsFormat; [BUGGY] this.localFormat = localFormat; } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	79	79	2	replace	
16	[BUG] [BUGGY] [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } this.dateType = dateType; [BUGGY] [BUGGY] this.enUsFormat = enUsFormat; this.localFormat = localFormat; } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	79	79	2	add	
17	[BUG] [BUGGY] this.localFormat = localFormat; [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } this.dateType = dateType; this.enUsFormat = enUsFormat; [BUGGY] this.localFormat = localFormat; [BUGGY] } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	80	80	2	replace	
18	[BUG] [BUGGY] [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } this.dateType = dateType; this.enUsFormat = enUsFormat; [BUGGY] [BUGGY] this.localFormat = localFormat; } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	80	80	2	add	
19	[BUG] [BUGGY] } [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } this.dateType = dateType; this.enUsFormat = enUsFormat; this.localFormat = localFormat; [BUGGY] } [BUGGY]  [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	81	81	2	replace	
20	[BUG] [BUGGY] [FE] JsonParseException [CONTEXT] DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException("Date type must be one of " + Date.class + ", " + Timestamp.class + ", or " + java.sql.Date.class + " but was " + dateType); } this.dateType = dateType; this.enUsFormat = enUsFormat; this.localFormat = localFormat; [BUGGY] [BUGGY] } [CLASS] DefaultDateTypeAdapter [METHOD] <init> [RETURN_TYPE] DateFormat)  Date> dateType DateFormat enUsFormat DateFormat localFormat [VARIABLES] Class dateType String SIMPLE_NAME datePattern boolean DateFormat enUsFormat localFormat  	projects/Gson17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java	0.4472135954999579	81	81	2	add	
