bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols.length;  ++j)  {  [CE]  int  cannot  be  dereferenced  [FE]    AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]  for(int  j  =  0;  j  <  solvedCols.length;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	for(int  j  =  0;  j  <  solvedCols.length;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	non-compiled	[CE]  int  cannot  be  dereferenced	31	None	replace
2	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  fixedCols;  ++j)  {  [CE]  cannot  find  symbol  fixedCols  [FE]      AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]  for(int  j  =  0;  j  <  fixedCols;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	for(int  j  =  0;  j  <  fixedCols;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	non-compiled	[CE]  cannot  find  symbol  fixedCols	31	None	replace
3	[BUG]  [BUGGY]    [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    [BUGGY]  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	  	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	non-compiled	[CE]  class,  interface,  or  enum  expected	31	None	replace
4	[BUG]  [BUGGY]    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  xK;  [CE]  cannot  find  symbol  k  [FE]    AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  xK;  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  xK;		non-compiled	[CE]  cannot  find  symbol  k	32	None	add
5	[BUG]  [BUGGY]    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  xNorm;  [CE]  cannot  find  symbol  k  [FE]      AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  xNorm;  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  xNorm;		non-compiled	[CE]  cannot  find  symbol  k	32	None	add
6	[BUG]  [BUGGY]    double  xK  =  permutation[k]  *  point[k];  xNorm+=  Math.sqrt(xK);  [CE]  cannot  find  symbol  k  [FE]        AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    double  xK  =  permutation[k]  *  point[k];  xNorm+=  Math.sqrt(xK);  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	    double  xK  =  permutation[k]  *  point[k];  xNorm+=  Math.sqrt(xK);		non-compiled	[CE]  cannot  find  symbol  k	32	None	add
7	[BUG]  [BUGGY]    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  oldX;  [CE]  cannot  find  symbol  k  [FE]          AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  oldX;  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  oldX;		non-compiled	[CE]  cannot  find  symbol  k	32	None	add
8	[BUG]  [BUGGY]    double  solvedCols  =  diag[k]  *  oldX[k];  xNorm+=  xK  *  xK;  [CE]  cannot  find  symbol  k  [FE]    AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    double  solvedCols  =  diag[k]  *  oldX[k];  xNorm+=  xK  *  xK;  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	    double  solvedCols  =  diag[k]  *  oldX[k];  xNorm+=  xK  *  xK;		non-compiled	[CE]  cannot  find  symbol  k	32	None	add
9	[BUG]  [BUGGY]    double  solvedCols  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  [CE]  cannot  find  symbol  k  [FE]      AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    double  solvedCols  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	    double  solvedCols  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;		non-compiled	[CE]  cannot  find  symbol  k	32	None	add
10	[BUG]  [BUGGY]    double  solvedCols  =  diag[k]  *  permutation[k];  xNorm+=  oldX[xNorm];  [CE]  cannot  find  symbol  k  [FE]        AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    double  solvedCols  =  diag[k]  *  permutation[k];  xNorm+=  oldX[xNorm];  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	    double  solvedCols  =  diag[k]  *  permutation[k];  xNorm+=  oldX[xNorm];		non-compiled	[CE]  cannot  find  symbol  k	32	None	add
11	[BUG]  [BUGGY]    double  solvedCols  =  diag[k]  *  point[k];  xNorm+=  oldX[xNorm];  [CE]  cannot  find  symbol  k  [FE]          AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    double  solvedCols  =  diag[k]  *  point[k];  xNorm+=  oldX[xNorm];  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	    double  solvedCols  =  diag[k]  *  point[k];  xNorm+=  oldX[xNorm];		non-compiled	[CE]  cannot  find  symbol  k	32	None	add
12	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	add	for(int  j  =  0;  j  <  diag.length;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	compilable	  [FE]  AssertionFailedError  	31	2	replace
13	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]  for(int  j  =  0;  j  <  diag.length;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	for(int  j  =  0;  j  <  diag.length;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	compilable	  [FE]  AssertionFailedError  	31	2	replace
14	[BUG]  [BUGGY]    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  tmpVec;  [CE]  cannot  find  symbol  k  [FE]    AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  tmpVec;  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	    double  xK  =  permutation[k]  *  point[k];  xNorm+=  xK  *  tmpVec;		non-compiled	[CE]  cannot  find  symbol  k	32	None	add
15	[BUG]  [BUGGY]    double[]  solvedCols  =  diag[k]  *  costRelativeTolerance;  [CE]  cannot  find  symbol  k  [FE]      AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]    double[]  solvedCols  =  diag[k]  *  costRelativeTolerance;  [BUGGY]  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	    double[]  solvedCols  =  diag[k]  *  costRelativeTolerance;		non-compiled	[CE]  cannot  find  symbol  k	32	None	add
16	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]  for(int  j  =  0;  j  <  2;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	add	for(int  j  =  0;  j  <  2;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	compilable	  [FE]  AssertionFailedError  	31	11	replace
17	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  2;  ++j)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  xK  =  diag[k]  *  point[k];  xNorm+=  xK  *  xK;  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  [BUGGY]  for(int  j  =  0;  j  <  2;  ++j)  {  [BUGGY]  int  pj  =  permutation[j];  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	427	427	2	replace	for(int  j  =  0;  j  <  2;  ++j)  {	for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  	compilable	  [FE]  AssertionFailedError  	31	11	replace
