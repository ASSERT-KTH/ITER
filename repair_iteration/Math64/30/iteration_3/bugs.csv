bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  sum  /=  work2[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work2[pj];    sum  /=  work2[pj];	  	compilable	  [FE]  AssertionFailedError  	52	4	add
2	[BUG]  [BUGGY]  sum  /=  work2[pj];  sum  /=  work2[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  sum  /=  work2[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work2[pj];    sum  /=  work2[pj];	  	compilable	  [FE]  AssertionFailedError  	52	4	add
3	[BUG]  [BUGGY]  sum  /=  work2[pj];  Sum  /=  work2[pj];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  Sum  /=  work2[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work2[pj];    Sum  /=  work2[pj];	  	non-compiled	[CE]  cannot  find  symbol  Sum	52	None	add
4	[BUG]  [BUGGY]  sum  /=  work2[pj];  double  /=  work2[pj];  [CE]  unexpected  type  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  double  /=  work2[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work2[pj];    double  /=  work2[pj];	  	non-compiled	[CE]  unexpected  type	52	None	add
5	[BUG]  [BUGGY]  sum  /=  work2[pj];  total  /=  work2[pj];  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  total  /=  work2[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work2[pj];    total  /=  work2[pj];	  	non-compiled	[CE]  cannot  find  symbol  total	52	None	add
6	[BUG]  [BUGGY]  sum  /=  work2[pj];  sum  /=  work2)[pj];  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  sum  /=  work2)[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work2[pj];    sum  /=  work2)[pj];	  	non-compiled	[CE]  ';'  expected	52	None	add
7	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	5	add
8	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	5	add
9	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	5	add
10	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	5	add
11	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	4	add
12	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	4	add
13	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	4	add
14	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	4	add
15	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	5	add
16	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	5	add
17	[BUG]  [BUGGY]  sum  /=  solveCols[0];  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  solveCols[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  solveCols[0];	  sum    /=    diag[0];    	non-compiled	[CE]  cannot  find  symbol  solveCols	84	None	replace
18	[BUG]  [BUGGY]  sum  /=  diagnostic[0];  [CE]  cannot  find  symbol  diagnostic  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diagnostic[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  diagnostic[0];	  sum    /=    diag[0];    	non-compiled	[CE]  cannot  find  symbol  diagnostic	84	None	replace
19	[BUG]  [BUGGY]  sum  /=  work[0];  [CE]  cannot  find  symbol  work  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work[0];	  sum    /=    diag[0];    	non-compiled	[CE]  cannot  find  symbol  work	84	None	replace
20	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  array  required,  but  int  found  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  array  required,  but  int  found	122	None	replace
21	[BUG]  [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  bucket  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  bucket	122	None	replace
22	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	122	None	replace
23	[BUG]  [BUGGY]  double  diag[i][pj]  *  qy[i];  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[i][pj]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[i][pj]  *  qy[i];	  int    diag[i][pj]    *    qy[i];    	non-compiled	[CE]  ']'  expected	22	None	replace
24	[BUG]  [BUGGY]  double[i][pj]  *  qy[i];  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double[i][pj]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double[i][pj]  *  qy[i];	  int    diag[i][pj]    *    qy[i];    	non-compiled	[CE]  ']'  expected	22	None	replace
25	[BUG]  [BUGGY]  int  diag[i][pj]  *  qy[i]  +  1;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  diag[i][pj]  *  qy[i]  +  1;  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  diag[i][pj]  *  qy[i]  +  1;	  int    diag[i][pj]    *    qy[i];    	non-compiled	[CE]  ']'  expected	22	None	replace
26	[BUG]  [BUGGY]  int  diag[i][pj]  *  work3[i];  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  diag[i][pj]  *  work3[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  diag[i][pj]  *  work3[i];	  int    diag[i][pj]    *    qy[i];    	non-compiled	[CE]  ']'  expected	22	None	replace
27	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work2[j];	  sum    /=    work3[j];    	compilable	  [FE]  AssertionFailedError  	55	5	replace
28	[BUG]  [BUGGY]  sum  /=  work2[j];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work2[j];	  sum    /=    work3[j];    	compilable	  [FE]  AssertionFailedError  	55	5	replace
29	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[j];	  sum    /=    work3[j];    	compilable	  [FE]  AssertionFailedError  	55	5	replace
30	[BUG]  [BUGGY]  sum  /=  work1[j];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[j];	  sum    /=    work3[j];    	compilable	  [FE]  AssertionFailedError  	55	5	replace
31	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  sum  /=  work3[pj];	  sum    /=    work3[pj];    total    /=    work3[pj];    	compilable	  [FE]  AssertionFailedError  	36	5	replace
32	[BUG]  [BUGGY]  sum  /=  work1[pj];  sum  /=  work3[pj];  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  sum  /=  work3[pj];	  sum    /=    work3[pj];    total    /=    work3[pj];    	compilable	  [FE]  AssertionFailedError  	36	5	replace
33	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols[0],  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols[0],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(solvedCols[0],  sum);	  double    diag[0]    =    Math.sqrt(solvedCols[i],    sum);    	non-compiled	[CE]  ']'  expected	102	None	replace
34	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols[1],  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols[1],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(solvedCols[1],  sum);	  double    diag[0]    =    Math.sqrt(solvedCols[i],    sum);    	non-compiled	[CE]  ']'  expected	102	None	replace
35	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols[i],  sum  +  1);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols[i],  sum  +  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(solvedCols[i],  sum  +  1);	  double    diag[0]    =    Math.sqrt(solvedCols[i],    sum);    	non-compiled	[CE]  ']'  expected	102	None	replace
36	[BUG]  [BUGGY]  sum  /=  solvedCols[i];  [CE]  cannot  find  symbol  i  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  solvedCols[i];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  solvedCols[i];	  sum    /=    solvedCols[pj];    	non-compiled	[CE]  cannot  find  symbol  i	17	None	replace
37	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(solvedCols[i],  sum  +  1);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(solvedCols[i],  sum  +  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(solvedCols[i],  sum  +  1);	  double    diag[j]    =    Math.sqrt(solvedCols[i],    sum);    	non-compiled	[CE]  ']'  expected	64	None	replace
38	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(solvedCols[j],  sum);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(solvedCols[j],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(solvedCols[j],  sum);	  double    diag[j]    =    Math.sqrt(solvedCols[i],    sum);    	non-compiled	[CE]  ']'  expected	64	None	replace
39	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(permutation[i],  sum);  [CE]  ']'  expected  [FE]                            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(permutation[i],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(permutation[i],  sum);	  double    diag[j]    =    Math.sqrt(solvedCols[i],    sum);    	non-compiled	[CE]  ']'  expected	64	None	replace
40	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  -=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  -=  work3[pj];	  sum    /=    work3[pj];    if(work3[pj]    <    =    0)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	112	4	replace
41	[BUG]  [BUGGY]  sum  -=  work3[pj];  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  -=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  -=  work3[pj];	  sum    /=    work3[pj];    if(work3[pj]    <    =    0)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	112	4	replace
42	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[0],  sum  +  1);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[0],  sum  +  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols[0],  sum  +  1);	  double    diag[pj]    =    Math.sqrt(solvedCols[0],    sum);    	non-compiled	[CE]  ']'  expected	63	None	replace
43	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[1],  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[1],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols[1],  sum);	  double    diag[pj]    =    Math.sqrt(solvedCols[0],    sum);    	non-compiled	[CE]  ']'  expected	63	None	replace
44	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[0],  sum  +  2);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[0],  sum  +  2);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols[0],  sum  +  2);	  double    diag[pj]    =    Math.sqrt(solvedCols[0],    sum);    	non-compiled	[CE]  ']'  expected	63	None	replace
45	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  sum  /=  work1[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work1[pj];    sum  /=  work1[pj];	  	compilable	  [FE]  AssertionFailedError  	50	5	add
46	[BUG]  [BUGGY]  sum  /=  work1[pj];  sum  /=  work1[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  sum  /=  work1[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    sum  /=  work1[pj];	  	compilable	  [FE]  AssertionFailedError  	50	5	add
47	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  sum  /=  work2[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work1[pj];    sum  /=  work2[pj];	  	compilable	  [FE]  AssertionFailedError  	50	4	add
48	[BUG]  [BUGGY]  sum  /=  work1[pj];  sum  /=  work2[pj];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  sum  /=  work2[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    sum  /=  work2[pj];	  	compilable	  [FE]  AssertionFailedError  	50	4	add
49	[BUG]  [BUGGY]  sum  /=  work1[pj];  Sum  /=  work1[pj];  [CE]  cannot  find  symbol  Sum  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  Sum  /=  work1[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    Sum  /=  work1[pj];	  	non-compiled	[CE]  cannot  find  symbol  Sum	50	None	add
50	[BUG]  [BUGGY]  sum  /=  work1[pj];  double  /=  work1[pj];  [CE]  unexpected  type  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  double  /=  work1[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    double  /=  work1[pj];	  	non-compiled	[CE]  unexpected  type	50	None	add
51	[BUG]  [BUGGY]  sum  /=  work1[pj];  sum  /=  work1)[pj];  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  sum  /=  work1)[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    sum  /=  work1)[pj];	  	non-compiled	[CE]  ';'  expected	50	None	add
52	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(solvedCols[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(solvedCols[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(solvedCols[i]);	  double    diag[pj]    =    Math.sqrt(solvedCols[i]);    	non-compiled	[CE]  ']'  expected	8	None	replace
53	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols[i]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(solvedCols[i]);	  double    diag[pj]    =    Math.sqrt(solvedCols[i]);    	non-compiled	[CE]  ']'  expected	8	None	replace
54	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(sum2,  sum);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag  =  Math.sqrt(sum2,  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag  =  Math.sqrt(sum2,  sum);	  double    diag    =    Math.sqrt(sum,    sum2);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
55	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(sum,  sum  +  1);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag  =  Math.sqrt(sum,  sum  +  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag  =  Math.sqrt(sum,  sum  +  1);	  double    diag    =    Math.sqrt(sum,    sum2);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
56	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	  	compilable	  [FE]  AssertionFailedError  	12	3	add
57	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	  	compilable	  [FE]  AssertionFailedError  	12	3	add
58	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  >  expected  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  >  expected	12	None	add
59	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  For(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  '.class'  expected  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  For(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    For(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  '.class'  expected	12	None	add
60	[BUG]  [BUGGY]  For(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  '.class'  expected  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  For(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	For(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	          for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  '.class'  expected	71	None	replace
61	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solvesCols  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	          for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solvesCols	71	None	replace
62	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  int  cannot  be  dereferenced  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    diagR.length;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  int  cannot  be  dereferenced	90	None	replace
63	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solveCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solveCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solveCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    diagR.length;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	90	None	replace
64	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(sum  +  2);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(sum  +  2);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(sum  +  2);	  double    diag[pj]    =    Math.sqrt(sum    +    1);    	non-compiled	[CE]  ']'  expected	39	None	replace
65	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(sum  +  1);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(sum  +  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(sum  +  1);	  double    diag[pj]    =    Math.sqrt(sum    +    1);    	non-compiled	[CE]  ']'  expected	39	None	replace
66	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(sum  *  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(sum  *  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(sum  *  1);	  double    diag[pj]    =    Math.sqrt(sum    +    1);    	non-compiled	[CE]  ']'  expected	39	None	replace
67	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  diag[i][j]  =  Math.ceil(diag[i]);  sum  +=  diag[i]  *  qy[i];  }  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  diag[i][j]  =  Math.ceil(diag[i]);  sum  +=  diag[i]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  diag[i][j]  =  Math.ceil(diag[i]);  sum  +=  diag[i]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    int    diag[i][j]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	91	None	replace
68	[BUG]  [BUGGY]  int  diag[i][j]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  diag[i][j]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  diag[i][j]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    int    diag[i][j]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	91	None	replace
69	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sin(diag[i]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sin(diag[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sin(diag[i]);	  double    diag[pj]    =    Math.cos(diag[i]);    	non-compiled	[CE]  ']'  expected	117	None	replace
70	[BUG]  [BUGGY]  double  diag[0]  =  Math.cos(diag[i]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.cos(diag[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.cos(diag[i]);	  double    diag[pj]    =    Math.cos(diag[i]);    	non-compiled	[CE]  ']'  expected	117	None	replace
71	[BUG]  [BUGGY]  double  diag[pj]  =  Math.cos(diag[0]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.cos(diag[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.cos(diag[0]);	  double    diag[pj]    =    Math.cos(diag[i]);    	non-compiled	[CE]  ']'  expected	117	None	replace
72	[BUG]  [BUGGY]  int  permutation  =  Math.min(permutation,  0);  [CE]  variable  permutation  might  not  have  been  initialized  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  =  Math.min(permutation,  0);  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  =  Math.min(permutation,  0);	  sum    /=    permutation[j];    int    permutation    =    Math.min(permutation,    0);    	non-compiled	[CE]  variable  permutation  might  not  have  been  initialized	106	None	replace
73	[BUG]  [BUGGY]  int  permutation  =  Math.min(permutation[j],  0);  [CE]  array  required,  but  int  found  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  =  Math.min(permutation[j],  0);  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  =  Math.min(permutation[j],  0);	  sum    /=    permutation[j];    int    permutation    =    Math.min(permutation,    0);    	non-compiled	[CE]  array  required,  but  int  found	106	None	replace
74	[BUG]  [BUGGY]  sum  /=  permutation[j];  int  permutation  =  Math.min(permutation,  0,  0);  [CE]  no  suitable  method  found  for  min(int,int,int)  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  int  permutation  =  Math.min(permutation,  0,  0);  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j];  int  permutation  =  Math.min(permutation,  0,  0);	  sum    /=    permutation[j];    int    permutation    =    Math.min(permutation,    0);    	non-compiled	[CE]  no  suitable  method  found  for  min(int,int,int)	106	None	replace
75	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][pj],  sum  +  1);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][pj],  sum  +  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[i][pj],  sum  +  1);	  double    diag[pj]    =    Math.sqrt(diag[i][pj],    sum);    	non-compiled	[CE]  ']'  expected	77	None	replace
76	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(sub[i][pj],  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(sub[i][pj],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(sub[i][pj],  sum);	  double    diag[pj]    =    Math.sqrt(diag[i][pj],    sum);    	non-compiled	[CE]  ']'  expected	77	None	replace
77	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[i][pj],  sum);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[i][pj],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols[i][pj],  sum);	  double    diag[pj]    =    Math.sqrt(diag[i][pj],    sum);    	non-compiled	[CE]  ']'  expected	77	None	replace
78	[BUG]  [BUGGY]  sum  /=  permutation[j].doubleValue();  [CE]  int  cannot  be  dereferenced  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j].doubleValue();  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j].doubleValue();	  sum    /=    permutation[j];    sum    /=    permutation[j];    	non-compiled	[CE]  int  cannot  be  dereferenced	26	None	replace
79	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[i],  sum  +  2);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[i],  sum  +  2);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols[i],  sum  +  2);	  double    diag[pj]    =    Math.sqrt(solvedCols[i],    sum    +    1);    	non-compiled	[CE]  ']'  expected	62	None	replace
80	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[i],  sum  +  3);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[i],  sum  +  3);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols[i],  sum  +  3);	  double    diag[pj]    =    Math.sqrt(solvedCols[i],    sum    +    1);    	non-compiled	[CE]  ']'  expected	62	None	replace
81	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[i],  sum  *  1);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[i],  sum  *  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols[i],  sum  *  1);	  double    diag[pj]    =    Math.sqrt(solvedCols[i],    sum    +    1);    	non-compiled	[CE]  ']'  expected	62	None	replace
82	[BUG]  [BUGGY]  double  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    double    diag[i][pj]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	20	None	replace
83	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  =  Math.log(diag[i]);  sum  +=  diag[i]  *  qy[i];  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  =  Math.log(diag[i]);  sum  +=  diag[i]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  =  Math.log(diag[i]);  sum  +=  diag[i]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    double    diag[i][pj]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	20	None	replace
84	[BUG]  [BUGGY]  int  permutation  %=  permutation[j];  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  %=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  %=  permutation[j];	  sum    /=    permutation[j];    int    permutation    %=    permutation[j];    	non-compiled	[CE]  ';'  expected	113	None	replace
85	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  permutation.length;  ++j)  {  sum  /=  permutation[j];  int  permutation  %=  permutation[j];  }  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  j  =  0;  j  <  permutation.length;  ++j)  {  sum  /=  permutation[j];  int  permutation  %=  permutation[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  j  =  0;  j  <  permutation.length;  ++j)  {  sum  /=  permutation[j];  int  permutation  %=  permutation[j];  }	  sum    /=    permutation[j];    int    permutation    %=    permutation[j];    	non-compiled	[CE]  ';'  expected	113	None	replace
86	[BUG]  [BUGGY]  double  permutation  %=  permutation[j];  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  permutation  %=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  permutation  %=  permutation[j];	  sum    /=    permutation[j];    int    permutation    %=    permutation[j];    	non-compiled	[CE]  ';'  expected	113	None	replace
87	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  permutation[j];  ++j)  {  sum  /=  permutation[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  j  =  0;  j  <  permutation[j];  ++j)  {  sum  /=  permutation[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  j  =  0;  j  <  permutation[j];  ++j)  {  sum  /=  permutation[j];  }	  sum    /=    permutation[j];    int    permutation    %=    permutation[j];    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	113	None	replace
88	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols[i];  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  array  required,  but  int  found  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols[i];  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols[i];  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    diag[i];    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  array  required,  but  int  found	89	None	replace
89	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solveCols[i];  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solveCols[i];  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solveCols[i];  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    diag[i];    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	89	None	replace
90	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(diag[1]);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(diag[1]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(diag[1]);	  double    diag[0]    =    Math.sqrt(diag[0]);    	non-compiled	[CE]  ']'  expected	82	None	replace
91	[BUG]  [BUGGY]  double  diag[1]  =  Math.sqrt(diag[1]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[1]  =  Math.sqrt(diag[1]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[1]  =  Math.sqrt(diag[1]);	  double    diag[0]    =    Math.sqrt(diag[0]);    	non-compiled	[CE]  ']'  expected	82	None	replace
92	[BUG]  [BUGGY]  Sum  /=  permutation[j];  sum  /=  permutation[j];  [CE]  cannot  find  symbol  Sum  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Sum  /=  permutation[j];  sum  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Sum  /=  permutation[j];  sum  /=  permutation[j];	  sum    /=    permutation[j];    total    /=    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  Sum	29	None	replace
93	[BUG]  [BUGGY]  double  pj  =  permutation[pj];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  pj  =  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  pj  =  permutation[pj];	  sum    /=    permutation[pj];    if(pj    <    0)    {    sum    /=    permutation[pj];    }    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	120	None	replace
94	[BUG]  [BUGGY]  Sum  /=  permutation[j];  [CE]  cannot  find  symbol  Sum  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Sum  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Sum  /=  permutation[j];	  sum    /=    permutation[j];    Sum    /=    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  Sum	27	None	replace
95	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  sum  /=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    permutation[0];    sum  /=  permutation[0];	  	compilable	  [FE]  AssertionFailedError  	43	3	add
96	[BUG]  [BUGGY]  sum  /=  permutation[0];  sum  /=  permutation[0];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  sum  /=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    permutation[0];    sum  /=  permutation[0];	  	compilable	  [FE]  AssertionFailedError  	43	3	add
97	[BUG]  [BUGGY]  sum  /=  permutation[0];  Sum  /=  permutation[0];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  Sum  /=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    permutation[0];    Sum  /=  permutation[0];	  	non-compiled	[CE]  cannot  find  symbol  Sum	43	None	add
98	[BUG]  [BUGGY]  sum  /=  permutation[0];  double  /=  permutation[0];  [CE]  unexpected  type  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  double  /=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    permutation[0];    double  /=  permutation[0];	  	non-compiled	[CE]  unexpected  type	43	None	add
99	[BUG]  [BUGGY]  sum  /=  permutation[0];  total  /=  permutation[0];  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  total  /=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    permutation[0];    total  /=  permutation[0];	  	non-compiled	[CE]  cannot  find  symbol  total	43	None	add
100	[BUG]  [BUGGY]  sum  /=  permutation[0];  /=  permutation[0];  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  /=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    permutation[0];    /=  permutation[0];	  	non-compiled	[CE]  illegal  start  of  expression	43	None	add
101	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    sum  /=  work3[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
102	[BUG]  [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    sum  /=  work3[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
103	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work2[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    sum  /=  work2[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
104	[BUG]  [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work2[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work2[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    sum  /=  work2[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
105	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
106	[BUG]  [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
107	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
108	[BUG]  [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
109	[BUG]  [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [CE]  cannot  find  symbol  work  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    sum  /=  work[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  work	79	None	add
110	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(diag[pj]);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag  =  Math.sqrt(diag[pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag  =  Math.sqrt(diag[pj]);	  double    diag    =    Math.sqrt(diag);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	85	None	replace
111	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(diag[0]);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag  =  Math.sqrt(diag[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag  =  Math.sqrt(diag[0]);	  double    diag    =    Math.sqrt(diag);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	85	None	replace
112	[BUG]  [BUGGY]  int  permutation  /=  permutation[pj];  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  /=  permutation[pj];	  sum    /=    permutation[pj];    int    permutation    /=    permutation[pj];    	non-compiled	[CE]  ';'  expected	103	None	replace
113	[BUG]  [BUGGY]  double  permutation  /=  permutation[pj];  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  permutation  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  permutation  /=  permutation[pj];	  sum    /=    permutation[pj];    int    permutation    /=    permutation[pj];    	non-compiled	[CE]  ';'  expected	103	None	replace
114	[BUG]  [BUGGY]  int  permutation  /=  permutation[0];  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  /=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  /=  permutation[0];	  sum    /=    permutation[pj];    int    permutation    /=    permutation[pj];    	non-compiled	[CE]  ';'  expected	103	None	replace
115	[BUG]  [BUGGY]  int  permutation  /=  permutation[j];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  /=  permutation[j];	  sum    /=    permutation[pj];    int    permutation    /=    permutation[pj];    	non-compiled	[CE]  ';'  expected	103	None	replace
116	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	96	None	replace
117	[BUG]  [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  bucket  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  bucket	96	None	replace
118	[BUG]  [BUGGY]  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	96	None	replace
119	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  array  required,  but  int  found  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  array  required,  but  int  found	96	None	replace
120	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(solvedCols);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(solvedCols);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(solvedCols);	  double    diag[pj]    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  ']'  expected	100	None	replace
121	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(solvedCols);	  double    diag[pj]    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  ']'  expected	100	None	replace
122	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols,  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols,  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols,  sum);	  double    diag[pj]    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  ']'  expected	100	None	replace
123	[BUG]  [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  bucket  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  bucket	94	None	replace
124	[BUG]  [BUGGY]  while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	94	None	replace
125	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	94	None	replace
126	[BUG]  [BUGGY]  double  /=  work3[pj];  [CE]  unexpected  type  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  /=  work3[pj];	  sum    /=    work3[pj];    double    /=    work3[pj];    	non-compiled	[CE]  unexpected  type	35	None	replace
127	[BUG]  [BUGGY]  sum  /=  work1[pj];  double  /=  work3[pj];  [CE]  unexpected  type  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  double  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  double  /=  work3[pj];	  sum    /=    work3[pj];    double    /=    work3[pj];    	non-compiled	[CE]  unexpected  type	35	None	replace
128	[BUG]  [BUGGY]  sum  /=  work1[pj];  double  /=  work2[pj];  [CE]  unexpected  type  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  double  /=  work2[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  double  /=  work2[pj];	  sum    /=    work3[pj];    double    /=    work3[pj];    	non-compiled	[CE]  unexpected  type	35	None	replace
129	[BUG]  [BUGGY]  sum  /=  solvedCols[j  +  1];  [CE]  array  required,  but  int  found  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  solvedCols[j  +  1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  solvedCols[j  +  1];	  sum    /=    solvedCols[j];    	non-compiled	[CE]  array  required,  but  int  found	56	None	replace
130	[BUG]  [BUGGY]  sum  /=  solvedCols[j]  +  permutation[j];  [CE]  array  required,  but  int  found  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  solvedCols[j]  +  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  solvedCols[j]  +  permutation[j];	  sum    /=    solvedCols[j];    	non-compiled	[CE]  array  required,  but  int  found	56	None	replace
131	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  resolvedCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  resolvedCols  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  resolvedCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  resolvedCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    qy.length;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	115	None	replace
132	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	5	replace
133	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	5	replace
134	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	4	replace
135	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	4	replace
136	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	5	replace
137	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	5	replace
138	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	5	replace
139	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	5	replace
140	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(solvedCols[0]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(solvedCols[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(solvedCols[0]);	  double    diag[pj]    =    Math.log(solvedCols[pj]);    	non-compiled	[CE]  ']'  expected	9	None	replace
141	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(solvedCols[pj]  *  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(solvedCols[pj]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(solvedCols[pj]  *  sum);	  double    diag[pj]    =    Math.log(solvedCols[pj]);    	non-compiled	[CE]  ']'  expected	9	None	replace
142	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0]  *  sum,  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0]  *  sum,  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[0]  *  sum,  sum);	  double    diag[pj]    =    Math.sqrt(diag[0]    *    sum);    	non-compiled	[CE]  ']'  expected	73	None	replace
143	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[1]  *  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[1]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[1]  *  sum);	  double    diag[pj]    =    Math.sqrt(diag[0]    *    sum);    	non-compiled	[CE]  ']'  expected	73	None	replace
144	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0]  *  sum  +  1);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0]  *  sum  +  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[0]  *  sum  +  1);	  double    diag[pj]    =    Math.sqrt(diag[0]    *    sum);    	non-compiled	[CE]  ']'  expected	73	None	replace
145	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols[1]);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(solvedCols[1]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(solvedCols[1]);	  double    diag[0]    =    Math.sqrt(solvedCols[0]);    	non-compiled	[CE]  ']'  expected	10	None	replace
146	[BUG]  [BUGGY]  double  diag[1]  =  Math.sqrt(solvedCols[1]);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[1]  =  Math.sqrt(solvedCols[1]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[1]  =  Math.sqrt(solvedCols[1]);	  double    diag[0]    =    Math.sqrt(solvedCols[0]);    	non-compiled	[CE]  ']'  expected	10	None	replace
147	[BUG]  [BUGGY]  double  diag[]  =  Math.sqrt(solvedCols[0]);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.sqrt(solvedCols[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.sqrt(solvedCols[0]);	  double    diag[0]    =    Math.sqrt(solvedCols[0]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	replace
148	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(sum2)/  1;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(sum2)/  1;  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(sum2)/  1;	  double    diag[pj]    =    Math.sqrt(sum2)+    1;    	non-compiled	[CE]  ']'  expected	101	None	replace
149	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(sum2)+  2;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(sum2)+  2;  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(sum2)+  2;	  double    diag[pj]    =    Math.sqrt(sum2)+    1;    	non-compiled	[CE]  ']'  expected	101	None	replace
150	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  sum  /=  work3[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work3[0];    sum  /=  work3[0];	  	compilable	  [FE]  AssertionFailedError  	98	5	add
151	[BUG]  [BUGGY]  sum  /=  work3[0];  sum  /=  work3[0];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  sum  /=  work3[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    sum  /=  work3[0];	  	compilable	  [FE]  AssertionFailedError  	98	5	add
152	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  if(work3[0]  ==  0.0)  {  sum  /=  work3[0];  }  else  {  sum  /=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work3[0];    if(work3[0]  ==  0.0)  {  sum  /=  work3[0];  }  else  {  sum  /=  work3[0];  }	  	compilable	  [FE]  AssertionFailedError  	98	5	add
153	[BUG]  [BUGGY]  sum  /=  work3[0];  if(work3[0]  ==  0.0)  {  sum  /=  work3[0];  }  else  {  sum  /=  work3[0];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  if(work3[0]  ==  0.0)  {  sum  /=  work3[0];  }  else  {  sum  /=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    if(work3[0]  ==  0.0)  {  sum  /=  work3[0];  }  else  {  sum  /=  work3[0];  }	  	compilable	  [FE]  AssertionFailedError  	98	5	add
154	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  if(work3[0]  ==  0)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work3[0];    if(work3[0]  ==  0)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }	  	compilable	  [FE]  AssertionFailedError  	98	5	add
155	[BUG]  [BUGGY]  sum  /=  work3[0];  if(work3[0]  ==  0)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  if(work3[0]  ==  0)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    if(work3[0]  ==  0)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }	  	compilable	  [FE]  AssertionFailedError  	98	5	add
156	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  if(work3[0]  ==  0.0)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work3[0];    if(work3[0]  ==  0.0)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }	  	compilable	  [FE]  AssertionFailedError  	98	5	add
157	[BUG]  [BUGGY]  sum  /=  work3[0];  if(work3[0]  ==  0.0)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  if(work3[0]  ==  0.0)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    if(work3[0]  ==  0.0)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }	  	compilable	  [FE]  AssertionFailedError  	98	5	add
158	[BUG]  [BUGGY]  sum  /=  work3[0];  Sum  /=  work3[0];  [CE]  cannot  find  symbol  Sum  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  Sum  /=  work3[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    Sum  /=  work3[0];	  	non-compiled	[CE]  cannot  find  symbol  Sum	98	None	add
159	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  int  cannot  be  dereferenced  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  int  cannot  be  dereferenced	40	None	replace
160	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  resolvedCols.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  resolvedCols  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  resolvedCols.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  resolvedCols.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	40	None	replace
161	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[1]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[1]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols[1]);	  double    diag[pj]    =    Math.sqrt(solvedCols[0]);    	non-compiled	[CE]  ']'  expected	7	None	replace
162	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[0]  +  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols[0]  +  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols[0]  +  sum);	  double    diag[pj]    =    Math.sqrt(solvedCols[0]);    	non-compiled	[CE]  ']'  expected	7	None	replace
163	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	93	None	replace
164	[BUG]  [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  bucket  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  bucket	93	None	replace
165	[BUG]  [BUGGY]  while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	93	None	replace
166	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	93	None	replace
167	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  /=  permutation[pj];  sum  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        permutation[pj];        sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  /=  permutation[pj];	  	compilable	  [FE]  AssertionFailedError  	1	5	add
168	[BUG]  [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  /=  permutation[pj];  sum  /=  permutation[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  /=  permutation[pj];  sum  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  /=  permutation[pj];	  	compilable	  [FE]  AssertionFailedError  	1	5	add
169	[BUG]  [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  Sum  /=  permutation[pj];  sum  /=  permutation[pj];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  Sum  /=  permutation[pj];  sum  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        sum    /=    permutation[pj];    Sum  /=  permutation[pj];  sum  /=  permutation[pj];	  	non-compiled	[CE]  cannot  find  symbol  Sum	1	None	add
170	[BUG]  [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  /=  permutation[pj];  Sum  /=  permutation[pj];  [CE]  cannot  find  symbol  Sum  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  /=  permutation[pj];  Sum  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        sum    /=    permutation[pj];    sum  /=  permutation[pj];  Sum  /=  permutation[pj];	  	non-compiled	[CE]  cannot  find  symbol  Sum	1	None	add
171	[BUG]  [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  total  /=  permutation[pj];  sum  /=  permutation[pj];  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  total  /=  permutation[pj];  sum  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        sum    /=    permutation[pj];    total  /=  permutation[pj];  sum  /=  permutation[pj];	  	non-compiled	[CE]  cannot  find  symbol  total	1	None	add
172	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  /=  permutation[pj];  sum  %=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        permutation[pj];        sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  %=  permutation[pj];	  	compilable	  [FE]  AssertionFailedError  	1	15	add
173	[BUG]  [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  /=  permutation[pj];  sum  %=  permutation[pj];  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  /=  permutation[pj];  sum  %=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        sum    /=    permutation[pj];    sum  /=  permutation[pj];  sum  %=  permutation[pj];	  	compilable	  [FE]  AssertionFailedError  	1	15	add
174	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  int  cannot  be  dereferenced  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  int  cannot  be  dereferenced	41	None	replace
175	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  jacobian[i];  }  [CE]  array  required,  but  int  found  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  jacobian[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  jacobian[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  array  required,  but  int  found	41	None	replace
176	[BUG]  [BUGGY]  double  permutation  /=  permutation[j];  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  permutation  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  permutation  /=  permutation[j];	  sum    /=    permutation[j];    int    permutation    /=    permutation[j];    	non-compiled	[CE]  ';'  expected	105	None	replace
177	[BUG]  [BUGGY]  int  permutation  =  permutation[j];  [CE]  array  required,  but  int  found  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  =  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  =  permutation[j];	  sum    /=    permutation[j];    int    permutation    /=    permutation[j];    	non-compiled	[CE]  array  required,  but  int  found	105	None	replace
178	[BUG]  [BUGGY]  double  diag[]  =  Math.log(diag[i]);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.log(diag[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.log(diag[i]);	  double    diag[pj]    =    Math.log(diag[pj]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	60	None	replace
179	[BUG]  [BUGGY]  double  diag[]  =  Math.log(diag[0]);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.log(diag[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.log(diag[0]);	  double    diag[pj]    =    Math.log(diag[pj]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	60	None	replace
180	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  sum  /=  permutation[j];  sum  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        permutation[j];        sum    /=    permutation[j];    sum  /=  permutation[j];  sum  /=  permutation[j];	  	compilable	  [FE]  AssertionFailedError  	25	5	add
181	[BUG]  [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  sum  /=  permutation[j];  sum  /=  permutation[j];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  sum  /=  permutation[j];  sum  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[j];        sum    /=    permutation[j];    sum  /=  permutation[j];  sum  /=  permutation[j];	  	compilable	  [FE]  AssertionFailedError  	25	5	add
182	[BUG]  [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  Sum  /=  permutation[j];  sum  /=  permutation[j];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  Sum  /=  permutation[j];  sum  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[j];        sum    /=    permutation[j];    Sum  /=  permutation[j];  sum  /=  permutation[j];	  	non-compiled	[CE]  cannot  find  symbol  Sum	25	None	add
183	[BUG]  [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  sum  /=  permutation[j];  Sum  /=  permutation[j];  [CE]  cannot  find  symbol  Sum  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  sum  /=  permutation[j];  Sum  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[j];        sum    /=    permutation[j];    sum  /=  permutation[j];  Sum  /=  permutation[j];	  	non-compiled	[CE]  cannot  find  symbol  Sum	25	None	add
184	[BUG]  [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  total  /=  permutation[j];  sum  /=  permutation[j];  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  total  /=  permutation[j];  sum  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[j];        sum    /=    permutation[j];    total  /=  permutation[j];  sum  /=  permutation[j];	  	non-compiled	[CE]  cannot  find  symbol  total	25	None	add
185	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  sum  /=  permutation[j];  sum  %=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        permutation[j];        sum    /=    permutation[j];    sum  /=  permutation[j];  sum  %=  permutation[j];	  	compilable	  [FE]  AssertionFailedError  	25	15	add
186	[BUG]  [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  sum  /=  permutation[j];  sum  %=  permutation[j];  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  sum  /=  permutation[j];  sum  %=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[j];        sum    /=    permutation[j];    sum  /=  permutation[j];  sum  %=  permutation[j];	  	compilable	  [FE]  AssertionFailedError  	25	15	add
187	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[1][pj]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[1][pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[1][pj]);	  double    diag[pj]    =    Math.sqrt(diag[0][pj]);    	non-compiled	[CE]  ']'  expected	75	None	replace
188	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0][pj]  *  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0][pj]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[0][pj]  *  sum);	  double    diag[pj]    =    Math.sqrt(diag[0][pj]);    	non-compiled	[CE]  ']'  expected	75	None	replace
189	[BUG]  [BUGGY]  int  diag[i][j]  *  qy[i];  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  diag[i][j]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  diag[i][j]  *  qy[i];	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    int    diag[i][j]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	31	None	replace
190	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][j]  *  qy[i];  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][j]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][j]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    int    diag[i][j]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	31	None	replace
191	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	111	5	replace
192	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	111	5	replace
193	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[1]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[1]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[1]);	  double    diag[pj]    =    Math.sqrt(diag[1]);    	non-compiled	[CE]  ']'  expected	72	None	replace
194	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	110	5	add
195	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	110	5	add
196	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	110	None	add
197	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	110	4	add
198	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	110	4	add
199	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	110	4	add
200	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	110	4	add
201	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  if(work3  ==  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    sum  /=  work3[pj];  if(work3  ==  null)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	110	5	add
202	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  if(work3  ==  null)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  if(work3  ==  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    sum  /=  work3[pj];  if(work3  ==  null)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	110	5	add
203	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][1]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][1]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[i][1]);	  double    diag[pj]    =    Math.sqrt(diag[i][0]);    	non-compiled	[CE]  ']'  expected	69	None	replace
204	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][0]  +  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][0]  +  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[i][0]  +  sum);	  double    diag[pj]    =    Math.sqrt(diag[i][0]);    	non-compiled	[CE]  ']'  expected	69	None	replace
205	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][0],  sum);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][0],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[i][0],  sum);	  double    diag[pj]    =    Math.sqrt(diag[i][0]);    	non-compiled	[CE]  ']'  expected	69	None	replace
206	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][0]  *  sum);  [CE]  ']'  expected  [FE]                            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][0]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[i][0]  *  sum);	  double    diag[pj]    =    Math.sqrt(diag[i][0]);    	non-compiled	[CE]  ']'  expected	69	None	replace
207	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  permutation[1];	  sum    /=    permutation[0];    	compilable	  [FE]  AssertionFailedError  	44	4	replace
208	[BUG]  [BUGGY]  sum  /=  permutation[1];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[1];	  sum    /=    permutation[0];    	compilable	  [FE]  AssertionFailedError  	44	4	replace
209	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0]  +  1;  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  permutation[0]  +  1;	  sum    /=    permutation[0];    	compilable	  [FE]  AssertionFailedError  	44	4	replace
210	[BUG]  [BUGGY]  sum  /=  permutation[0]  +  1;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0]  +  1;  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[0]  +  1;	  sum    /=    permutation[0];    	compilable	  [FE]  AssertionFailedError  	44	4	replace
211	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0]  +  2;  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  permutation[0]  +  2;	  sum    /=    permutation[0];    	compilable	  [FE]  AssertionFailedError  	44	4	replace
212	[BUG]  [BUGGY]  sum  /=  permutation[0]  +  2;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0]  +  2;  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[0]  +  2;	  sum    /=    permutation[0];    	compilable	  [FE]  AssertionFailedError  	44	4	replace
213	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvesCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solvesCols  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvesCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvesCols.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    diag.length;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solvesCols	88	None	replace
214	[BUG]  [BUGGY]  double  diag[j]  =  Math.log(diag[i][pj]);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.log(diag[i][pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.log(diag[i][pj]);	  double    diag[j]    =    Math.sqrt(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	70	None	replace
215	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(diag[i][0]);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(diag[i][0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(diag[i][0]);	  double    diag[j]    =    Math.sqrt(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	70	None	replace
216	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(diag[i][pj]  *  sum);  [CE]  ']'  expected  [FE]                            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(diag[i][pj]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(diag[i][pj]  *  sum);	  double    diag[j]    =    Math.sqrt(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	70	None	replace
217	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(diag[i][pj],  sum);  [CE]  ']'  expected  [FE]                              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(diag[i][pj],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(diag[i][pj],  sum);	  double    diag[j]    =    Math.sqrt(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	70	None	replace
218	[BUG]  [BUGGY]  sum  /=  work1[pj];  sum  /=  work3)[pj];  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  sum  /=  work3)[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  sum  /=  work3)[pj];	  sum    /=    work3[pj];    sum    /=    work3)[pj];    	non-compiled	[CE]  ';'  expected	37	None	replace
219	[BUG]  [BUGGY]  double  /=  permutation[j];  [CE]  unexpected  type  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  /=  permutation[j];	  sum    /=    permutation[j];    double    /=    permutation[j];    	non-compiled	[CE]  unexpected  type	28	None	replace
220	[BUG]  [BUGGY]  /=  permutation[j];  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	/=  permutation[j];	  sum    /=    permutation[j];    double    /=    permutation[j];    	non-compiled	[CE]  illegal  start  of  expression	28	None	replace
221	[BUG]  [BUGGY]  total  /=  permutation[j];  [CE]  cannot  find  symbol  total  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  total  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	total  /=  permutation[j];	  sum    /=    permutation[j];    double    /=    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  total	28	None	replace
222	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[0];	  sum    /=    work3[0];    	compilable	  [FE]  AssertionFailedError  	99	5	replace
223	[BUG]  [BUGGY]  sum  /=  work1[0];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[0];	  sum    /=    work3[0];    	compilable	  [FE]  AssertionFailedError  	99	5	replace
224	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work2[0];	  sum    /=    work3[0];    	compilable	  [FE]  AssertionFailedError  	99	6	replace
225	[BUG]  [BUGGY]  sum  /=  work2[0];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work2[0];	  sum    /=    work3[0];    	compilable	  [FE]  AssertionFailedError  	99	6	replace
226	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work3[1];	  sum    /=    work3[0];    	compilable	  [FE]  AssertionFailedError  	99	5	replace
227	[BUG]  [BUGGY]  sum  /=  work3[1];  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work3[1];	  sum    /=    work3[0];    	compilable	  [FE]  AssertionFailedError  	99	5	replace
228	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solves.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solves  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solves.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solves.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solves	42	None	replace
229	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solver.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solver  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solver.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solver.length;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solver	42	None	replace
230	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(sum,  scope);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag  =  Math.sqrt(sum,  scope);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag  =  Math.sqrt(sum,  scope);	  double    diag    =    Math.sqrt(diag,    sum);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	86	None	replace
231	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i],  sum  +  1);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i],  sum  +  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[i],  sum  +  1);	  double    diag[pj]    =    Math.sqrt(diag[i],    sum);    	non-compiled	[CE]  ']'  expected	78	None	replace
232	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(sum,  diag[i]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(sum,  diag[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(sum,  diag[i]);	  double    diag[pj]    =    Math.sqrt(diag[i],    sum);    	non-compiled	[CE]  ']'  expected	78	None	replace
233	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0],  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[0],  sum);	  double    diag[pj]    =    Math.sqrt(diag[i],    sum);    	non-compiled	[CE]  ']'  expected	78	None	replace
234	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i][pj]  *  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i][pj]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i][pj]  *  sum);	  double    diag[pj]    =    Math.log(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	67	None	replace
235	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i][0]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i][0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i][0]);	  double    diag[pj]    =    Math.log(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	67	None	replace
236	[BUG]  [BUGGY]  double  diag[0]  =  Math.log(diag[i][pj]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.log(diag[i][pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.log(diag[i][pj]);	  double    diag[pj]    =    Math.log(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	67	None	replace
237	[BUG]  [BUGGY]  double  diag[]  =  Math.log(diag[i][0]);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.log(diag[i][0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.log(diag[i][0]);	  double    diag[pj]    =    Math.log(diag[i][pj]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	67	None	replace
238	[BUG]  [BUGGY]  int  permutation  %=  permutation[pj];  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  %=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  %=  permutation[pj];	  sum    /=    permutation[pj];    int    permutation    %=    permutation[pj];    	non-compiled	[CE]  ';'  expected	104	None	replace
239	[BUG]  [BUGGY]  int  permutation  %=  permutation[0];  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  %=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  %=  permutation[0];	  sum    /=    permutation[pj];    int    permutation    %=    permutation[pj];    	non-compiled	[CE]  ';'  expected	104	None	replace
240	[BUG]  [BUGGY]  double  permutation  %=  permutation[pj];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  permutation  %=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  permutation  %=  permutation[pj];	  sum    /=    permutation[pj];    int    permutation    %=    permutation[pj];    	non-compiled	[CE]  ';'  expected	104	None	replace
241	[BUG]  [BUGGY]  Sum  /=  permutation[j];  sum  /=  permutation[i];  [CE]  cannot  find  symbol  Sum  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Sum  /=  permutation[j];  sum  /=  permutation[i];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Sum  /=  permutation[j];  sum  /=  permutation[i];	  sum    /=    permutation[j];    sum    /=    permutation[je];    	non-compiled	[CE]  cannot  find  symbol  Sum	30	None	replace
242	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  sum  /=  diag[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    diag[j];    sum  /=  diag[j];	  	compilable	  [FE]  AssertionFailedError  	47	3	add
243	[BUG]  [BUGGY]  sum  /=  diag[j];  sum  /=  diag[j];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  sum  /=  diag[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    sum  /=  diag[j];	  	compilable	  [FE]  AssertionFailedError  	47	3	add
244	[BUG]  [BUGGY]  sum  /=  diag[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  /=  diag[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  /=  diag[j];  }	  	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	47	None	add
245	[BUG]  [BUGGY]  sum  /=  diag[j];  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  sum  /=  diag[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    for(int  j  =  0;  j  <  solvedCols;  ++i)  {  sum  /=  diag[j];  }	  	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	47	None	add
246	[BUG]  [BUGGY]  sum  /=  diag[j];  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  /=  diag[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  /=  diag[j];  }	  	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	47	None	add
247	[BUG]  [BUGGY]  sum  /=  diag[j];  for(int  j  =  0;  j  <  solveCols;  ++i)  {  sum  /=  diag[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  for(int  j  =  0;  j  <  solveCols;  ++i)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    for(int  j  =  0;  j  <  solveCols;  ++i)  {  sum  /=  diag[j];  }	  	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	47	None	add
248	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(diag[1][pj]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(diag[1][pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(diag[1][pj]);	  double    diag[0]    =    Math.sqrt(diag[0][pj]);    	non-compiled	[CE]  ']'  expected	76	None	replace
249	[BUG]  [BUGGY]  double  diag[1]  =  Math.sqrt(diag[1][pj]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[1]  =  Math.sqrt(diag[1][pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[1]  =  Math.sqrt(diag[1][pj]);	  double    diag[0]    =    Math.sqrt(diag[0][pj]);    	non-compiled	[CE]  ']'  expected	76	None	replace
250	[BUG]  [BUGGY]  double  diag[]  =  Math.sqrt(diag[0][pj]);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.sqrt(diag[0][pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.sqrt(diag[0][pj]);	  double    diag[0]    =    Math.sqrt(diag[0][pj]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	76	None	replace
251	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(diag[0][j]);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(diag[0][j]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(diag[0][j]);	  double    diag[0]    =    Math.sqrt(diag[0][pj]);    	non-compiled	[CE]  ']'  expected	76	None	replace
252	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	80	5	replace
253	[BUG]  [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	80	5	replace
254	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work2[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	80	4	replace
255	[BUG]  [BUGGY]  sum  /=  work2[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work2[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	80	4	replace
256	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	80	5	replace
257	[BUG]  [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	80	5	replace
258	[BUG]  [BUGGY]  sum  /=  work[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work[pj];  }  [CE]  cannot  find  symbol  work  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    	non-compiled	[CE]  cannot  find  symbol  work	80	None	replace
259	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(sum,  sum)+  1;  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag  =  Math.sqrt(sum,  sum)+  1;  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag  =  Math.sqrt(sum,  sum)+  1;	  double    diag    =    Math.sqrt(sum,    sum);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	14	None	replace
260	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  =  Math.ceil(diag[i]);  sum  +=  diag[i]  *  qy[i];  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  =  Math.ceil(diag[i]);  sum  +=  diag[i]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  =  Math.ceil(diag[i]);  sum  +=  diag[i]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    int    diag[i][pj]    =    Math.ceil(diag[i]);    sum    +=    diag[i]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	21	None	replace
261	[BUG]  [BUGGY]  Sum  /=  permutation[pj];  [CE]  cannot  find  symbol  Sum  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Sum  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Sum  /=  permutation[pj];	  sum    /=    permutation[pj];    Sum    /=    permutation[pj];    	non-compiled	[CE]  cannot  find  symbol  Sum	3	None	replace
262	[BUG]  [BUGGY]  sum  /=  permutation[i];  Sum  /=  permutation[i];  [CE]  cannot  find  symbol  i  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[i];  Sum  /=  permutation[i];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[i];  Sum  /=  permutation[i];	  sum    /=    permutation[pj];    Sum    /=    permutation[pj];    	non-compiled	[CE]  cannot  find  symbol  i	3	None	replace
263	[BUG]  [BUGGY]  double  diag[0]  =  Math.ceil(diag[i]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.ceil(diag[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.ceil(diag[i]);	  double    diag[pj]    =    Math.ceil(diag[i]);    	non-compiled	[CE]  ']'  expected	118	None	replace
264	[BUG]  [BUGGY]  double  diag[pj]  =  Math.ceil(diag[0]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.ceil(diag[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.ceil(diag[0]);	  double    diag[pj]    =    Math.ceil(diag[i]);    	non-compiled	[CE]  ']'  expected	118	None	replace
265	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[0];  sum  /=  diag[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    diag[0];    sum  /=  diag[0];	  	compilable	  [FE]  AssertionFailedError  	83	4	add
266	[BUG]  [BUGGY]  sum  /=  diag[0];  sum  /=  diag[0];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[0];  sum  /=  diag[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[0];    sum  /=  diag[0];	  	compilable	  [FE]  AssertionFailedError  	83	4	add
267	[BUG]  [BUGGY]  sum  /=  diag[0];  Sum  /=  diag[0];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[0];  Sum  /=  diag[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[0];    Sum  /=  diag[0];	  	non-compiled	[CE]  cannot  find  symbol  Sum	83	None	add
268	[BUG]  [BUGGY]  sum  /=  diag[0];  double  /=  diag[0];  [CE]  unexpected  type  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[0];  double  /=  diag[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[0];    double  /=  diag[0];	  	non-compiled	[CE]  unexpected  type	83	None	add
269	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[0];  sum  /=  diag[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    diag[0];    sum  /=  diag[1];	  	compilable	  [FE]  AssertionFailedError  	83	4	add
270	[BUG]  [BUGGY]  sum  /=  diag[0];  sum  /=  diag[1];  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[0];  sum  /=  diag[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[0];    sum  /=  diag[1];	  	compilable	  [FE]  AssertionFailedError  	83	4	add
271	[BUG]  [BUGGY]  sum  /=  diag[0];  /=  diag[0];  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[0];  /=  diag[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[0];    /=  diag[0];	  	non-compiled	[CE]  illegal  start  of  expression	83	None	add
272	[BUG]  [BUGGY]  sum  /=  work1[i];  [CE]  cannot  find  symbol  i  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[i];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[i];	  sum    /=    work[i];    	non-compiled	[CE]  cannot  find  symbol  i	46	None	replace
273	[BUG]  [BUGGY]  sum  /=  work3;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3;  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work3;	  sum    /=    work[i];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	46	None	replace
274	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  *  qy[i];  }  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    double    diag[i][pj]    *    qy[i];    	non-compiled	[CE]  ']'  expected	23	None	replace
275	[BUG]  [BUGGY]  double  /=  permutation[pj];  [CE]  unexpected  type  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  /=  permutation[pj];	  sum    /=    permutation[pj];    double    /=    permutation[pj];    	non-compiled	[CE]  unexpected  type	4	None	replace
276	[BUG]  [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  bucket  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  bucket	95	None	replace
277	[BUG]  [BUGGY]  while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	95	None	replace
278	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[0]  *  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[0]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[0]  *  sum);	  double    diag[pj]    =    Math.log(diag[0]);    	non-compiled	[CE]  ']'  expected	59	None	replace
279	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[0]  +  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[0]  +  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[0]  +  sum);	  double    diag[pj]    =    Math.log(diag[0]);    	non-compiled	[CE]  ']'  expected	59	None	replace
280	[BUG]  [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work3[pj];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    /=    work3[pj];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	81	None	replace
281	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	81	5	replace
282	[BUG]  [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	81	5	replace
283	[BUG]  [BUGGY]  sum  /=  work2[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work3[pj];  }  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work2[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    /=    work3[pj];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	81	None	replace
284	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solved  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    j    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solved	123	None	replace
285	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    j    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	123	None	replace
286	[BUG]  [BUGGY]  double  diag[]  =  Math.sqrt(diag[i]);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.sqrt(diag[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.sqrt(diag[i]);	  double    diag[0]    =    Math.sqrt(diag[i]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	66	None	replace
287	[BUG]  [BUGGY]  double  diag[0]  =  Math.log(diag[i]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.log(diag[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.log(diag[i]);	  double    diag[0]    =    Math.sqrt(diag[i]);    	non-compiled	[CE]  ']'  expected	66	None	replace
288	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solved  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solved	121	None	replace
289	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	121	None	replace
290	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveable  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveable	121	None	replace
291	[BUG]  [BUGGY]  int  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];	  Integer    diag[i][pj]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    	non-compiled	[CE]  ']'  expected	92	None	replace
292	[BUG]  [BUGGY]  Integer  diag[i][pj]  =  Math.floor(diag[i]  *  work1[i]);  sum  +=  diag[i]  *  qy[i];  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Integer  diag[i][pj]  =  Math.floor(diag[i]  *  work1[i]);  sum  +=  diag[i]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Integer  diag[i][pj]  =  Math.floor(diag[i]  *  work1[i]);  sum  +=  diag[i]  *  qy[i];	  Integer    diag[i][pj]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    	non-compiled	[CE]  ']'  expected	92	None	replace
293	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[j];  sum  /=  work3[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work3[j];    sum  /=  work3[j];	  	compilable	  [FE]  AssertionFailedError  	54	4	add
294	[BUG]  [BUGGY]  sum  /=  work3[j];  sum  /=  work3[j];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[j];  sum  /=  work3[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[j];    sum  /=  work3[j];	  	compilable	  [FE]  AssertionFailedError  	54	4	add
295	[BUG]  [BUGGY]  sum  /=  work3[j];  Sum  /=  work3[j];  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[j];  Sum  /=  work3[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[j];    Sum  /=  work3[j];	  	non-compiled	[CE]  cannot  find  symbol  Sum	54	None	add
296	[BUG]  [BUGGY]  sum  /=  work3[j];  double  /=  work3[j];  [CE]  unexpected  type  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[j];  double  /=  work3[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[j];    double  /=  work3[j];	  	non-compiled	[CE]  unexpected  type	54	None	add
297	[BUG]  [BUGGY]  sum  /=  work3[j];  total  /=  work3[j];  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[j];  total  /=  work3[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[j];    total  /=  work3[j];	  	non-compiled	[CE]  cannot  find  symbol  total	54	None	add
298	[BUG]  [BUGGY]  sum  /=  work3[j];  sum  /=  work3)[j];  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[j];  sum  /=  work3)[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[j];    sum  /=  work3)[j];	  	non-compiled	[CE]  ';'  expected	54	None	add
299	[BUG]  [BUGGY]  double  diag[]  =  Math.sqrt(diag[0]  *  sum);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.sqrt(diag[0]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.sqrt(diag[0]  *  sum);	  double    diag[]    =    Math.sqrt(diag[0]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	61	None	replace
300	[BUG]  [BUGGY]  double  diag[]  =  Math.sqrt(diag[0],  sum);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.sqrt(diag[0],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.sqrt(diag[0],  sum);	  double    diag[]    =    Math.sqrt(diag[0]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	61	None	replace
301	[BUG]  [BUGGY]  double  diag[]  =  Math.sqrt(diag[1]);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.sqrt(diag[1]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.sqrt(diag[1]);	  double    diag[]    =    Math.sqrt(diag[0]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	61	None	replace
302	[BUG]  [BUGGY]  double  diag[]  =  Math.sqrt(sum);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.sqrt(sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.sqrt(sum);	  double    diag[]    =    Math.sqrt(diag[0]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	61	None	replace
303	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  resolvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  resolvedCols  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  resolvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  resolvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	13	None	replace
304	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  sum  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  permutation[j];  sum  /=  permutation[pj];	  sum    /=    permutation[pj];    total    /=    permutation[pj];    	compilable	  [FE]  AssertionFailedError  	5	5	replace
305	[BUG]  [BUGGY]  sum  /=  permutation[j];  sum  /=  permutation[pj];  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  sum  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j];  sum  /=  permutation[pj];	  sum    /=    permutation[pj];    total    /=    permutation[pj];    	compilable	  [FE]  AssertionFailedError  	5	5	replace
306	[BUG]  [BUGGY]  sum  /=  permutation[i];  sum  /=  permutation[pj];  [CE]  cannot  find  symbol  i  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[i];  sum  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[i];  sum  /=  permutation[pj];	  sum    /=    permutation[pj];    total    /=    permutation[pj];    	non-compiled	[CE]  cannot  find  symbol  i	5	None	replace
307	[BUG]  [BUGGY]  Sum  /=  work3[pj];  [CE]  cannot  find  symbol  Sum  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Sum  /=  work3[pj];	  sum    /=    work3[pj];    Sum    /=    work3[pj];    	non-compiled	[CE]  cannot  find  symbol  Sum	34	None	replace
308	[BUG]  [BUGGY]  sum  /=  work1[pj];  Sum  /=  work3[pj];  [CE]  cannot  find  symbol  Sum  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  Sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  Sum  /=  work3[pj];	  sum    /=    work3[pj];    Sum    /=    work3[pj];    	non-compiled	[CE]  cannot  find  symbol  Sum	34	None	replace
309	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(permutation[j]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(permutation[j]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(permutation[j]);	  double    diag[j]    =    Math.sqrt(solvedCols[j]);    	non-compiled	[CE]  ']'  expected	107	None	replace
310	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(diag[j]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(diag[j]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(diag[j]);	  double    diag[j]    =    Math.sqrt(solvedCols[j]);    	non-compiled	[CE]  ']'  expected	107	None	replace
311	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(solvedCols[i]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(solvedCols[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(solvedCols[i]);	  double    diag[j]    =    Math.sqrt(solvedCols[j]);    	non-compiled	[CE]  ']'  expected	107	None	replace
312	[BUG]  [BUGGY]  double  diag[j]  =  Math.log(solvedCols[j]);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.log(solvedCols[j]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.log(solvedCols[j]);	  double    diag[j]    =    Math.sqrt(solvedCols[j]);    	non-compiled	[CE]  ']'  expected	107	None	replace
313	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[1]  +  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[1]  +  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[1]  +  sum);	  double    diag[pj]    =    Math.sqrt(diag[0]    +    sum);    	non-compiled	[CE]  ']'  expected	74	None	replace
314	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0]  +  sum,  sum);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0]  +  sum,  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[0]  +  sum,  sum);	  double    diag[pj]    =    Math.sqrt(diag[0]    +    sum);    	non-compiled	[CE]  ']'  expected	74	None	replace
315	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(sum  +  diag[0]);  [CE]  ']'  expected  [FE]                            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(sum  +  diag[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(sum  +  diag[0]);	  double    diag[pj]    =    Math.sqrt(diag[0]    +    sum);    	non-compiled	[CE]  ']'  expected	74	None	replace
316	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][j]  *  qy[i];  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][j]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][j]  *  qy[i];	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    int    diag[i][j]    *    qy[i];    	non-compiled	[CE]  ']'  expected	24	None	replace
317	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  diag[i][j]  =  permutation[i];  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  diag[i][j]  =  permutation[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  diag[i][j]  =  permutation[i];	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    int    diag[i][j]    *    qy[i];    	non-compiled	[CE]  ']'  expected	24	None	replace
318	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i]  *  sum  +  1);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i]  *  sum  +  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i]  *  sum  +  1);	  double    diag[pj]    =    Math.log(diag[i]    *    sum);    	non-compiled	[CE]  ']'  expected	57	None	replace
319	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i]  *  sum,  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i]  *  sum,  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i]  *  sum,  sum);	  double    diag[pj]    =    Math.log(diag[i]    *    sum);    	non-compiled	[CE]  ']'  expected	57	None	replace
320	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i]  *  sum  +  2);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i]  *  sum  +  2);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i]  *  sum  +  2);	  double    diag[pj]    =    Math.log(diag[i]    *    sum);    	non-compiled	[CE]  ']'  expected	57	None	replace
321	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag);	  double    diag[pj]    =    Math.sqrt(diag);    	non-compiled	[CE]  ']'  expected	87	None	replace
322	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(diag);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(diag);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(diag);	  double    diag[pj]    =    Math.sqrt(diag);    	non-compiled	[CE]  ']'  expected	87	None	replace
323	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work3[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work3[pj];	  	compilable	  [FE]  AssertionFailedError  	32	5	add
324	[BUG]  [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work3[pj];  sum  /=  work3[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work3[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work3[pj];	  	compilable	  [FE]  AssertionFailedError  	32	5	add
325	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work2[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        sum    /=    work3[pj];    sum  /=  work2[pj];  sum  /=  work3[pj];	  	compilable	  [FE]  AssertionFailedError  	32	4	add
326	[BUG]  [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work2[pj];  sum  /=  work3[pj];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work2[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        sum    /=    work3[pj];    sum  /=  work2[pj];  sum  /=  work3[pj];	  	compilable	  [FE]  AssertionFailedError  	32	4	add
327	[BUG]  [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work3,[pj];  sum  /=  work3[pj];  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work3,[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        sum    /=    work3[pj];    sum  /=  work3,[pj];  sum  /=  work3[pj];	  	non-compiled	[CE]  ';'  expected	32	None	add
328	[BUG]  [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  Sum  /=  work3[pj];  sum  /=  work3[pj];  [CE]  cannot  find  symbol  Sum  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  Sum  /=  work3[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        sum    /=    work3[pj];    Sum  /=  work3[pj];  sum  /=  work3[pj];	  	non-compiled	[CE]  cannot  find  symbol  Sum	32	None	add
329	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work1[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        sum    /=    work3[pj];    sum  /=  work1[pj];  sum  /=  work3[pj];	  	compilable	  [FE]  AssertionFailedError  	32	4	add
330	[BUG]  [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work1[pj];  sum  /=  work3[pj];  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work1[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        sum    /=    work3[pj];    sum  /=  work1[pj];  sum  /=  work3[pj];	  	compilable	  [FE]  AssertionFailedError  	32	4	add
331	[BUG]  [BUGGY]  double  diag[j]  =  Math.log(diag[i]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.log(diag[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.log(diag[i]);	  double    diag[j]    =    Math.sqrt(diag[i]);    	non-compiled	[CE]  ']'  expected	114	None	replace
332	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(diag[0]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(diag[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(diag[0]);	  double    diag[j]    =    Math.sqrt(diag[i]);    	non-compiled	[CE]  ']'  expected	114	None	replace
333	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }	  	compilable	  [FE]  AssertionFailedError  	119	5	add
334	[BUG]  [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }	  	compilable	  [FE]  AssertionFailedError  	119	5	add
335	[BUG]  [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  if(pj  <  0)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  if(pj  <  0)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    if(pj  <  0)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	119	None	add
336	[BUG]  [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  double  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  double  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    double  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }	  	non-compiled	[CE]  ']'  expected	119	None	add
337	[BUG]  [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	119	None	add
338	[BUG]  [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	119	None	add
339	[BUG]  [BUGGY]  sum  /=  permutation[j];  /=  permutation[j];  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j];  /=  permutation[j];	  sum    /=    permutation[pj];    /=    permutation[pj];    	non-compiled	[CE]  illegal  start  of  expression	6	None	replace
340	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][j]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	97	None	replace
341	[BUG]  [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [CE]  cannot  find  symbol  bucket  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	bucket  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][j]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  bucket	97	None	replace
342	[BUG]  [BUGGY]  while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	while(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][j]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	97	None	replace
343	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][j]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	97	None	replace
344	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(diag[i][j]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(diag[i][j]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(diag[i][j]);	  double    diag[0]    =    Math.sqrt(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	68	None	replace
345	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(diag[i][1]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(diag[i][1]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(diag[i][1]);	  double    diag[0]    =    Math.sqrt(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	68	None	replace
346	[BUG]  [BUGGY]  sum  /=  work4[pj];  [CE]  cannot  find  symbol  work4  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work4[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work4[pj];	  sum    /=    work1[pj];    	non-compiled	[CE]  cannot  find  symbol  work4	51	None	replace
347	[BUG]  [BUGGY]  sum  /=  diagnostic[j];  [CE]  cannot  find  symbol  diagnostic  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diagnostic[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  diagnostic[j];	  sum    /=    diag[j];    	non-compiled	[CE]  cannot  find  symbol  diagnostic	48	None	replace
348	[BUG]  [BUGGY]  double  diag[pj]  =  Math.rint(sum);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.rint(sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.rint(sum);	  double    diag[pj]    =    Math.log(sum);    	non-compiled	[CE]  ']'  expected	38	None	replace
349	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i],  sum  +  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i],  sum  +  1);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i],  sum  +  1);	  double    diag[pj]    =    Math.log(diag[i],    sum);    	non-compiled	[CE]  ']'  expected	58	None	replace
350	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[0],  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[0],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[0],  sum);	  double    diag[pj]    =    Math.log(diag[i],    sum);    	non-compiled	[CE]  ']'  expected	58	None	replace
351	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i],  sum  +  2);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i],  sum  +  2);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i],  sum  +  2);	  double    diag[pj]    =    Math.log(diag[i],    sum);    	non-compiled	[CE]  ']'  expected	58	None	replace
352	[BUG]  [BUGGY]  double  diag[1]  =  Math.sqrt(diag[i]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[1]  =  Math.sqrt(diag[i]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[1]  =  Math.sqrt(diag[i]);	  double    diag[0]    =    Math.sqrt(diag[i]);    	non-compiled	[CE]  ']'  expected	66	None	replace
353	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i]  /  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i]  /  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i]  /  sum);	  double    diag[pj]    =    Math.log(diag[i]    *    sum);    	non-compiled	[CE]  ']'  expected	57	None	replace
354	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i]  *  qy);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i]  *  qy);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i]  *  qy);	  double    diag[pj]    =    Math.log(diag[i]    *    sum);    	non-compiled	[CE]  ']'  expected	57	None	replace
355	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work2[pj]  <  =  0)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work2[pj]  <  =  0)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  if(work2[pj]  <  =  0)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3[pj]    <    =    0)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	112	None	replace
356	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work2[pj]  <  =  0)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work2[pj]  <  =  0)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  if(work2[pj]  <  =  0)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3[pj]    <    =    0)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	non-compiled	[CE]  illegal  start  of  expression	112	None	replace
357	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work2[pj];  sum  /=  work3[pj];	  sum    /=    work3[pj];    total    /=    work3[pj];    	compilable	  [FE]  AssertionFailedError  	36	4	replace
358	[BUG]  [BUGGY]  sum  /=  work2[pj];  sum  /=  work3[pj];  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work2[pj];  sum  /=  work3[pj];	  sum    /=    work3[pj];    total    /=    work3[pj];    	compilable	  [FE]  AssertionFailedError  	36	4	replace
359	[BUG]  [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work4[pj];  sum  /=  work4[pj];  [CE]  cannot  find  symbol  work4  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    sum  /=  work3[pj];  sum  /=  work4[pj];  sum  /=  work4[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        sum    /=    work3[pj];    sum  /=  work4[pj];  sum  /=  work4[pj];	  	non-compiled	[CE]  cannot  find  symbol  work4	32	None	add
360	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solves;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solves  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solves;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solves;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	          for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solves	71	None	replace
361	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(diag[i],  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(diag[i],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(diag[i],  sum);	  double    diag[j]    =    Math.sqrt(solvedCols[i],    sum);    	non-compiled	[CE]  ']'  expected	64	None	replace
362	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solvesCols  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solvesCols	42	None	replace
363	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solves.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solves  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solves.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solves.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    qy.length;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solves	115	None	replace
364	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(diag,  sum2);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag  =  Math.sqrt(diag,  sum2);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag  =  Math.sqrt(diag,  sum2);	  double    diag    =    Math.sqrt(sum2);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
365	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  %=  permutation[j];  }  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  %=  permutation[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  %=  permutation[j];  }	  sum    /=    permutation[j];    int    permutation    %=    permutation[j];    	non-compiled	[CE]  ';'  expected	113	None	replace
366	[BUG]  [BUGGY]  sum  /=  permutation[0];  int  permutation  %=  permutation[0];  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  int  permutation  %=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[0];  int  permutation  %=  permutation[0];	  sum    /=    permutation[j];    int    permutation    %=    permutation[j];    	non-compiled	[CE]  ';'  expected	113	None	replace
367	[BUG]  [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  permutation[pj];  sum  /=  permutation[pj];  }  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  permutation[pj];  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        sum    /=    permutation[pj];    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  permutation[pj];  sum  /=  permutation[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  solveCols	1	None	add
368	[BUG]  [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  -=  permutation[pj];  sum  /=  permutation[pj];  }  [CE]  cannot  find  symbol  solveCols  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  -=  permutation[pj];  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        sum    /=    permutation[pj];    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  -=  permutation[pj];  sum  /=  permutation[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  solveCols	1	None	add
369	[BUG]  [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  permutation[i];  sum  /=  permutation[pj];  }  [CE]  cannot  find  symbol  solveCols  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  permutation[i];  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        sum    /=    permutation[pj];    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  permutation[i];  sum  /=  permutation[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  solveCols	1	None	add
370	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  Integer  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  >  expected  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  Integer  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    Integer  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  >  expected	12	None	add
371	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  double  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  >  expected  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  double  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    double  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  >  expected	12	None	add
372	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  Javabian[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  Javabian  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  Javabian[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  Javabian[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  cannot  find  symbol  Javabian	12	None	add
373	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(diag[0][pj]);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(diag[0][pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(diag[0][pj]);	  double    diag[j]    =    Math.sqrt(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	70	None	replace
374	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(diag[i][j]);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(diag[i][j]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(diag[i][j]);	  double    diag[j]    =    Math.sqrt(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	70	None	replace
375	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work3[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	4	add
376	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work3[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work3[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	108	4	add
377	[BUG]  [BUGGY]  sum  /=  work2[pj];  Sum  /=  work3[pj];  [CE]  cannot  find  symbol  Sum  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  Sum  /=  work3[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work2[pj];  Sum  /=  work3[pj];	  sum    /=    work3[pj];    Sum    /=    work3[pj];    	non-compiled	[CE]  cannot  find  symbol  Sum	34	None	replace
378	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(sum  +  3);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(sum  +  3);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(sum  +  3);	  double    diag[pj]    =    Math.sqrt(sum    +    1);    	non-compiled	[CE]  ']'  expected	39	None	replace
379	[BUG]  [BUGGY]  Integer  diag[i][pj]  =  Math.floor(diag[i]  *  work3[i]);  sum  +=  diag[i]  *  qy[i];  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Integer  diag[i][pj]  =  Math.floor(diag[i]  *  work3[i]);  sum  +=  diag[i]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Integer  diag[i][pj]  =  Math.floor(diag[i]  *  work3[i]);  sum  +=  diag[i]  *  qy[i];	  Integer    diag[i][pj]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    	non-compiled	[CE]  ']'  expected	92	None	replace
380	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  -=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  -=  permutation[pj];	  sum    /=    permutation[pj];    if(pj    <    0)    {    sum    /=    permutation[pj];    }    	compilable	  [FE]  AssertionFailedError  	120	3	replace
381	[BUG]  [BUGGY]  sum  -=  permutation[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  -=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  -=  permutation[pj];	  sum    /=    permutation[pj];    if(pj    <    0)    {    sum    /=    permutation[pj];    }    	compilable	  [FE]  AssertionFailedError  	120	3	replace
382	[BUG]  [BUGGY]  double  diag[pj]  =  Math.cos(solvedCols[pj]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.cos(solvedCols[pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.cos(solvedCols[pj]);	  double    diag[pj]    =    Math.log(solvedCols[pj]);    	non-compiled	[CE]  ']'  expected	9	None	replace
383	[BUG]  [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  double  permutation[j];  sum  /=  permutation[j];  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  double  permutation[j];  sum  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[j];        sum    /=    permutation[j];    double  permutation[j];  sum  /=  permutation[j];	  	non-compiled	[CE]  ']'  expected	25	None	add
384	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(diag[i][0]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(diag[i][0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(diag[i][0]);	  double    diag[pj]    =    Math.sqrt(diag[i][0]);    	non-compiled	[CE]  ']'  expected	69	None	replace
385	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work2[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work2[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	80	4	replace
386	[BUG]  [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work2[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work2[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work2[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	80	4	replace
387	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  }  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(solvedCols  >  0)  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(solvedCols  >  0)  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    double    diag[i][pj]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	20	None	replace
388	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][j]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][j]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][j]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    double    diag[i][pj]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	20	None	replace
389	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solves[i];  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solves  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solves[i];  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solves[i];  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    diag[i];    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solves	89	None	replace
390	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(diag[i],  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(diag[i],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(diag[i],  sum);	  double    diag[0]    =    Math.sqrt(solvedCols[i],    sum);    	non-compiled	[CE]  ']'  expected	102	None	replace
391	[BUG]  [BUGGY]  double  diag[pj]  =  Math.min(sum,  sum);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.min(sum,  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.min(sum,  sum);	  double    diag[pj]    =    Math.log(sum);    	non-compiled	[CE]  ']'  expected	38	None	replace
392	[BUG]  [BUGGY]  double  diag[pj]  =  Math.cos(sum);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.cos(sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.cos(sum);	  double    diag[pj]    =    Math.log(sum);    	non-compiled	[CE]  ']'  expected	38	None	replace
393	[BUG]  [BUGGY]  sum  /=  permutation[j];  /=  permutation[pj];  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j];  /=  permutation[pj];	  sum    /=    permutation[pj];    /=    permutation[pj];    	non-compiled	[CE]  illegal  start  of  expression	6	None	replace
394	[BUG]  [BUGGY]  sum  /=  permutation[i];  /=  permutation[pj];  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[i];  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[i];  /=  permutation[pj];	  sum    /=    permutation[pj];    /=    permutation[pj];    	non-compiled	[CE]  illegal  start  of  expression	6	None	replace
395	[BUG]  [BUGGY]  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	93	None	replace
396	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvecols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvecols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvecols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	93	None	replace
397	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[0][pj]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[0][pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[0][pj]);	  double    diag[pj]    =    Math.log(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	67	None	replace
398	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i][pj],  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i][pj],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i][pj],  sum);	  double    diag[pj]    =    Math.log(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	67	None	replace
399	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[i][pj]  *  work3);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[i][pj]  *  work3);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[i][pj]  *  work3);	  double    diag[pj]    =    Math.log(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	67	None	replace
400	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvingCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvingCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvingCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	94	None	replace
401	[BUG]  [BUGGY]  sum  /=  permutation[j];  Sum  /=  permutation[pj];  [CE]  cannot  find  symbol  Sum  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  Sum  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j];  Sum  /=  permutation[pj];	  sum    /=    permutation[pj];    Sum    /=    permutation[pj];    	non-compiled	[CE]  cannot  find  symbol  Sum	3	None	replace
402	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	4	replace
403	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work2[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	4	replace
404	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	4	replace
405	[BUG]  [BUGGY]  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	4	replace
406	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work2[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work2[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	4	replace
407	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work2[pj];  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work2[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  if(work2!=  null)  {  sum  /=  work2[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	109	4	replace
408	[BUG]  [BUGGY]  float  diag[i][pj]  *  qy[i];  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  float  diag[i][pj]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	float  diag[i][pj]  *  qy[i];	  int    diag[i][pj]    *    qy[i];    	non-compiled	[CE]  ']'  expected	22	None	replace
409	[BUG]  [BUGGY]  sum  /=  permutation[pj];  int  permutation  %=  permutation[0];  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[pj];  int  permutation  %=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[pj];  int  permutation  %=  permutation[0];	  sum    /=    permutation[pj];    int    permutation    %=    permutation[pj];    	non-compiled	[CE]  ';'  expected	104	None	replace
410	[BUG]  [BUGGY]  sum  /=  permutation[0];  int  permutation  %=  permutation[1];  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  int  permutation  %=  permutation[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[0];  int  permutation  %=  permutation[1];	  sum    /=    permutation[pj];    int    permutation    %=    permutation[pj];    	non-compiled	[CE]  ';'  expected	104	None	replace
411	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	96	None	replace
412	[BUG]  [BUGGY]  timeout  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  for(int  i  =  0;  i  <  work3[0];  ++i)  {  sum  /=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work3[0];    for(int  i  =  0;  i  <  work3[0];  ++i)  {  sum  /=  work3[0];  }	  	compilable	timeout	98	1	add
413	[BUG]  [BUGGY]  sum  /=  work3[0];  for(int  i  =  0;  i  <  work3[0];  ++i)  {  sum  /=  work3[0];  }  timeout  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  for(int  i  =  0;  i  <  work3[0];  ++i)  {  sum  /=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    for(int  i  =  0;  i  <  work3[0];  ++i)  {  sum  /=  work3[0];  }	  	compilable	timeout	98	1	add
414	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work3[0];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[0];  }	  	compilable	  [FE]  AssertionFailedError  	98	4	add
415	[BUG]  [BUGGY]  sum  /=  work3[0];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[0];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[0];  }	  	compilable	  [FE]  AssertionFailedError  	98	4	add
416	[BUG]  [BUGGY]  sum  /=  work3[0];  for(int  i  =  0;  i  <  =  work3[0];  ++i)  {  sum  /=  work3[0];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  for(int  i  =  0;  i  <  =  work3[0];  ++i)  {  sum  /=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    for(int  i  =  0;  i  <  =  work3[0];  ++i)  {  sum  /=  work3[0];  }	  	non-compiled	[CE]  illegal  start  of  expression	98	None	add
417	[BUG]  [BUGGY]  sum  /=  work3[0];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work3[0];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work3[0];  }	  	non-compiled	[CE]  cannot  find  symbol  solveCols	98	None	add
418	[BUG]  [BUGGY]  double  diag[pj]  =  Math.ceil(diag[i],  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.ceil(diag[i],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.ceil(diag[i],  sum);	  double    diag[pj]    =    Math.ceil(diag[i]);    	non-compiled	[CE]  ']'  expected	118	None	replace
419	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  sum2  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  permutation[j];  sum2  /=  permutation[j];	  sum    /=    permutation[j];    total    /=    permutation[j];    	compilable	  [FE]  AssertionFailedError  	29	13	replace
420	[BUG]  [BUGGY]  sum  /=  permutation[j];  sum2  /=  permutation[j];  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  sum2  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j];  sum2  /=  permutation[j];	  sum    /=    permutation[j];    total    /=    permutation[j];    	compilable	  [FE]  AssertionFailedError  	29	13	replace
421	[BUG]  [BUGGY]  sum  /=  permutation[0];  int  permutation[0]  =  Math.floor(permutation[0]);  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  int  permutation[0]  =  Math.floor(permutation[0]);  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    permutation[0];    int  permutation[0]  =  Math.floor(permutation[0]);	  	non-compiled	[CE]  ']'  expected	43	None	add
422	[BUG]  [BUGGY]  sum  /=  permutation[0];  int  permutation[0]  =  permutation[0];  [CE]  ']'  expected  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  int  permutation[0]  =  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    permutation[0];    int  permutation[0]  =  permutation[0];	  	non-compiled	[CE]  ']'  expected	43	None	add
423	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    sum  /=  work3[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
424	[BUG]  [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work3[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    sum  /=  work3[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
425	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
426	[BUG]  [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work3[pj];  }	  	compilable	  [FE]  AssertionFailedError  	79	4	add
427	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(solvedCols[0]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(solvedCols[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(solvedCols[0]);	  double    diag[j]    =    Math.sqrt(solvedCols[j]);    	non-compiled	[CE]  ']'  expected	107	None	replace
428	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solver.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solver  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solver.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solver.length;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    diagR.length;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solver	90	None	replace
429	[BUG]  [BUGGY]  sum  /=  diag[0];  Math  /=  diag[0];  [CE]  cannot  find  symbol  Math  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[0];  Math  /=  diag[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[0];    Math  /=  diag[0];	  	non-compiled	[CE]  cannot  find  symbol  Math	83	None	add
430	[BUG]  [BUGGY]  sum  /=  permutation[j];  int  permutation  =  Math.min(sum,  0);  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  int  permutation  =  Math.min(sum,  0);  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j];  int  permutation  =  Math.min(sum,  0);	  sum    /=    permutation[j];    int    permutation    =    Math.min(permutation,    0);    	non-compiled	[CE]  possible  loss  of  precision	106	None	replace
431	[BUG]  [BUGGY]  sum  /=  permutation[j];  int  permutation  =  Math.min(sum2,  0);  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  int  permutation  =  Math.min(sum2,  0);  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j];  int  permutation  =  Math.min(sum2,  0);	  sum    /=    permutation[j];    int    permutation    =    Math.min(permutation,    0);    	non-compiled	[CE]  possible  loss  of  precision	106	None	replace
432	[BUG]  [BUGGY]  sum  /=  permutation[j];  int  permutation  =  Math.min(permutation,  0,  permutation.length);  [CE]  int  cannot  be  dereferenced  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  int  permutation  =  Math.min(permutation,  0,  permutation.length);  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j];  int  permutation  =  Math.min(permutation,  0,  permutation.length);	  sum    /=    permutation[j];    int    permutation    =    Math.min(permutation,    0);    	non-compiled	[CE]  int  cannot  be  dereferenced	106	None	replace
433	[BUG]  [BUGGY]  sum  /=  solveCols[j];  sum  /=  permutation[j];  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  solveCols[j];  sum  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  solveCols[j];  sum  /=  permutation[j];	  sum    /=    permutation[j];    sum    /=    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  solveCols	26	None	replace
434	[BUG]  [BUGGY]  sum  /=  solveCols[j];  sum  /=  solveCols[j];  [CE]  cannot  find  symbol  solveCols  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  solveCols[j];  sum  /=  solveCols[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  solveCols[j];  sum  /=  solveCols[j];	  sum    /=    permutation[j];    sum    /=    permutation[j];    	non-compiled	[CE]  cannot  find  symbol  solveCols	26	None	replace
435	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols)+  1;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(solvedCols)+  1;  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(solvedCols)+  1;	  double    diag[pj]    =    Math.sqrt(sum2)+    1;    	non-compiled	[CE]  ']'  expected	101	None	replace
436	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  solvedcols[i][pj]  *  qy[i];  }  [CE]  int  cannot  be  dereferenced  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  solvedcols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols.length;  ++i)  {  sum  +=  solvedcols[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  int  cannot  be  dereferenced	40	None	replace
437	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  diag[i][pj]  *  qy[i];  }  [CE]  array  required,  but  double  found  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  diag[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  diag[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  array  required,  but  double  found	13	None	replace
438	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(sum  *  diag[0]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(sum  *  diag[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(sum  *  diag[0]);	  double    diag[pj]    =    Math.sqrt(diag[0]    *    sum);    	non-compiled	[CE]  ']'  expected	73	None	replace
439	[BUG]  [BUGGY]  sum  /=  permutation[0];  int  permutation  /=  permutation[0];  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  int  permutation  /=  permutation[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[0];  int  permutation  /=  permutation[0];	  sum    /=    permutation[pj];    int    permutation    /=    permutation[pj];    	non-compiled	[CE]  ';'  expected	103	None	replace
440	[BUG]  [BUGGY]  sum  /=  permutation[j];  int  permutation  /=  permutation[pj];  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[j];  int  permutation  /=  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  permutation[j];  int  permutation  /=  permutation[pj];	  sum    /=    permutation[pj];    int    permutation    /=    permutation[pj];    	non-compiled	[CE]  ';'  expected	103	None	replace
441	[BUG]  [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work2;  ++i)  {  sum  /=  work1[pj];  }  [CE]  bad  operand  types  for  binary  operator  '<'  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work2;  ++i)  {  sum  /=  work1[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    for(int  i  =  0;  i  <  work2;  ++i)  {  sum  /=  work1[pj];  }	  	non-compiled	[CE]  bad  operand  types  for  binary  operator  '<'	50	None	add
442	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work1[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work1[pj];    for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work1[pj];  }	  	compilable	  [FE]  AssertionFailedError  	50	5	add
443	[BUG]  [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work1[pj];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work1[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  /=  work1[pj];  }	  	compilable	  [FE]  AssertionFailedError  	50	5	add
444	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  /=  work1[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    work1[pj];    for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  /=  work1[pj];  }	  	compilable	  [FE]  AssertionFailedError  	50	5	add
445	[BUG]  [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  /=  work1[pj];  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  /=  work1[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  /=  work1[pj];  }	  	compilable	  [FE]  AssertionFailedError  	50	5	add
446	[BUG]  [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work2[pj];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work2[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work2[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    /=    work3[pj];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	81	None	replace
447	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  /=  permutation[j];  }  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  /=  permutation[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  /=  permutation[j];  }	  sum    /=    permutation[j];    int    permutation    /=    permutation[j];    	non-compiled	[CE]  ';'  expected	105	None	replace
448	[BUG]  [BUGGY]  double  diag[]  =  Math.sqrt(diag[0]  +  sum);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[]  =  Math.sqrt(diag[0]  +  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[]  =  Math.sqrt(diag[0]  +  sum);	  double    diag[]    =    Math.sqrt(diag[0]);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	61	None	replace
449	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  Sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [CE]  cannot  find  symbol  Sum  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  Sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    Sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  Sum	110	None	add
450	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  double  pj  =  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  double  pj  =  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    double  pj  =  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	110	None	add
451	[BUG]  [BUGGY]  double  diag[pj]  =  Math.rint(diag[pj]);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.rint(diag[pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.rint(diag[pj]);	  double    diag[pj]    =    Math.log(diag[pj]);    	non-compiled	[CE]  ']'  expected	60	None	replace
452	[BUG]  [BUGGY]  Sum  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [CE]  cannot  find  symbol  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Sum  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Sum  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][j]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol	97	None	replace
453	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvecols[i][j]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvecols[i][j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvecols[i][j]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][j]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	97	None	replace
454	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveable  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    j    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveable	123	None	replace
455	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  j  <  solveCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  j  <  solveCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  j  <  solveCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    j    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	123	None	replace
456	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	111	4	replace
457	[BUG]  [BUGGY]  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work2[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	111	4	replace
458	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work2[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work2[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	111	4	replace
459	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work2[pj];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work2[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work1[pj];  if(work3!=  null)  {  sum  /=  work2[pj];  }	  sum    /=    work3[pj];    if(work3!=    null)    {    sum    /=    work3[pj];    }    	compilable	  [FE]  AssertionFailedError  	111	4	replace
460	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  double  /=  permutation[j];  }  [CE]  unexpected  type  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  double  /=  permutation[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(sum  >  0)  {  sum  /=  permutation[j];  double  /=  permutation[j];  }	  sum    /=    permutation[j];    double    /=    permutation[j];    	non-compiled	[CE]  unexpected  type	28	None	replace
461	[BUG]  [BUGGY]  Integer  diag[][j]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Integer  diag[][j]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Integer  diag[][j]  =  Math.floor(diag[i]);  sum  +=  diag[i]  *  qy[i];	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    int    diag[i][j]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	91	None	replace
462	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  /=  diag[1];	  sum    /=    diag[0];    	compilable	  [FE]  AssertionFailedError  	84	3	replace
463	[BUG]  [BUGGY]  sum  /=  diag[1];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  diag[1];	  sum    /=    diag[0];    	compilable	  [FE]  AssertionFailedError  	84	3	replace
464	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(sum,  diag);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag  =  Math.sqrt(sum,  diag);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag  =  Math.sqrt(sum,  diag);	  double    diag    =    Math.sqrt(diag,    sum);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	86	None	replace
465	[BUG]  [BUGGY]  timeout  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  for(int  i  =  0;  i  <  diag[j];  ++i)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    diag[j];    for(int  i  =  0;  i  <  diag[j];  ++i)  {  sum  /=  diag[j];  }	  	compilable	timeout	47	1	add
466	[BUG]  [BUGGY]  sum  /=  diag[j];  for(int  i  =  0;  i  <  diag[j];  ++i)  {  sum  /=  diag[j];  }  timeout  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  for(int  i  =  0;  i  <  diag[j];  ++i)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    for(int  i  =  0;  i  <  diag[j];  ++i)  {  sum  /=  diag[j];  }	  	compilable	timeout	47	1	add
467	[BUG]  [BUGGY]  sum  /=  diag[j];  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  /=  diag[j];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  /=  diag[j];  }	  	non-compiled	[CE]  illegal  start  of  expression	47	None	add
468	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  for(int  i  =  0;  i  <  diag.length;  ++i)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    diag[j];    for(int  i  =  0;  i  <  diag.length;  ++i)  {  sum  /=  diag[j];  }	  	compilable	  [FE]  AssertionFailedError  	47	2	add
469	[BUG]  [BUGGY]  sum  /=  diag[j];  for(int  i  =  0;  i  <  diag.length;  ++i)  {  sum  /=  diag[j];  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  for(int  i  =  0;  i  <  diag.length;  ++i)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    for(int  i  =  0;  i  <  diag.length;  ++i)  {  sum  /=  diag[j];  }	  	compilable	  [FE]  AssertionFailedError  	47	2	add
470	[BUG]  [BUGGY]  sum  /=  diag[j];  for(int  i  =  0;  i  <  diag[j].length;  ++i)  {  sum  /=  diag[j];  }  [CE]  double  cannot  be  dereferenced  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  for(int  i  =  0;  i  <  diag[j].length;  ++i)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    for(int  i  =  0;  i  <  diag[j].length;  ++i)  {  sum  /=  diag[j];  }	  	non-compiled	[CE]  double  cannot  be  dereferenced	47	None	add
471	[BUG]  [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i];  if(pj  <  0)  {  sum  /=  permutation[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	119	None	add
472	[BUG]  [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  cannot  find  symbol  solveCols	119	None	add
473	[BUG]  [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  solveCols[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  solveCols[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  solveCols[i];  }	  	non-compiled	[CE]  cannot  find  symbol  solveCols	119	None	add
474	[BUG]  [BUGGY]  double  diag[1]  =  Math.sqrt(solvedCols[0]);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[1]  =  Math.sqrt(solvedCols[0]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[1]  =  Math.sqrt(solvedCols[0]);	  double    diag[0]    =    Math.sqrt(solvedCols[0]);    	non-compiled	[CE]  ']'  expected	10	None	replace
475	[BUG]  [BUGGY]  double  diag[pj]  =  Math.ceil(solvedCols[pj]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.ceil(solvedCols[pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.ceil(solvedCols[pj]);	  double    diag[pj]    =    Math.log(solvedCols[pj]);    	non-compiled	[CE]  ']'  expected	9	None	replace
476	[BUG]  [BUGGY]  int  permutation  =  Math.min(sum2,  0);  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  =  Math.min(sum2,  0);  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  =  Math.min(sum2,  0);	  sum    /=    permutation[j];    int    permutation    =    Math.min(permutation,    0);    	non-compiled	[CE]  possible  loss  of  precision	106	None	replace
477	[BUG]  [BUGGY]  Integer  diag[i][pj]  =  Math.floor(diag[i]  +  1);  sum  +=  diag[i]  *  qy[i];  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Integer  diag[i][pj]  =  Math.floor(diag[i]  +  1);  sum  +=  diag[i]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Integer  diag[i][pj]  =  Math.floor(diag[i]  +  1);  sum  +=  diag[i]  *  qy[i];	  Integer    diag[i][pj]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    	non-compiled	[CE]  ']'  expected	92	None	replace
478	[BUG]  [BUGGY]  Integer  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  jacobian[i]  *  qy[i];  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Integer  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  jacobian[i]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Integer  diag[i][pj]  =  Math.floor(diag[i]);  sum  +=  jacobian[i]  *  qy[i];	  Integer    diag[i][pj]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    	non-compiled	[CE]  ']'  expected	92	None	replace
479	[BUG]  [BUGGY]  double  diag[0]  =  Math.sqrt(diag[0]  *  sum);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[0]  =  Math.sqrt(diag[0]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[0]  =  Math.sqrt(diag[0]  *  sum);	  double    diag[0]    =    Math.sqrt(diag[0]);    	non-compiled	[CE]  ']'  expected	82	None	replace
480	[BUG]  [BUGGY]  int  permutation  =  permutation[pj];  [CE]  array  required,  but  int  found  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  permutation  =  permutation[pj];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  permutation  =  permutation[pj];	  sum    /=    permutation[pj];    int    permutation    /=    permutation[pj];    	non-compiled	[CE]  array  required,  but  int  found	103	None	replace
481	[BUG]  [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  /=  permutation[j];  sum  /=  permutation[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  /=  permutation[j];  sum  /=  permutation[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[j];        sum    /=    permutation[j];    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  /=  permutation[j];  sum  /=  permutation[j];  }	  	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	25	None	add
482	[BUG]  [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  -=  permutation[j];  sum  /=  permutation[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  -=  permutation[j];  sum  /=  permutation[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[j];        sum    /=    permutation[j];    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  -=  permutation[j];  sum  /=  permutation[j];  }	  	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	25	None	add
483	[BUG]  [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j];  sum  /=  permutation[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[j];    sum  /=  permutation[j];  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j];  sum  /=  permutation[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[j];        sum    /=    permutation[j];    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j];  sum  /=  permutation[j];  }	  	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	25	None	add
484	[BUG]  [BUGGY]  double  diag[pj]  =  Math.cos(diag[i]  *  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.cos(diag[i]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.cos(diag[i]  *  sum);	  double    diag[pj]    =    Math.log(diag[i]    *    sum);    	non-compiled	[CE]  ']'  expected	57	None	replace
485	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(diag[j]);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag  =  Math.sqrt(diag[j]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag  =  Math.sqrt(diag[j]);	  double    diag    =    Math.sqrt(diag);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	85	None	replace
486	[BUG]  [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work[pj];  }  [CE]  cannot  find  symbol  work  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work3[pj];  }  sum  /=  work[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        for(int    i    =    0;    i    <    work3.length;    ++i)    {    sum    /=    work3[pj];    }    sum  /=  work[pj];  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  /=  work[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  work	79	None	add
487	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  diag[i][j]  =  Math.floor(diag[i]);  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  diag[i][j]  =  Math.floor(diag[i]);  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  diag[i][j]  =  Math.floor(diag[i]);  sum  +=  jacobian[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    int    diag[i][j]    =    Math.floor(diag[i]);    sum    +=    diag[i]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	91	None	replace
488	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  %=  permutation[j];  }  else  {  sum++;  }  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  %=  permutation[j];  }  else  {  sum++;  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  %=  permutation[j];  }  else  {  sum++;  }	  sum    /=    permutation[j];    int    permutation    %=    permutation[j];    	non-compiled	[CE]  ';'  expected	113	None	replace
489	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	108	None	add
490	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	108	None	add
491	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [CE]  cannot  find  symbol  work  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  sum  /=  work[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    else    {    sum    +=    work3[pj];    }    sum  /=  work[pj];  if(work3!=  null)  {  sum  +=  work3[pj];  }  else  {  sum  +=  work3[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  work	108	None	add
492	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  if(diag[j]  <  0)  {  sum  /=  diag[j];  }  else  {  sum  +=  diag[j]  *  qy[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    diag[j];    if(diag[j]  <  0)  {  sum  /=  diag[j];  }  else  {  sum  +=  diag[j]  *  qy[j];  }	  	compilable	  [FE]  AssertionFailedError  	47	3	add
493	[BUG]  [BUGGY]  sum  /=  diag[j];  if(diag[j]  <  0)  {  sum  /=  diag[j];  }  else  {  sum  +=  diag[j]  *  qy[j];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  if(diag[j]  <  0)  {  sum  /=  diag[j];  }  else  {  sum  +=  diag[j]  *  qy[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    if(diag[j]  <  0)  {  sum  /=  diag[j];  }  else  {  sum  +=  diag[j]  *  qy[j];  }	  	compilable	  [FE]  AssertionFailedError  	47	3	add
494	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  if(diag[j]  <  0)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    diag[j];    if(diag[j]  <  0)  {  sum  /=  diag[j];  }	  	compilable	  [FE]  AssertionFailedError  	47	4	add
495	[BUG]  [BUGGY]  sum  /=  diag[j];  if(diag[j]  <  0)  {  sum  /=  diag[j];  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  if(diag[j]  <  0)  {  sum  /=  diag[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    if(diag[j]  <  0)  {  sum  /=  diag[j];  }	  	compilable	  [FE]  AssertionFailedError  	47	4	add
496	[BUG]  [BUGGY]  sum  /=  diag[j];  if(diag[j]  <  0)  {  sum  /=  diag[j];  }  else  {  sum  +=  diag[j]  *  qy[i];  }  [CE]  cannot  find  symbol  i  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  if(diag[j]  <  0)  {  sum  /=  diag[j];  }  else  {  sum  +=  diag[j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    if(diag[j]  <  0)  {  sum  /=  diag[j];  }  else  {  sum  +=  diag[j]  *  qy[i];  }	  	non-compiled	[CE]  cannot  find  symbol  i	47	None	add
497	[BUG]  [BUGGY]  sum  /=  diag[j];  Sum  /=  diag[j];  [CE]  cannot  find  symbol  Sum  [FE]          AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[j];  Sum  /=  diag[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[j];    Sum  /=  diag[j];	  	non-compiled	[CE]  cannot  find  symbol  Sum	47	None	add
498	[BUG]  [BUGGY]  double  diag[pj]  =  Math.ceil(diag[i][pj]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.ceil(diag[i][pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.ceil(diag[i][pj]);	  double    diag[pj]    =    Math.log(diag[i][pj]);    	non-compiled	[CE]  ']'  expected	67	None	replace
499	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  /=  permutation[j];  }  else  {  sum++;  }  [CE]  ';'  expected  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  /=  permutation[j];  }  else  {  sum++;  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(sum  >  0)  {  sum  /=  permutation[j];  int  permutation  /=  permutation[j];  }  else  {  sum++;  }	  sum    /=    permutation[j];    int    permutation    /=    permutation[j];    	non-compiled	[CE]  ';'  expected	105	None	replace
500	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    j    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	123	None	replace
501	[BUG]  [BUGGY]  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][j]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	97	None	replace
502	[BUG]  [BUGGY]  sum  -=  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  -=  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  -=  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][j]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	97	None	replace
503	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][j]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	97	None	replace
504	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  /  qy[i];  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  /  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  double  diag[i][pj]  /  qy[i];	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    double    diag[i][pj]    *    qy[i];    	non-compiled	[CE]  ']'  expected	23	None	replace
505	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  =  solvedCols;  ++i)  {  double  diag[i][pj]  *  qy[i];  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  =  solvedCols;  ++i)  {  double  diag[i][pj]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  =  solvedCols;  ++i)  {  double  diag[i][pj]  *  qy[i];	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    double    diag[i][pj]    *    qy[i];    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
506	[BUG]  [BUGGY]  double  diag[pj]  =  Math.log(diag[j]);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.log(diag[j]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.log(diag[j]);	  double    diag[pj]    =    Math.log(sum);    	non-compiled	[CE]  ']'  expected	38	None	replace
507	[BUG]  [BUGGY]  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	94	None	replace
508	[BUG]  [BUGGY]  sum  -=  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  -=  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  -=  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	94	None	replace
509	[BUG]  [BUGGY]  double  diag  =  Math.sqrt(sum2,  sum2);  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag  =  Math.sqrt(sum2,  sum2);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag  =  Math.sqrt(sum2,  sum2);	  double    diag    =    Math.sqrt(sum,    sum2);    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
510	[BUG]  [BUGGY]  double  diag[j]  =  Math.sqrt(solvedCols[0],  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[j]  =  Math.sqrt(solvedCols[0],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[j]  =  Math.sqrt(solvedCols[0],  sum);	  double    diag[pj]    =    Math.sqrt(solvedCols[0],    sum);    	non-compiled	[CE]  ']'  expected	63	None	replace
511	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(solvedCols  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(solvedCols  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	96	None	replace
512	[BUG]  [BUGGY]  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	96	None	replace
513	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0][pj],  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0][pj],  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[0][pj],  sum);	  double    diag[pj]    =    Math.sqrt(diag[0][pj]);    	non-compiled	[CE]  ']'  expected	75	None	replace
514	[BUG]  [BUGGY]  sum  /=  work3[j];  if(work3[j]  <  =  0)  {  sum  /=  work3[j];  }  else  {  sum  +=  work3[j]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[j];  if(work3[j]  <  =  0)  {  sum  /=  work3[j];  }  else  {  sum  +=  work3[j]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[j];    if(work3[j]  <  =  0)  {  sum  /=  work3[j];  }  else  {  sum  +=  work3[j]  *  qy[i];  }	  	non-compiled	[CE]  illegal  start  of  expression	54	None	add
515	[BUG]  [BUGGY]  sum  /=  work3[j];  if(work3[j]  <  =  0)  {  sum  /=  work3[j];  }  else  {  sum  +=  work3[j];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[j];  if(work3[j]  <  =  0)  {  sum  /=  work3[j];  }  else  {  sum  +=  work3[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[j];    if(work3[j]  <  =  0)  {  sum  /=  work3[j];  }  else  {  sum  +=  work3[j];  }	  	non-compiled	[CE]  illegal  start  of  expression	54	None	add
516	[BUG]  [BUGGY]  sum  /=  work3[j];  if(work3[j]  <  =  work3[j])  {  sum  /=  work3[j];  }  else  {  sum  +=  work3[j];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[j];  if(work3[j]  <  =  work3[j])  {  sum  /=  work3[j];  }  else  {  sum  +=  work3[j];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[j];    if(work3[j]  <  =  work3[j])  {  sum  /=  work3[j];  }  else  {  sum  +=  work3[j];  }	  	non-compiled	[CE]  illegal  start  of  expression	54	None	add
517	[BUG]  [BUGGY]  sum  +=  diag[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  i  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  +=  diag[i][pj]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  +=  diag[i][pj]  *  qy[i];	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  i	13	None	replace
518	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  cannot  find  symbol  solveCols	12	None	add
519	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  cocobian[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  cocobian  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  cocobian[i][pj]  *  qy[i];  }  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  cocobian[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  cannot  find  symbol  cocobian	12	None	add
520	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  double  /=  permutation[j];  }  else  {  sum  =  Math.sqrt(sum);  }  [CE]  unexpected  type  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(sum  >  0)  {  sum  /=  permutation[j];  double  /=  permutation[j];  }  else  {  sum  =  Math.sqrt(sum);  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(sum  >  0)  {  sum  /=  permutation[j];  double  /=  permutation[j];  }  else  {  sum  =  Math.sqrt(sum);  }	  sum    /=    permutation[j];    double    /=    permutation[j];    	non-compiled	[CE]  unexpected  type	28	None	replace
521	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[j]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[j]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[j]);	  double    diag[pj]    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  ']'  expected	100	None	replace
522	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[0];  diag[0]  =  diag[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    diag[0];    diag[0]  =  diag[0];	  	compilable	  [FE]  AssertionFailedError  	83	5	add
523	[BUG]  [BUGGY]  sum  /=  diag[0];  diag[0]  =  diag[0];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  diag[0];  diag[0]  =  diag[0];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    diag[0];    diag[0]  =  diag[0];	  	compilable	  [FE]  AssertionFailedError  	83	5	add
524	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCol[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solvedCol  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCol[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCol[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solvedCol	42	None	replace
525	[BUG]  [BUGGY]  sum  -=  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  array  required,  but  int  found  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  -=  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  -=  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  array  required,  but  int  found	122	None	replace
526	[BUG]  [BUGGY]  int  diag[i][pj]  =  Math.ceil(diag[i]);  sum  +=  diag[i]  *  qy[i];  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  diag[i][pj]  =  Math.ceil(diag[i]);  sum  +=  diag[i]  *  qy[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  diag[i][pj]  =  Math.ceil(diag[i]);  sum  +=  diag[i]  *  qy[i];	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    int    diag[i][pj]    =    Math.ceil(diag[i]);    sum    +=    diag[i]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	21	None	replace
527	[BUG]  [BUGGY]  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	95	None	replace
528	[BUG]  [BUGGY]  if(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	95	None	replace
529	[BUG]  [BUGGY]  sum  /=  work3[0];  if(work3[0]!=  null)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }  [CE]  incomparable  types:  double  and  <null>  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  if(work3[0]!=  null)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    if(work3[0]!=  null)  {  sum  /=  work3[0];  }  else  {  sum  +=  work3[0];  }	  	non-compiled	[CE]  incomparable  types:  double  and  <null>	98	None	add
530	[BUG]  [BUGGY]  sum  /=  work3[0];  if(work3[0]!=  null)  {  sum  /=  work3[0];  }  [CE]  incomparable  types:  double  and  <null>  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  if(work3[0]!=  null)  {  sum  /=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    if(work3[0]!=  null)  {  sum  /=  work3[0];  }	  	non-compiled	[CE]  incomparable  types:  double  and  <null>	98	None	add
531	[BUG]  [BUGGY]  sum  /=  work3[0];  if(work3[0]!=  null)  {  sum  /=  work3[0];  }  else  {  sum  /=  work3[0];  }  [CE]  incomparable  types:  double  and  <null>  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work3[0];  if(work3[0]!=  null)  {  sum  /=  work3[0];  }  else  {  sum  /=  work3[0];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work3[0];    if(work3[0]!=  null)  {  sum  /=  work3[0];  }  else  {  sum  /=  work3[0];  }	  	non-compiled	[CE]  incomparable  types:  double  and  <null>	98	None	add
532	[BUG]  [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  double  permutation  =  Math.sqrt(sum);  if(pj  <  0)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  double  permutation  =  Math.sqrt(sum);  if(pj  <  0)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    double  permutation  =  Math.sqrt(sum);  if(pj  <  0)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	119	None	add
533	[BUG]  [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  if(pj  <  0)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  +=  permutation[pj];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    if(pj  <  0)  {  sum  /=  permutation[pj];  }  if(pj  <  0)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  +=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        if(pj    <    0)    {    sum    /=    permutation[pj];    }    if(pj  <  0)  {  sum  /=  permutation[pj];  if(pj  <  0)  {  sum  +=  permutation[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	119	None	add
534	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work1[pj]!=  null)  {  sum  /=  work1[pj];  }  [CE]  incomparable  types:  double  and  <null>  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work1[pj]!=  null)  {  sum  /=  work1[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    if(work1[pj]!=  null)  {  sum  /=  work1[pj];  }	  	non-compiled	[CE]  incomparable  types:  double  and  <null>	50	None	add
535	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work1[pj]!=  null)  {  sum  /=  work1[pj];  }  else  {  sum  +=  work1[pj];  }  [CE]  incomparable  types:  double  and  <null>  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work1[pj]!=  null)  {  sum  /=  work1[pj];  }  else  {  sum  +=  work1[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    if(work1[pj]!=  null)  {  sum  /=  work1[pj];  }  else  {  sum  +=  work1[pj];  }	  	non-compiled	[CE]  incomparable  types:  double  and  <null>	50	None	add
536	[BUG]  [BUGGY]  sum  /=  work1[pj];  if(work1[pj]!=  null)  {  sum  /=  work1[pj];  }  else  {  sum  /=  work1[pj];  }  [CE]  incomparable  types:  double  and  <null>  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work1[pj];  if(work1[pj]!=  null)  {  sum  /=  work1[pj];  }  else  {  sum  /=  work1[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work1[pj];    if(work1[pj]!=  null)  {  sum  /=  work1[pj];  }  else  {  sum  /=  work1[pj];  }	  	non-compiled	[CE]  incomparable  types:  double  and  <null>	50	None	add
537	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(sum2)-  1;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(sum2)-  1;  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(sum2)-  1;	  double    diag[pj]    =    Math.sqrt(sum2)+    1;    	non-compiled	[CE]  ']'  expected	101	None	replace
538	[BUG]  [BUGGY]  Sum  sum  /=  permutation[j];  sum  /=  permutation[j];  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Sum  sum  /=  permutation[j];  sum  /=  permutation[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Sum  sum  /=  permutation[j];  sum  /=  permutation[j];	  sum    /=    permutation[j];    total    /=    permutation[j];    	non-compiled	[CE]  ';'  expected	29	None	replace
539	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	if(pj  <  0)  {  sum  /=  permutation[pj];  }	  sum    /=    permutation[pj];    if(pj    <    0)    {    sum    /=    permutation[pj];    }    	compilable	  [FE]  AssertionFailedError  	120	4	replace
540	[BUG]  [BUGGY]  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(pj  <  0)  {  sum  /=  permutation[pj];  }	  sum    /=    permutation[pj];    if(pj    <    0)    {    sum    /=    permutation[pj];    }    	compilable	  [FE]  AssertionFailedError  	120	4	replace
541	[BUG]  [BUGGY]  double  pj  =  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  pj  =  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  pj  =  permutation[pj];  if(pj  <  0)  {  sum  /=  permutation[pj];  }	  sum    /=    permutation[pj];    if(pj    <    0)    {    sum    /=    permutation[pj];    }    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	120	None	replace
542	[BUG]  [BUGGY]  sum  /=  work[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work[pj];  }  [CE]  cannot  find  symbol  work  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  work[pj];  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  /=  work[pj];  }	  sum    /=    work3[pj];    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    /=    work3[pj];    }    	non-compiled	[CE]  cannot  find  symbol  work	81	None	replace
543	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  sum  /=  permutation[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum    /=    permutation[0];    sum  /=  permutation[1];	  	compilable	  [FE]  AssertionFailedError  	43	3	add
544	[BUG]  [BUGGY]  sum  /=  permutation[0];  sum  /=  permutation[1];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  permutation[0];  sum  /=  permutation[1];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    permutation[0];    sum  /=  permutation[1];	  	compilable	  [FE]  AssertionFailedError  	43	3	add
545	[BUG]  [BUGGY]  sum  /=  work2[pj];  if(work2[pj]  <  =  Math.abs(work2[pj]))  {  sum  /=  work2[pj];  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  if(work2[pj]  <  =  Math.abs(work2[pj]))  {  sum  /=  work2[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work2[pj];    if(work2[pj]  <  =  Math.abs(work2[pj]))  {  sum  /=  work2[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	52	None	add
546	[BUG]  [BUGGY]  sum  /=  work2[pj];  if(work2[pj]  <  =  Math.max(work2[pj]))  {  sum  /=  work2[pj];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  if(work2[pj]  <  =  Math.max(work2[pj]))  {  sum  /=  work2[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work2[pj];    if(work2[pj]  <  =  Math.max(work2[pj]))  {  sum  /=  work2[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	52	None	add
547	[BUG]  [BUGGY]  sum  /=  work2[pj];  if(work2[pj]  <  =  work2[pj])  {  sum  /=  work2[pj];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  work2[pj];  if(work2[pj]  <  =  work2[pj])  {  sum  /=  work2[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum    /=    work2[pj];    if(work2[pj]  <  =  work2[pj])  {  sum  /=  work2[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	52	None	add
548	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveable  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveable[i][pj]  *  qy[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveable	40	None	replace
549	[BUG]  [BUGGY]  int  diag[i][pj]  *  jacobian[i];  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  int  diag[i][pj]  *  jacobian[i];  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	int  diag[i][pj]  *  jacobian[i];	  int    diag[i][pj]    *    qy[i];    	non-compiled	[CE]  ']'  expected	22	None	replace
550	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	add	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	compilable	  [FE]  AssertionFailedError  	121	15	replace
551	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    qy[i];    }    	compilable	  [FE]  AssertionFailedError  	121	15	replace
552	[BUG]  [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [CE]  array  required,  but  int  found  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    permutation[pj];    sum  /=  permutation[pj];  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        permutation[pj];        sum    /=    permutation[pj];    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  array  required,  but  int  found	1	None	add
553	[BUG]  [BUGGY]  if(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  if(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	if(j  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	93	None	replace
554	[BUG]  [BUGGY]  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	Math.sqrt(sum2);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	          if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	93	None	replace
555	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][pj]  *  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[i][pj]  *  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[i][pj]  *  sum);	  double    diag[pj]    =    Math.sqrt(diag[i][pj],    sum);    	non-compiled	[CE]  ']'  expected	77	None	replace
556	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [CE]  cannot  find  symbol  work  [FE]    AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  sum  /=  work[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    sum  /=  work[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  work	110	None	add
557	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	110	None	add
558	[BUG]  [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj].;  }  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum    /=    work3[pj];    if(work3!=  null)  {  sum  /=  work3[pj];  }  if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj].;  }  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum        /=        work3[pj];        if(work3!=    null)    {    sum    /=    work3[pj];    }    if(work3!=  null)  {  sum  /=  work3[pj];  if(work3!=  null)  {  sum  /=  work3[pj].;  }	  	non-compiled	[CE]  <identifier>  expected	110	None	add
559	[BUG]  [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0]  /  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.sqrt(diag[0]  /  sum);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.sqrt(diag[0]  /  sum);	  double    diag[pj]    =    Math.sqrt(diag[0]    +    sum);    	non-compiled	[CE]  ']'  expected	74	None	replace
560	[BUG]  [BUGGY]  sum  /=  solvingCols[j];  [CE]  cannot  find  symbol  solvingCols  [FE]        AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  sum  /=  solvingCols[j];  [BUGGY]      sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	sum  /=  solvingCols[j];	  sum    /=    solvedCols[j];    	non-compiled	[CE]  cannot  find  symbol  solvingCols	56	None	replace
561	[BUG]  [BUGGY]  double  diag[pj]  =  Math.ceil(diag[pj]);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.ceil(diag[pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.ceil(diag[pj]);	  double    diag[pj]    =    Math.log(diag[pj]);    	non-compiled	[CE]  ']'  expected	60	None	replace
562	[BUG]  [BUGGY]  double  diag[pj]  =  Math.cos(diag[pj]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }      [BUGGY]  double  diag[pj]  =  Math.cos(diag[pj]);  [BUGGY]      sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	556	556	2	replace	double  diag[pj]  =  Math.cos(diag[pj]);	  double    diag[pj]    =    Math.log(diag[pj]);    	non-compiled	[CE]  ']'  expected	60	None	replace
