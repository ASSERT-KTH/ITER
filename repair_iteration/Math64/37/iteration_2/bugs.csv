bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	18	4	add
2	[BUG]  [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	18	4	add
3	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	18	4	add
4	[BUG]  [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	18	4	add
5	[BUG]  [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	18	None	add
6	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	18	4	add
7	[BUG]  [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	18	4	add
8	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.0,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  double  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.0,  0.001  *  paru);	      double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	11	None	replace
9	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  double  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	      double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	11	None	replace
10	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);	      double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	11	None	replace
11	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	20	4	add
12	[BUG]  [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	20	4	add
13	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	20	4	add
14	[BUG]  [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	20	4	add
15	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	20	4	add
16	[BUG]  [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	20	4	add
17	[BUG]  [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    LmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	20	None	add
18	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown  <  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	4	15	replace
19	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	4	15	replace
20	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	4	15	replace
21	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	4	15	replace
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown!=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	4	15	replace
23	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown!=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	4	15	replace
24	[BUG]  [BUGGY]  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
25	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.2251e-308,  0.001);	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
26	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(delta,  0.0)));  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(delta,  0.0)));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(delta,  0.0)));	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
27	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	22	5	add
28	[BUG]  [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	22	5	add
29	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	22	5	add
30	[BUG]  [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	22	5	add
31	[BUG]  [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  LmPar  =  Math.max(2.0,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  LmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.0,    0.001    *    paru);    LmPar  =  Math.max(2.0,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	22	None	add
32	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	22	5	add
33	[BUG]  [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	22	5	add
34	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  1;  countdown!=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	2	5	replace
35	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown!=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	2	5	replace
36	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  1;  countdown  <  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	2	15	replace
37	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  <  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	2	15	replace
38	[BUG]  [BUGGY]  for(int  i  =  1;  countdown  >=  0;  --i)  {  [CE]  cannot  find  symbol  countdown  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  i  =  1;  countdown  >=  0;  --i)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  countdown  >=  0;  --i)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  cannot  find  symbol  countdown	2	None	replace
39	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
40	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    for(int  countdown  =  0;  countdown!=  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
41	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >>  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >>  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    for(int  countdown  =  0;  countdown  >>  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
42	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  	non-compiled	[CE]  not  a  statement	3	None	add
43	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]            AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  	non-compiled	[CE]  '.class'  expected	3	None	add
44	[BUG]  [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
45	[BUG]  [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown!=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown!=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    for(int  countdown  =  2;  countdown!=  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
46	[BUG]  [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown  >>  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown  >>  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    for(int  countdown  =  2;  countdown  >>  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
47	[BUG]  [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    int  countdown  =  2;  countdown  >=  0;  --countdown)  {	  	non-compiled	[CE]  not  a  statement	5	None	add
48	[BUG]  [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]            AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {	  	non-compiled	[CE]  '.class'  expected	5	None	add
49	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	5	add
50	[BUG]  [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	5	add
51	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	5	add
52	[BUG]  [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	5	add
53	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	5	add
54	[BUG]  [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	5	add
55	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	5	add
56	[BUG]  [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	5	add
57	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	      lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	21	None	replace
58	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	6	15	replace
59	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	6	15	replace
60	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	8	5	add
61	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	8	5	add
62	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	8	5	add
63	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	8	5	add
64	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	8	5	add
65	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	8	5	add
66	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	8	5	add
67	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	8	5	add
68	[BUG]  [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	add
69	[BUG]  [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	add
70	[BUG]  [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  Double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  Double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    Double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	add
71	[BUG]  [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	add
72	[BUG]  [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	add
73	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
74	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    for(int  countdown  =  1;  countdown!=  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
75	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >>  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >>  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    for(int  countdown  =  1;  countdown  >>  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
76	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    int  countdown  =  1;  countdown  >=  0;  --countdown)  {	  	non-compiled	[CE]  not  a  statement	1	None	add
77	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]            AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {	  	non-compiled	[CE]  '.class'  expected	1	None	add
78	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	16	5	add
79	[BUG]  [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	16	5	add
80	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	16	5	add
81	[BUG]  [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	16	5	add
82	[BUG]  [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	16	None	add
83	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	16	5	add
84	[BUG]  [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	16	5	add
85	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	5	add
86	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	5	add
87	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	5	add
88	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	5	add
89	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	5	add
90	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	5	add
91	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]          AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	14	None	add
92	[BUG]  [BUGGY]  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	      lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	15	None	replace
93	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.002  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.002  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.2251e-308,  0.002  *  paru);	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
94	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	5	add
95	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	5	add
96	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-408,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-408,  0.001  *  paru);	  	non-compiled	[CE]  floating  point  number  too  small	14	None	add
97	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	8	5	add
98	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	8	5	add
99	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	8	None	add
100	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
101	[BUG]  [BUGGY]  lmPar  =  Math.min(2.0e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  lmPar  =  Math.min(2.0e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.0e-308,  0.001  *  paru);	      lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	19	None	replace
102	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	20	4	add
103	[BUG]  [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	20	4	add
104	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  paru  +  1);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  0.001  *  paru  +  1);	      lmPar    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	23	None	replace
105	[BUG]  [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  (lmPar  =  Math.max(2.0,  0.001  *  paru);  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.0,  0.001  *  paru);  (lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.0,    0.001    *    paru);    (lmPar  =  Math.max(2.0,  0.001  *  paru);	  	non-compiled	[CE]  ')'  expected	22	None	add
106	[BUG]  [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	5	None	add
107	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
108	[BUG]  [BUGGY]  lmPar  =  Math.sqrt(paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  lmPar  =  Math.sqrt(paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.sqrt(paru);	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
109	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(paru);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  double  lmPar  =  Math.sqrt(paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.sqrt(paru);	      	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
110	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	5	add
111	[BUG]  [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	5	add
112	[BUG]  [BUGGY]  lmPar  =  Math.min(2.0,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  lmPar  =  Math.min(2.0,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.0,  0.001  *  paru);	      lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	19	None	replace
113	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown  <  2;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	4	2	replace
114	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  2;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	4	2	replace
115	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  double  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	      double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	11	None	replace
116	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  lmPar);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  lmPar);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.2251e-308,  0.001  *  lmPar);	      double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	11	None	replace
117	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  <  =  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]  for(int  countdown  =  1;  countdown  <  =  0;  --countdown)  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  <  =  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	2	None	replace
118	[BUG]  [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2253e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2253e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2253e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	add
119	[BUG]  [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2255e-308,  0.001  *  paru);  [CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }    [BUGGY]      double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  double  lmPar  =  Math.max(2.2255e-308,  0.001  *  paru);  [BUGGY]    for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	        double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double  lmPar  =  Math.max(2.2255e-308,  0.001  *  paru);	  	non-compiled	[CE]  variable  lmPar  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	add
