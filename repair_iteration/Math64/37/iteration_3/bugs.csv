bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  lmPar  =  Math.sqrt(gNorm);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.sqrt(gNorm);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.sqrt(gNorm);	  lmPar    =    Math.sqrt(paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	108	None	replace
2	[BUG]  [BUGGY]  lmPar  =  Math.sqrt(param);  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.sqrt(param);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.sqrt(param);	  lmPar    =    Math.sqrt(paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	108	None	replace
3	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
4	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
5	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
6	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
7	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
8	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
9	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
10	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
11	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	73	None	replace
12	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	73	None	replace
13	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	73	None	replace
14	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	78	5	add
15	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	78	5	add
16	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	78	5	add
17	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	78	5	add
18	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  no  suitable  method  found  for  max(double,double,double)  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,double)	78	None	add
19	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	78	5	add
20	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	78	5	add
21	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	39	None	replace
22	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	39	None	replace
23	[BUG]  [BUGGY]  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    LmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	99	None	replace
24	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.0,  0.001  *  lmPar);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.0,  0.001  *  lmPar);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.0,  0.001  *  lmPar);	  double    lmPar    =    Math.max(2.2251e-308,    0.001    *    lmPar);    	non-compiled	[CE]  class,  interface,  or  enum  expected	116	None	replace
25	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	27	5	add
26	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	27	5	add
27	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [CE]  no  suitable  method  found  for  max(double,double,double)  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	non-compiled	[CE]  no  suitable  method  found  for  max(double,double,double)	27	None	add
28	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(0.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	27	5	add
29	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(0.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	27	5	add
30	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	27	5	add
31	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	27	5	add
32	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	48	None	replace
33	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                  AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	48	None	replace
34	[BUG]  [BUGGY]  LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    LmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	82	None	replace
35	[BUG]  [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    2;    countdown!=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	45	None	replace
36	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    2;    countdown!=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	45	None	replace
37	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	90	None	replace
38	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  1;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown  <  1;  --countdown)  {	  for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	114	2	replace
39	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  1;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  1;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  1;  --countdown)  {	  for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	114	2	replace
40	[BUG]  [BUGGY]  for(int  i  =  0;  countdown  <  2;  --i)  {  [CE]  cannot  find  symbol  countdown  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  0;  countdown  <  2;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  0;  countdown  <  2;  --i)  {	  for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    	non-compiled	[CE]  cannot  find  symbol  countdown	114	None	replace
41	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  3;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown  <  3;  --countdown)  {	  for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	114	2	replace
42	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  3;  --countdown)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  3;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  3;  --countdown)  {	  for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	114	2	replace
43	[BUG]  [BUGGY]  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	paru  =  Math.max(2.2251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	98	None	replace
44	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown!=  1;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown!=  1;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    1;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	21	2	replace
45	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown!=  1;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown!=  1;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown!=  1;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    1;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	21	2	replace
46	[BUG]  [BUGGY]  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	42	None	replace
47	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	42	None	replace
48	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]                  AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	42	None	replace
49	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	83	5	add
50	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	83	5	add
51	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	83	5	add
52	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	83	5	add
53	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	83	5	add
54	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	83	5	add
55	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	83	5	add
56	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	83	5	add
57	[BUG]  [BUGGY]  for(int  i  =  1;  countdown  >=  0;  --i)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  countdown  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  countdown  >=  0;  --i)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  countdown  >=  0;  --i)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  countdown	100	None	replace
58	[BUG]  [BUGGY]  for(int  lmPar  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  countdown  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  lmPar  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  lmPar  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  countdown	100	None	replace
59	[BUG]  [BUGGY]  for(int  lmPar  =  1;  lmPar!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  countdown  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  lmPar  =  1;  lmPar!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  lmPar  =  1;  lmPar!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  countdown	100	None	replace
60	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  double    lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	9	None	replace
61	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    2;    --countdown)    {    for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	58	None	add
62	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  for(int  countdown  =  0;  countdown!=  2;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  for(int  countdown  =  0;  countdown!=  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    2;    --countdown)    {    for(int  countdown  =  0;  countdown!=  2;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	58	None	add
63	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  for(int  countdown  =  0;  countdown  >>  2;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  for(int  countdown  =  0;  countdown  >>  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    2;    --countdown)    {    for(int  countdown  =  0;  countdown  >>  2;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	58	None	add
64	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [CE]  not  a  statement  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    2;    --countdown)    {    int  countdown  =  0;  countdown  >=  2;  --countdown)  {	  	non-compiled	[CE]  not  a  statement	58	None	add
65	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [CE]  '.class'  expected  [FE]            AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    2;    --countdown)    {    For(int  countdown  =  0;  countdown  >=  2;  --countdown)  {	  	non-compiled	[CE]  '.class'  expected	58	None	add
66	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2252e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.2252e-408,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.2252e-408,  0.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2252e-408,    0.001    *    paru);    	non-compiled	[CE]  floating  point  number  too  small	96	None	replace
67	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.2255e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.2255e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.2255e-308,  0.001  *  paru);	          double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.max(2.2255e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	119	None	replace
68	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.22551e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.22551e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.22551e-308,  0.001  *  paru);	          double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.max(2.2255e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	119	None	replace
69	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    <    0;    --countdown)    {    for(int  countdown  =  1;  countdown  <  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	36	None	add
70	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  int  countdown  =  1;  countdown  <  0;  --countdown)  {  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  int  countdown  =  1;  countdown  <  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    <    0;    --countdown)    {    int  countdown  =  1;  countdown  <  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  type	36	None	add
71	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    <    0;    --countdown)    {    if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }	  	non-compiled	[CE]  illegal  start  of  expression	36	None	add
72	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  For(int  countdown  =  1;  countdown  <  0;  --countdown)  {  [CE]  '.class'  expected  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  For(int  countdown  =  1;  countdown  <  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    <    0;    --countdown)    {    For(int  countdown  =  1;  countdown  <  0;  --countdown)  {	  	non-compiled	[CE]  '.class'  expected	36	None	add
73	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  <  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown    <    0;    --countdown)    {    Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	36	None	add
74	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
75	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
76	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
77	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
78	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
79	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
80	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
81	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
82	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    1;    countdown!=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	74	None	replace
83	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown!=    0;    --countdown)    {    for(int  countdown  =  0;  countdown!=  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	22	None	add
84	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  int  countdown  =  0;  countdown!=  0;  --countdown)  {  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  int  countdown  =  0;  countdown!=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown!=    0;    --countdown)    {    int  countdown  =  0;  countdown!=  0;  --countdown)  {	  	non-compiled	[CE]  not  a  statement	22	None	add
85	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  For(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  For(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown!=    0;    --countdown)    {    For(int  countdown  =  0;  countdown!=  0;  --countdown)  {	  	non-compiled	[CE]  '.class'  expected	22	None	add
86	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >>  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >>  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown!=    0;    --countdown)    {    for(int  countdown  =  0;  countdown  >>  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	22	None	add
87	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	64	5	add
88	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	64	5	add
89	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	64	5	add
90	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	64	5	add
91	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	64	5	add
92	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	64	5	add
93	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	64	5	add
94	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	64	5	add
95	[BUG]  [BUGGY]  int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	int  countdown  =  1;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	76	None	replace
96	[BUG]  [BUGGY]  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	countdown  =  1;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	76	None	replace
97	[BUG]  [BUGGY]  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	paru  =  Math.max(2.0251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru    =    Math.max(2.0251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	84	None	replace
98	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru    =    Math.max(2.0251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	84	None	replace
99	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.002  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,  0.002  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  0.002  *  paru);	  lmPar    =    Math.max(2.2251e-308,    0.002    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	93	None	replace
100	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
101	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
102	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
103	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
104	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
105	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
106	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
107	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
108	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	32	5	add
109	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	32	5	add
110	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	32	5	add
111	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	32	5	add
112	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(0.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	32	5	add
113	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(0.0,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	32	5	add
114	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	32	5	add
115	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  paru  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	32	5	add
116	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(gNorm);  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.sqrt(gNorm);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.sqrt(gNorm);	  double    lmPar    =    Math.sqrt(paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	109	None	replace
117	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(lmPar);  [CE]  class,  interface,  or  enum  expected  [FE]                      AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.sqrt(lmPar);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.sqrt(lmPar);	  double    lmPar    =    Math.sqrt(paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	109	None	replace
118	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]                        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.sqrt(paru  +  1);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.sqrt(paru  +  1);	  double    lmPar    =    Math.sqrt(paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	109	None	replace
119	[BUG]  [BUGGY]  for(int  i  =  2;  countdown  >=  0;  --i)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  countdown  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  2;  countdown  >=  0;  --i)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  2;  countdown  >=  0;  --i)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  countdown	106	None	replace
120	[BUG]  [BUGGY]  for(int  lmPar  =  2;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  countdown  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  lmPar  =  2;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  lmPar  =  2;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  countdown	106	None	replace
121	[BUG]  [BUGGY]  for(int  lmPar  =  2;  lmPar!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  countdown  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  lmPar  =  2;  lmPar!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  lmPar  =  2;  lmPar!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  countdown	106	None	replace
122	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  2);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  2);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  2);	  double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  class,  interface,  or  enum  expected	10	None	replace
123	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.251e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.251e-308,  0.001  *  paru  +  1);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.251e-308,  0.001  *  paru  +  1);	  double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  class,  interface,  or  enum  expected	10	None	replace
124	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	62	5	add
125	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	62	5	add
126	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	62	5	add
127	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	62	5	add
128	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	62	5	add
129	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	62	5	add
130	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	62	5	add
131	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	62	5	add
132	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
133	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
134	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
135	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
136	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
137	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
138	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
139	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	66	5	add
140	[BUG]  [BUGGY]  LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    LmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	91	None	replace
141	[BUG]  [BUGGY]  for(int  i  =  0;  countdown  <  0;  --i)  {  [CE]  cannot  find  symbol  countdown  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  0;  countdown  <  0;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  0;  countdown  <  0;  --i)  {	  for(int    countdown    =    0;    countdown    <    0;    --countdown)    {    	non-compiled	[CE]  cannot  find  symbol  countdown	19	None	replace
142	[BUG]  [BUGGY]  for(int  i  =  1;  countdown  <  =  0;  --i)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  countdown  <  =  0;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  countdown  <  =  0;  --i)  {	  for(int    countdown    =    1;    countdown    <    =    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	117	None	replace
143	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    for(int  countdown  =  0;  countdown  <  2;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	113	None	add
144	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  int  countdown  =  0;  countdown  <  2;  --countdown)  {  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  int  countdown  =  0;  countdown  <  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    int  countdown  =  0;  countdown  <  2;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  type	113	None	add
145	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }	  	non-compiled	[CE]  illegal  start  of  expression	113	None	add
146	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  For(int  countdown  =  0;  countdown  <  2;  --countdown)  {  [CE]  '.class'  expected  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  For(int  countdown  =  0;  countdown  <  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    For(int  countdown  =  0;  countdown  <  2;  --countdown)  {	  	non-compiled	[CE]  '.class'  expected	113	None	add
147	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	113	None	add
148	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	80	5	add
149	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	80	5	add
150	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	80	5	add
151	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	80	5	add
152	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	80	5	add
153	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	80	5	add
154	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	80	5	add
155	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	80	5	add
156	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  ==  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  1;  countdown  ==  0;  --countdown)  {	  for(int    countdown    =    1;    countdown!=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	35	15	replace
157	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  ==  0;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  ==  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  ==  0;  --countdown)  {	  for(int    countdown    =    1;    countdown!=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	35	15	replace
158	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	87	5	add
159	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	87	5	add
160	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	87	5	add
161	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	87	5	add
162	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	87	5	add
163	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	87	5	add
164	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	87	5	add
165	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	87	5	add
166	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	110	5	add
167	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	110	5	add
168	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	110	5	add
169	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	110	5	add
170	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	110	5	add
171	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	110	5	add
172	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	110	5	add
173	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	110	5	add
174	[BUG]  [BUGGY]  int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	int  countdown  =  2;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	47	None	replace
175	[BUG]  [BUGGY]  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	countdown  =  2;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	47	None	replace
176	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]                  AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  2;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	47	None	replace
177	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.001);  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,  0.001);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  0.001);	  lmPar    =    Math.max(2.2251e-308,    0.001);    	non-compiled	[CE]  class,  interface,  or  enum  expected	25	None	replace
178	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	          double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	71	None	replace
179	[BUG]  [BUGGY]  Double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  Double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	Double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	          double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	71	None	replace
180	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);	  lmPar    =    Math.max(2.0,    0.001    *    paru    +    1);    	non-compiled	[CE]  class,  interface,  or  enum  expected	104	None	replace
181	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  paru  +  2);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  paru  +  2);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  0.001  *  paru  +  2);	  lmPar    =    Math.max(2.0,    0.001    *    paru    +    1);    	non-compiled	[CE]  class,  interface,  or  enum  expected	104	None	replace
182	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown!=    0;    --countdown)    {    for(int  countdown  =  1;  countdown!=  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	34	None	add
183	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  int  countdown  =  1;  countdown!=  0;  --countdown)  {  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  int  countdown  =  1;  countdown!=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown!=    0;    --countdown)    {    int  countdown  =  1;  countdown!=  0;  --countdown)  {	  	non-compiled	[CE]  not  a  statement	34	None	add
184	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >>  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  for(int  countdown  =  1;  countdown  >>  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown!=    0;    --countdown)    {    for(int  countdown  =  1;  countdown  >>  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	34	None	add
185	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  For(int  countdown  =  1;  countdown!=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  For(int  countdown  =  1;  countdown!=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown!=    0;    --countdown)    {    For(int  countdown  =  1;  countdown!=  0;  --countdown)  {	  	non-compiled	[CE]  '.class'  expected	34	None	add
186	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,.001  *  paru);	          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar    =    Math.max(2.0,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	30	None	replace
187	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	4	add
188	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	4	add
189	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	4	add
190	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	4	add
191	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	4	add
192	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	4	add
193	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	4	add
194	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	4	add
195	[BUG]  [BUGGY]  lmPar  =  Math.min(2.0,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.0,  0.001  *  paru  +  1);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.0,  0.001  *  paru  +  1);	  lmPar    =    Math.min(2.0,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	112	None	replace
196	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        paru    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	94	5	add
197	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        paru    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	94	5	add
198	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        paru    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	94	5	add
199	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        paru    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	94	5	add
200	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        paru    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	94	5	add
201	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        paru    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	94	5	add
202	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        paru    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	94	5	add
203	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        paru    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	94	5	add
204	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	4	add
205	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	4	add
206	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	4	add
207	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	4	add
208	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	4	add
209	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	4	add
210	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	4	add
211	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	4	add
212	[BUG]  [BUGGY]  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	57	None	replace
213	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru  +  1);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.2252e-308,  0.001  *  paru  +  1);	  lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	57	None	replace
214	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
215	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
216	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
217	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
218	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
219	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
220	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  paru  =  Math.min(2.250e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  paru  =  Math.min(2.250e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
221	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  paru  =  Math.min(2.250e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  paru  =  Math.min(2.250e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  paru  =  Math.min(2.250e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
222	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	43	None	replace
223	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                  AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	43	None	replace
224	[BUG]  [BUGGY]  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                    AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	43	None	replace
225	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	77	None	replace
226	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                  AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	77	None	replace
227	[BUG]  [BUGGY]  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    LmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	5	None	replace
228	[BUG]  [BUGGY]  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	56	None	replace
229	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	85	5	add
230	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	85	5	add
231	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	85	5	add
232	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	85	5	add
233	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	85	5	add
234	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	85	5	add
235	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	85	5	add
236	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	85	5	add
237	[BUG]  [BUGGY]  for(int  i  =  1;  --i  >=  0;  --i)  {  [CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  --i  >=  0;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  --i  >=  0;  --i)  {	  for(int    i    =    1;    countdown    >=    0;    --i)    {    	non-compiled	[CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	38	None	replace
238	[BUG]  [BUGGY]  for(int  i  =  1;  --i!=  0;  --i)  {  [CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  --i!=  0;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  --i!=  0;  --i)  {	  for(int    i    =    1;    countdown    >=    0;    --i)    {    	non-compiled	[CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	38	None	replace
239	[BUG]  [BUGGY]  for(int  i  =  1;  --i  ==  0;  --i)  {  [CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  --i  ==  0;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  --i  ==  0;  --i)  {	  for(int    i    =    1;    countdown    >=    0;    --i)    {    	non-compiled	[CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	38	None	replace
240	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    <    0;    --countdown)    {    for(int  countdown  =  0;  countdown  <  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	18	None	add
241	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  int  countdown  =  0;  countdown  <  0;  --countdown)  {  [CE]  illegal  start  of  type  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  int  countdown  =  0;  countdown  <  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    <    0;    --countdown)    {    int  countdown  =  0;  countdown  <  0;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  type	18	None	add
242	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    <    0;    --countdown)    {    if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }	  	non-compiled	[CE]  illegal  start  of  expression	18	None	add
243	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  For(int  countdown  =  0;  countdown  <  0;  --countdown)  {  [CE]  '.class'  expected  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  For(int  countdown  =  0;  countdown  <  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    <    0;    --countdown)    {    For(int  countdown  =  0;  countdown  <  0;  --countdown)  {	  	non-compiled	[CE]  '.class'  expected	18	None	add
244	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    <    0;    --countdown)    {    Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	18	None	add
245	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    2;    countdown    >>    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	46	None	replace
246	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	4	add
247	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	4	add
248	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	4	add
249	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	4	add
250	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.52e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.52e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	4	add
251	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.52e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.52e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.52e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	4	add
252	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	4	add
253	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	4	add
254	[BUG]  [BUGGY]  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	paru  =  Math.max(2.2252e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	95	None	replace
255	[BUG]  [BUGGY]  paru  =  Math.max(2.0,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	paru  =  Math.max(2.0,  0.001  *  paru);	          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	33	None	replace
256	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);	          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	33	None	replace
257	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(1.0,  Math.min(delta,  0.0)));  [CE]  class,  interface,  or  enum  expected  [FE]                      AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(1.0,  Math.min(delta,  0.0)));  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  Math.max(1.0,  Math.min(delta,  0.0)));	  lmPar    =    Math.max(2.0,    Math.max(2.0,    Math.min(delta,    0.0)));    	non-compiled	[CE]  class,  interface,  or  enum  expected	26	None	replace
258	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(paru,  0.0)));  [CE]  class,  interface,  or  enum  expected  [FE]                        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(paru,  0.0)));  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(paru,  0.0)));	  lmPar    =    Math.max(2.0,    Math.max(2.0,    Math.min(delta,    0.0)));    	non-compiled	[CE]  class,  interface,  or  enum  expected	26	None	replace
259	[BUG]  [BUGGY]  lmPar  =  Math.max(1.0,  Math.max(1.0,  Math.min(delta,  0.0)));  [CE]  class,  interface,  or  enum  expected  [FE]                          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(1.0,  Math.max(1.0,  Math.min(delta,  0.0)));  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(1.0,  Math.max(1.0,  Math.min(delta,  0.0)));	  lmPar    =    Math.max(2.0,    Math.max(2.0,    Math.min(delta,    0.0)));    	non-compiled	[CE]  class,  interface,  or  enum  expected	26	None	replace
260	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
261	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
262	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
263	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
264	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
265	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
266	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
267	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
268	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	44	None	replace
269	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	89	5	add
270	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	89	5	add
271	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	89	5	add
272	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	89	5	add
273	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	89	5	add
274	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	89	5	add
275	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	89	5	add
276	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	89	5	add
277	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        paru    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	97	5	add
278	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        paru    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	97	5	add
279	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        paru    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	97	5	add
280	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        paru    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	97	5	add
281	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        paru    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	97	5	add
282	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        paru    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	97	5	add
283	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        paru    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	97	5	add
284	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        paru    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	97	5	add
285	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru  +  1);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru  +  1);	  double    lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	115	None	replace
286	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  double    lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	115	None	replace
287	[BUG]  [BUGGY]  LmPar  =  Math.max(2.0,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  LmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	LmPar  =  Math.max(2.0,  0.001  *  paru);	          lmPar    =    Math.max(2.0,    0.001    *    paru);    LmPar    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	31	None	replace
288	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
289	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
290	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
291	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
292	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
293	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
294	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
295	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
296	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.6251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.6251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
297	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.6251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.6251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.6251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
298	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    LmPar    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	17	None	replace
299	[BUG]  [BUGGY]  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	paru  =  Math.min(2.2251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
300	[BUG]  [BUGGY]  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
301	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.2253e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.2253e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.2253e-308,  0.001  *  paru);	          double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.max(2.2253e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	118	None	replace
302	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	29	5	add
303	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	29	5	add
304	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    lmPar  =  Math.max(0.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	29	5	add
305	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    lmPar  =  Math.max(0.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	29	5	add
306	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	29	5	add
307	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	29	5	add
308	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [CE]  no  suitable  method  found  for  max(double)  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    lmPar  =  Math.max(0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	non-compiled	[CE]  no  suitable  method  found  for  max(double)	29	None	add
309	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
310	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
311	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
312	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
313	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
314	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
315	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
316	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
317	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	103	None	replace
318	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  countdown;  --i)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  countdown  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  0;  i  <  countdown;  --i)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  0;  i  <  countdown;  --i)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  countdown	107	None	replace
319	[BUG]  [BUGGY]  for(int  lmPar  =  0;  lmPar!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  countdown  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  lmPar  =  0;  lmPar!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  lmPar  =  0;  lmPar!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  countdown	107	None	replace
320	[BUG]  [BUGGY]  for(int  lmPar  =  0;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  countdown  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  lmPar  =  0;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  lmPar  =  0;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  countdown	107	None	replace
321	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    1;    --countdown)    {    for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	20	None	add
322	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown!=  1;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown!=  1;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    1;    --countdown)    {    for(int  countdown  =  0;  countdown!=  1;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	20	None	add
323	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  int  countdown  =  0;  countdown  >=  1;  --countdown)  {  [CE]  not  a  statement  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  int  countdown  =  0;  countdown  >=  1;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    1;    --countdown)    {    int  countdown  =  0;  countdown  >=  1;  --countdown)  {	  	non-compiled	[CE]  not  a  statement	20	None	add
324	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown  >>  1;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown  >>  1;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    1;    --countdown)    {    for(int  countdown  =  0;  countdown  >>  1;  --countdown)  {	  	non-compiled	[CE]  illegal  start  of  expression	20	None	add
325	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  [CE]  '.class'  expected  [FE]            AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    1;    --countdown)    {    For(int  countdown  =  0;  countdown  >=  1;  --countdown)  {	  	non-compiled	[CE]  '.class'  expected	20	None	add
326	[BUG]  [BUGGY]  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.51e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	16	None	replace
327	[BUG]  [BUGGY]  lmPar  =  Math.min(2.52e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.52e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.52e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	16	None	replace
328	[BUG]  [BUGGY]  for(int  i  =  1;  countdown  <  0;  --i)  {  [CE]  cannot  find  symbol  countdown  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  countdown  <  0;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  countdown  <  0;  --i)  {	  for(int    countdown    =    1;    countdown    <    0;    --countdown)    {    	non-compiled	[CE]  cannot  find  symbol  countdown	37	None	replace
329	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  <  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  1;  countdown  <  2;  --countdown)  {	  for(int    countdown    =    1;    countdown    <    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	37	2	replace
330	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  <  2;  --countdown)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  <  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  <  2;  --countdown)  {	  for(int    countdown    =    1;    countdown    <    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	37	2	replace
331	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.0,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.0,  0.001  *  paru  +  1);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.0,  0.001  *  paru  +  1);	  double    lmPar    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	8	None	replace
332	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.2252e-308,.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2252e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	111	None	replace
333	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
334	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
335	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
336	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
337	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
338	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
339	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
340	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
341	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	13	4	add
342	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	13	4	add
343	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	13	4	add
344	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	13	4	add
345	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	13	4	add
346	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	13	4	add
347	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [CE]  no  suitable  method  found  for  min(double,double,double)  [FE]          AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	non-compiled	[CE]  no  suitable  method  found  for  min(double,double,double)	13	None	add
348	[BUG]  [BUGGY]  Double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  Double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	Double  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	          double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    Double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	70	None	replace
349	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    1;    --countdown)    {    Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	20	None	add
350	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    1;    --countdown)    {    if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }	  	non-compiled	[CE]  illegal  start  of  expression	20	None	add
351	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    1;    --countdown)    {    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	20	None	add
352	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
353	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
354	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	6	None	add
355	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    2;    --countdown)    {    Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	58	None	add
356	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown    >=    2;    --countdown)    {    if(lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }	  	non-compiled	[CE]  illegal  start  of  expression	58	None	add
357	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  2;  countdown  <  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  2;  countdown  <  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    <    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	37	15	replace
358	[BUG]  [BUGGY]  for(int  countdown  =  2;  countdown  <  0;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  2;  countdown  <  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  2;  countdown  <  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    <    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	37	15	replace
359	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	87	5	add
360	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	87	5	add
361	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.252e-308,    0.001    *    paru);    LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	87	None	add
362	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }  [CE]  variable  countdown  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    0;    countdown!=    0;    --countdown)    {    	non-compiled	[CE]  variable  countdown  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	40	None	replace
363	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	13	4	add
364	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	13	4	add
365	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }  [CE]  not  a  statement  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	42	None	replace
366	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  =  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  =  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  =  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    <    =    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	117	None	replace
367	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  incompatible  types  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  incompatible  types	100	None	replace
368	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  incompatible  types	100	None	replace
369	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	5	add
370	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	5	add
371	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	3	None	add
372	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	4	add
373	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	3	4	add
374	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
375	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
376	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
377	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
378	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [CE]  no  suitable  method  found  for  max(double)  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);	  	non-compiled	[CE]  no  suitable  method  found  for  max(double)	32	None	add
379	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    1;    countdown!=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	74	None	replace
380	[BUG]  [BUGGY]  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.0251e-308,  0.001  *  paru);	  lmPar    =    Math.min(2.0e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	101	None	replace
381	[BUG]  [BUGGY]  lmPar  =  Math.min(2.0e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.0e-308,  0.001  *  paru  +  1);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.0e-308,  0.001  *  paru  +  1);	  lmPar    =    Math.min(2.0e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	101	None	replace
382	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.0252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.0252e-308,  0.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	95	None	replace
383	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	5	add
384	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	5	add
385	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	1	None	add
386	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	4	add
387	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	1	4	add
388	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
389	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
390	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        paru    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	97	5	add
391	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        paru    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	97	5	add
392	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	103	None	replace
393	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	43	None	replace
394	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  incompatible  types  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  incompatible  types	107	None	replace
395	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  incompatible  types  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  incompatible  types	107	None	replace
396	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	62	None	add
397	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	62	5	add
398	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	62	5	add
399	[BUG]  [BUGGY]  For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	For(int  countdown  =  2;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	48	None	replace
400	[BUG]  [BUGGY]  lmPar  =  Math.min(2.0,  0.001  *  paru  +  2);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.0,  0.001  *  paru  +  2);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.0,  0.001  *  paru  +  2);	  lmPar    =    Math.min(2.0,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	112	None	replace
401	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	77	None	replace
402	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
403	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
404	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
405	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	49	5	add
406	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
407	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
408	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
409	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
410	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	83	None	add
411	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	83	5	add
412	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        paru    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	83	5	add
413	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [CE]  no  suitable  method  found  for  max(double)  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	non-compiled	[CE]  no  suitable  method  found  for  max(double)	27	None	add
414	[BUG]  [BUGGY]  for(int  i  =  1;  countdown!=  0;  --i)  {  [CE]  cannot  find  symbol  countdown  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  countdown!=  0;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  countdown!=  0;  --i)  {	  for(int    i    =    1;    countdown    >=    0;    --i)    {    	non-compiled	[CE]  cannot  find  symbol  countdown	38	None	replace
415	[BUG]  [BUGGY]  for(int  i  =  1;  countdown  >>  0;  --i)  {  [CE]  cannot  find  symbol  countdown  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  countdown  >>  0;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  countdown  >>  0;  --i)  {	  for(int    i    =    1;    countdown    >=    0;    --i)    {    	non-compiled	[CE]  cannot  find  symbol  countdown	38	None	replace
416	[BUG]  [BUGGY]  double  lmPar  =  Math.sqrt(param);  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.sqrt(param);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.sqrt(param);	  double    lmPar    =    Math.sqrt(paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	109	None	replace
417	[BUG]  [BUGGY]  LmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  LmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	LmPar  =  Math.min(2.252e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    LmPar    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	17	None	replace
418	[BUG]  [BUGGY]  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	LmPar  =  Math.min(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    LmPar    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	17	None	replace
419	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	78	None	add
420	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	78	5	add
421	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	78	5	add
422	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	78	5	add
423	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	78	5	add
424	[BUG]  [BUGGY]  lmPar  =  Math.min(2.0,  0.001  *  paru);  paru  =  Math.min(2.0,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.0,  0.001  *  paru);  paru  =  Math.min(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.0,  0.001  *  paru);  paru  =  Math.min(2.0,  0.001  *  paru);	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	7	None	replace
425	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	85	None	add
426	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	85	5	add
427	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	85	5	add
428	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.2252e-308,  0.001  *  gNorm);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.2252e-308,  0.001  *  gNorm);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.2252e-308,  0.001  *  gNorm);	  double    lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	115	None	replace
429	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    0;    countdown!=    0;    --countdown)    {    Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	22	None	add
430	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	76	None	replace
431	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru  +  1);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.0251e-308,  0.001  *  paru  +  1);	  double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  class,  interface,  or  enum  expected	10	None	replace
432	[BUG]  [BUGGY]  lmPar  =  Math.sqrt(lmPar);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.sqrt(lmPar);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.sqrt(lmPar);	  lmPar    =    Math.sqrt(paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	108	None	replace
433	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    LmPar  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	80	None	add
434	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	80	5	add
435	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.0252e-308,    0.001    *    paru);    paru  =  Math.max(2.0251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	80	5	add
436	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.01,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    lmPar  =  Math.max(0.01,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	29	5	add
437	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.01,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.01,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    lmPar  =  Math.max(0.01,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	29	5	add
438	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }  [CE]  variable  countdown  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  variable  countdown  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	73	None	replace
439	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
440	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	53	5	add
441	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	60	None	add
442	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
443	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
444	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.0e-308,  0.001  *  paru);	  double    lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	9	None	replace
445	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  ==  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown  ==  0;  --countdown)  {	  for(int    countdown    =    0;    countdown!=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	23	5	replace
446	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  ==  0;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  ==  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  ==  0;  --countdown)  {	  for(int    countdown    =    0;    countdown!=    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	23	5	replace
447	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  3;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown  >=  3;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    2;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	59	15	replace
448	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  3;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  3;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  3;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    2;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	59	15	replace
449	[BUG]  [BUGGY]  lmPar  =  Math.max(2.251e-308,  0.001);  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.251e-308,  0.001);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.251e-308,  0.001);	  lmPar    =    Math.max(2.2251e-308,    0.001);    	non-compiled	[CE]  class,  interface,  or  enum  expected	25	None	replace
450	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(delta,  1.0)));  [CE]  class,  interface,  or  enum  expected  [FE]                      AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(delta,  1.0)));  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(delta,  1.0)));	  lmPar    =    Math.max(2.0,    Math.max(2.0,    Math.min(delta,    0.0)));    	non-compiled	[CE]  class,  interface,  or  enum  expected	26	None	replace
451	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(delta,  0.1)));  [CE]  class,  interface,  or  enum  expected  [FE]                        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(delta,  0.1)));  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  Math.max(2.0,  Math.min(delta,  0.1)));	  lmPar    =    Math.max(2.0,    Math.max(2.0,    Math.min(delta,    0.0)));    	non-compiled	[CE]  class,  interface,  or  enum  expected	26	None	replace
452	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown!=  0;  --countdown)  {  int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int    countdown    =    1;    countdown!=    0;    --countdown)    {    int  countdown  =  1;  countdown  >=  0;  --countdown)  {	  	non-compiled	[CE]  not  a  statement	34	None	add
453	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	64	5	add
454	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	64	5	add
455	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.251e-308,    0.001    *    paru);    LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	64	None	add
456	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	110	5	add
457	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	110	5	add
458	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,.001  *  paru);  LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2252e-308,.001    *    paru);    LmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	110	None	add
459	[BUG]  [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  not  a  statement  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	47	None	replace
460	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }  [CE]  variable  countdown  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  variable  countdown  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	39	None	replace
461	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
462	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.7251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.7251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	55	5	add
463	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	103	None	replace
464	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  paru  =  Math.min(2.253e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  paru  =  Math.min(2.253e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
465	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  paru  =  Math.min(2.253e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  paru  =  Math.min(2.253e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  paru  =  Math.min(2.253e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
466	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
467	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	102	4	add
468	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    lmPar  =  Math.max(0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	29	5	add
469	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(2.0,.001  *  paru);  lmPar  =  Math.max(0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        lmPar    =    Math.max(2.0,.001    *    paru);    lmPar  =  Math.max(0.001,  0.001  *  paru);  lmPar  =  Math.max(2.0,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	29	5	add
470	[BUG]  [BUGGY]  for(int  i  =  1;  --i  >  0;  --i)  {  [CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  --i  >  0;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  --i  >  0;  --i)  {	  for(int    i    =    1;    countdown    >=    0;    --i)    {    	non-compiled	[CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	38	None	replace
471	[BUG]  [BUGGY]  for(int  i  =  1;  --i  <  0;  --i)  {  [CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  --i  <  0;  --i)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  --i  <  0;  --i)  {	  for(int    i    =    1;    countdown    >=    0;    --i)    {    	non-compiled	[CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	38	None	replace
472	[BUG]  [BUGGY]  lmPar  =  Math.max(2.252e-308,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.252e-308,.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.252e-308,.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    lmPar    =    Math.max(2.2252e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	111	None	replace
473	[BUG]  [BUGGY]  For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	For(int  countdown  =  1;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	77	None	replace
474	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
475	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
476	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.0252e-308,  0.001  *  paru);	          double    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.max(2.0251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	71	None	replace
477	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
478	[BUG]  [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.3251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.3251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.3252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	51	5	add
479	[BUG]  [BUGGY]  for(int  i  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  countdown  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  i  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  i  =  1;  countdown  >=  0;  --countdown)  {  Integer  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    Integer    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  cannot  find  symbol  countdown	100	None	replace
480	[BUG]  [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }  [CE]  not  a  statement  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  1;  countdown  >=  0;  --countdown)  {  int  countdown  =  0;  countdown  >=  0;  --countdown)  {  }	  for(int    countdown    =    1;    countdown    >=    0;    --countdown)    {    int    countdown    =    1;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  not  a  statement	76	None	replace
481	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.001,  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,  0.001,  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  0.001,  paru);	          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	28	None	replace
482	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.001  +  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,  0.001  +  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  0.001  +  paru);	          lmPar    =    Math.max(2.0,    0.001    *    paru);    lmPar    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	28	None	replace
483	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
484	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	11	4	add
485	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  4;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown  <  4;  --countdown)  {	  for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	114	2	replace
486	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  4;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  4;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  4;  --countdown)  {	  for(int    countdown    =    0;    countdown    <    2;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	114	2	replace
487	[BUG]  [BUGGY]  double  lmPar  =  Math.max(2.2252e-308,  0.001  *  lmPar);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  double  lmPar  =  Math.max(2.2252e-308,  0.001  *  lmPar);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	double  lmPar  =  Math.max(2.2252e-308,  0.001  *  lmPar);	  double    lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	115	None	replace
488	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [CE]  '.class'  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  2;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  2;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  2;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	43	None	replace
489	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  paru  +  3);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  paru  +  3);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(2.0,  0.001  *  paru  +  3);	  lmPar    =    Math.max(2.0,    0.001    *    paru    +    1);    	non-compiled	[CE]  class,  interface,  or  enum  expected	104	None	replace
490	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
491	[BUG]  [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.3251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	60	5	add
492	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	13	4	add
493	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	13	4	add
494	[BUG]  [BUGGY]  (lmPar  =  Math.max(2.0,  0.001  *  paru));  [CE]  not  a  statement  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  (lmPar  =  Math.max(2.0,  0.001  *  paru));  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	(lmPar  =  Math.max(2.0,  0.001  *  paru));	          lmPar    =    Math.max(2.0,    0.001    *    paru);    (lmPar    =    Math.max(2.0,    0.001    *    paru);    	non-compiled	[CE]  not  a  statement	105	None	replace
495	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.001,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(0.001,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	32	5	add
496	[BUG]  [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.001,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.max(2.0,    0.001    *    paru);    paru  =  Math.max(2.0,  0.001  *  paru);  lmPar  =  Math.max(0.001,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.max(2.0,        0.001        *        paru);        paru    =    Math.max(2.0,    0.001    *    paru);    lmPar  =  Math.max(0.001,  0.001  *  paru);  paru  =  Math.max(2.0,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	32	5	add
497	[BUG]  [BUGGY]  lmPar  =  Math.sqrt(paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.sqrt(paru  +  1);  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.sqrt(paru  +  1);	  lmPar    =    Math.sqrt(paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	108	None	replace
498	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  10;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	for(int  countdown  =  0;  countdown  <  10;  --countdown)  {	  for(int    countdown    =    0;    countdown    <    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	19	2	replace
499	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  <  10;  --countdown)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  <  10;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  <  10;  --countdown)  {	  for(int    countdown    =    0;    countdown    <    0;    --countdown)    {    	compilable	  [FE]  AssertionFailedError  	19	2	replace
500	[BUG]  [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(1.0,  Math.min(delta,  0.0)));  [CE]  class,  interface,  or  enum  expected  [FE]                      AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.max(0.0,  Math.max(1.0,  Math.min(delta,  0.0)));  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.max(0.0,  Math.max(1.0,  Math.min(delta,  0.0)));	  lmPar    =    Math.max(2.0,    Math.max(2.0,    Math.min(delta,    0.0)));    	non-compiled	[CE]  class,  interface,  or  enum  expected	26	None	replace
501	[BUG]  [BUGGY]  LmPar  =  Math.max(2.2252e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  LmPar  =  Math.max(2.2252e-3,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	LmPar  =  Math.max(2.2252e-3,  0.001  *  paru);	          lmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    LmPar    =    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	91	None	replace
502	[BUG]  [BUGGY]  lmPar  =  Math.min(2.5251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.5251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.5251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	16	None	replace
503	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  no  suitable  method  found  for  min(double,double,double)  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  no  suitable  method  found  for  min(double,double,double)	1	None	add
504	[BUG]  [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  0;  countdown  >=  1;  --countdown)  {  for(int  countdown  =  0;  countdown!=  0;  --countdown)  {	  for(int    countdown    =    0;    countdown    >=    0;    --countdown)    {    for(int    countdown    =    0;    countdown!=    0;    --countdown)    {    	non-compiled	[CE]  illegal  start  of  expression	40	None	replace
505	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	5	add
506	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.51e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	5	add
507	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.55e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.55e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	4	add
508	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.55e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.55e-308,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.51e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.55e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	15	4	add
509	[BUG]  [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [CE]  '.class'  expected  [FE]                AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {  [BUGGY]        if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	for(int  countdown  =  2;  countdown  >=  0;  --countdown)  {  For(int  countdown  =  0;  countdown  >=  0;  --countdown)  {	  for(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    For(int    countdown    =    2;    countdown    >=    0;    --countdown)    {    	non-compiled	[CE]  '.class'  expected	48	None	replace
510	[BUG]  [BUGGY]  lmPar  =  Math.min(2.0,  0.001,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }      [BUGGY]  lmPar  =  Math.min(2.0,  0.001,  0.001  *  paru);  [BUGGY]      for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	573	573	2	replace	lmPar  =  Math.min(2.0,  0.001,  0.001  *  paru);	  lmPar    =    Math.min(2.0,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	112	None	replace
