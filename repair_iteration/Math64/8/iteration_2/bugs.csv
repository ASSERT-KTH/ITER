bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  for(int  i  =  0;  i  <  pj;  ++i)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  for(int  i  =  0;  i  <  pj;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    pj;    ++i)    {    for(int  i  =  0;  i  <  pj;  ++i)  {	  	non-compiled	[CE]  illegal  start  of  expression	6	None	add
2	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  For(int  i  =  0;  i  <  pj;  ++i)  {  [CE]  '.class'  expected  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  For(int  i  =  0;  i  <  pj;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    pj;    ++i)    {    For(int  i  =  0;  i  <  pj;  ++i)  {	  	non-compiled	[CE]  '.class'  expected	6	None	add
3	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  int  i  =  0;  i  <  pj;  ++i)  {  [CE]  >  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  int  i  =  0;  i  <  pj;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    pj;    ++i)    {    int  i  =  0;  i  <  pj;  ++i)  {	  	non-compiled	[CE]  >  expected	6	None	add
4	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  FOR(int  i  =  0;  i  <  pj;  ++i)  {  [CE]  '.class'  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  FOR(int  i  =  0;  i  <  pj;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    pj;    ++i)    {    FOR(int  i  =  0;  i  <  pj;  ++i)  {	  	non-compiled	[CE]  '.class'  expected	6	None	add
5	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
6	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work3;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work3;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work3;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
7	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
8	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  [CE]  illegal  start  of  expression  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    j    <    solvedCols;    ++i)    {    for(int  i  =  0;  j  <  solvedCols;  ++i)  {	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
9	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  For(int  i  =  0;  j  <  solvedCols;  ++i)  {  [CE]  '.class'  expected  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  For(int  i  =  0;  j  <  solvedCols;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    j    <    solvedCols;    ++i)    {    For(int  i  =  0;  j  <  solvedCols;  ++i)  {	  	non-compiled	[CE]  '.class'  expected	8	None	add
10	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  for(int  i  =  0;  j  <  solveCols;  ++i)  {  [CE]  illegal  start  of  expression  [FE]        ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  for(int  i  =  0;  j  <  solveCols;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    j    <    solvedCols;    ++i)    {    for(int  i  =  0;  j  <  solveCols;  ++i)  {	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
11	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  int  i  =  0;  j  <  solvedCols;  ++i)  {  [CE]  >  expected  [FE]          ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  int  i  =  0;  j  <  solvedCols;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    j    <    solvedCols;    ++i)    {    int  i  =  0;  j  <  solvedCols;  ++i)  {	  	non-compiled	[CE]  >  expected	8	None	add
12	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work2[j]  *  work1[j]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work2[j]  *  work1[j]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work2[j]  *  work1[j]  /  dxNorm;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    work1[j]    *    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
13	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  parl;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  parl;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  parl;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    work1[j]    *    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
14	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  total;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  total;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  total;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    work1[j]    *    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
15	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  <identifier>  expected	23	None	replace
16	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  sum2[pj];  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  sum2[pj];  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  sum2[pj];	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  <identifier>  expected	23	None	replace
17	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  jacobian[pj];  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  jacobian[pj];  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  jacobian[pj];	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  <identifier>  expected	23	None	replace
18	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  sum;  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  sum;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  sum;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  <identifier>  expected	23	None	replace
19	[BUG]  [BUGGY]  sum2  +=  work1[pj]  *  dxNorm;  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  sum2  +=  work1[pj]  *  dxNorm;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	sum2  +=  work1[pj]  *  dxNorm;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum2    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	25	None	replace
20	[BUG]  [BUGGY]  sum2  +=  work1[pj]  *  s;  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  sum2  +=  work1[pj]  *  s;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	sum2  +=  work1[pj]  *  s;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum2    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	25	None	replace
21	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  dxNorm[pj];  sum2  +=  s  *  s;  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  dxNorm[pj];  sum2  +=  s  *  s;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  dxNorm[pj];  sum2  +=  s  *  s;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum2    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	25	None	replace
22	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  dxNorm;  sum2  +=  s  *  s;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  dxNorm;  sum2  +=  s  *  s;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  dxNorm;  sum2  +=  s  *  s;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum2    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	25	None	replace
23	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(sum);	      double    diagR[pj]    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  ']'  expected	13	None	replace
24	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.log(rank);  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.log(rank);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.log(rank);	      double    diagR[pj]    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  ']'  expected	13	None	replace
25	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  r.length;  ++i)  {  [CE]  cannot  find  symbol  r  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  r.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  r.length;  ++i)  {	  for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    	non-compiled	[CE]  cannot  find  symbol  r	20	None	replace
26	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  number;  ++i)  {  [CE]  cannot  find  symbol  number  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  number;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  number;  ++i)  {	  for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    	non-compiled	[CE]  cannot  find  symbol  number	20	None	replace
27	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  dxNorm.length;  ++i)  {  [CE]  double  cannot  be  dereferenced  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  dxNorm.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  dxNorm.length;  ++i)  {	  for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    	non-compiled	[CE]  double  cannot  be  dereferenced	20	None	replace
28	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {	  for(int    i    =    0;    j    <    solvedCols;    ++i)    {    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	9	None	replace
29	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  foundCols;  ++i)  {  [CE]  cannot  find  symbol  foundCols  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  foundCols;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  j  <  foundCols;  ++i)  {	  for(int    i    =    0;    j    <    solvedCols;    ++i)    {    	non-compiled	[CE]  cannot  find  symbol  foundCols	9	None	replace
30	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[pj]  *  work2[pj]  +  sum);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =  Math.abs(work1[pj]  *  work2[pj]  +  sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =  Math.abs(work1[pj]  *  work2[pj]  +  sum);	      double    s    =    Math.abs(work1[pj]    *    work2[pj]);    	non-compiled	[CE]  <identifier>  expected	26	None	replace
31	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[pj]  *  work3[pj]);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =  Math.abs(work1[pj]  *  work3[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =  Math.abs(work1[pj]  *  work3[pj]);	      double    s    =    Math.abs(work1[pj]    *    work2[pj]);    	non-compiled	[CE]  <identifier>  expected	26	None	replace
32	[BUG]  [BUGGY]  double  s  =  Math.abs(diagR[pj]  *  work2[pj]);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =  Math.abs(diagR[pj]  *  work2[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =  Math.abs(diagR[pj]  *  work2[pj]);	      double    s    =    Math.abs(work1[pj]    *    work2[pj]);    	non-compiled	[CE]  <identifier>  expected	26	None	replace
33	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  sum;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  sum;  ++i)  {	  for(int    i    =    0;    i    <    ns;    ++i)    {    	compilable	  [FE]  AssertionFailedError  	22	13	replace
34	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  sum;  ++i)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  sum;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  sum;  ++i)  {	  for(int    i    =    0;    i    <    ns;    ++i)    {    	compilable	  [FE]  AssertionFailedError  	22	13	replace
35	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  countdown;  ++i)  {  [CE]  cannot  find  symbol  countdown  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  countdown;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  countdown;  ++i)  {	  for(int    i    =    0;    i    <    ns;    ++i)    {    	non-compiled	[CE]  cannot  find  symbol  countdown	22	None	replace
36	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj]  *  sum2);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj]  *  sum2);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj]  *  sum2);	      double    s    =(work1[pj]    -    work1[pj]    *    diagR[pj]);    	non-compiled	[CE]  <identifier>  expected	24	None	replace
37	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj]  *  sum2[pj]);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj]  *  sum2[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj]  *  sum2[pj]);	      double    s    =(work1[pj]    -    work1[pj]    *    diagR[pj]);    	non-compiled	[CE]  <identifier>  expected	24	None	replace
38	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work2[pj]  *  diagR[pj]);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work2[pj]  *  diagR[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work2[pj]  *  diagR[pj]);	      double    s    =(work1[pj]    -    work1[pj]    *    diagR[pj]);    	non-compiled	[CE]  <identifier>  expected	24	None	replace
39	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    diagR.length;    ++i)    {    for(int  i  =  0;  i  <  diagR.length;  ++i)  {	  	non-compiled	[CE]  illegal  start  of  expression	17	None	add
40	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  For(int  i  =  0;  i  <  diagR.length;  ++i)  {  [CE]  '.class'  expected  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  For(int  i  =  0;  i  <  diagR.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    diagR.length;    ++i)    {    For(int  i  =  0;  i  <  diagR.length;  ++i)  {	  	non-compiled	[CE]  '.class'  expected	17	None	add
41	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  int  i  =  0;  i  <  diagR.length;  ++i)  {  [CE]  >  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  int  i  =  0;  i  <  diagR.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    diagR.length;    ++i)    {    int  i  =  0;  i  <  diagR.length;  ++i)  {	  	non-compiled	[CE]  >  expected	17	None	add
42	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  FOR(int  i  =  0;  i  <  diagR.length;  ++i)  {  [CE]  '.class'  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  FOR(int  i  =  0;  i  <  diagR.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    diagR.length;    ++i)    {    FOR(int  i  =  0;  i  <  diagR.length;  ++i)  {	  	non-compiled	[CE]  '.class'  expected	17	None	add
43	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[i][pj]  *  dxNorm;  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[i][pj]  *  dxNorm;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[i][pj]  *  dxNorm;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	27	None	replace
44	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[i][pj]  *  s;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[i][pj]  *  s;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[i][pj]  *  s;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	27	None	replace
45	[BUG]  [BUGGY]  sum  +=  work1[pj]  *  dxNorm;  [CE]  <identifier>  expected  [FE]                    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  sum  +=  work1[pj]  *  dxNorm;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	sum  +=  work1[pj]  *  dxNorm;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	27	None	replace
46	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  dxNorm[pj];  sum  +=  s  *  s;  [CE]  <identifier>  expected  [FE]                      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  dxNorm[pj];  sum  +=  s  *  s;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  dxNorm[pj];  sum  +=  s  *  s;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	27	None	replace
47	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work1[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
48	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work2;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work2;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work2;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work1[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
49	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work1[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
50	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work1.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work1[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
51	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum  *  solvedCols);  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum  *  solvedCols);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(sum  *  solvedCols);	      double    diagR[pj]    =    Math.sqrt(solvedCols    *    sum);    	non-compiled	[CE]  ']'  expected	16	None	replace
52	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(rank  *  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(rank  *  sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(rank  *  sum);	      double    diagR[pj]    =    Math.sqrt(solvedCols    *    sum);    	non-compiled	[CE]  ']'  expected	16	None	replace
53	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols  *  sum,  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols  *  sum,  sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(solvedCols  *  sum,  sum);	      double    diagR[pj]    =    Math.sqrt(solvedCols    *    sum);    	non-compiled	[CE]  ']'  expected	16	None	replace
54	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(diag[j]  *  work1[j]);  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(diag[j]  *  work1[j]);  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(diag[j]  *  work1[j]);  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    Math.abs(work1[j]    *    Math.abs(diag[j]));    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
55	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    Math.abs(work1[j]    *    Math.abs(diag[j]));    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
56	[BUG]  [BUGGY]  For(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [CE]  '.class'  expected  [FE]                    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  For(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	For(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    Math.abs(work1[j]    *    Math.abs(diag[j]));    }    	non-compiled	[CE]  '.class'  expected	5	None	replace
57	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj]);  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[pj]);	      double    diagR[pj]    =    Math.sqrt(rank);    	non-compiled	[CE]  ']'  expected	14	None	replace
58	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[pj]);  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(work1[pj]);	      double    diagR[pj]    =    Math.sqrt(rank);    	non-compiled	[CE]  ']'  expected	14	None	replace
59	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(tab);  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(tab);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(tab);	      double    diagR[pj]    =    Math.sqrt(rank);    	non-compiled	[CE]  ']'  expected	14	None	replace
60	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work1[i]);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  Math.abs(work1[i]);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	11	11	replace
61	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work1[i]);  ++i)  {  [FE]  ArrayIndexOutOfBoundsException  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work1[i]);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.abs(work1[i]);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	11	11	replace
62	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work1.length);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  Math.abs(work1.length);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	compilable	  [FE]  AssertionFailedError  	11	6	replace
63	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work1.length);  ++i)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work1.length);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.abs(work1.length);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	compilable	  [FE]  AssertionFailedError  	11	6	replace
64	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(pj);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  Math.abs(pj);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	compilable	  [FE]  AssertionFailedError  	11	6	replace
65	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(pj);  ++i)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(pj);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.abs(pj);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	compilable	  [FE]  AssertionFailedError  	11	6	replace
66	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(parl);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  Math.abs(parl);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	compilable	  [FE]  AssertionFailedError  	11	13	replace
67	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(parl);  ++i)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(parl);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.abs(parl);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	compilable	  [FE]  AssertionFailedError  	11	13	replace
68	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum,  solvedCols);  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum,  solvedCols);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(sum,  solvedCols);	      double    diagR[pj]    =    Math.sqrt(solvedCols,    sum2);    	non-compiled	[CE]  ']'  expected	15	None	replace
69	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(rank,  sum2);  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(rank,  sum2);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(rank,  sum2);	      double    diagR[pj]    =    Math.sqrt(solvedCols,    sum2);    	non-compiled	[CE]  ']'  expected	15	None	replace
70	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(rank,  sum);  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(rank,  sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(rank,  sum);	      double    diagR[pj]    =    Math.sqrt(solvedCols,    sum);    	non-compiled	[CE]  ']'  expected	12	None	replace
71	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols,  sum  +  1);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols,  sum  +  1);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(solvedCols,  sum  +  1);	      double    diagR[pj]    =    Math.sqrt(solvedCols,    sum);    	non-compiled	[CE]  ']'  expected	12	None	replace
72	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work1.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  work1.length;  ++i)  {	  for(int    i    =    0;    i    <    diagR.length;    ++i)    {    	compilable	  [FE]  AssertionFailedError  	18	6	replace
73	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work1.length;  ++i)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work1.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work1.length;  ++i)  {	  for(int    i    =    0;    i    <    diagR.length;    ++i)    {    	compilable	  [FE]  AssertionFailedError  	18	6	replace
74	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work2.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  work2.length;  ++i)  {	  for(int    i    =    0;    i    <    diagR.length;    ++i)    {    	compilable	  [FE]  AssertionFailedError  	18	6	replace
75	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work2.length;  ++i)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work2.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work2.length;  ++i)  {	  for(int    i    =    0;    i    <    diagR.length;    ++i)    {    	compilable	  [FE]  AssertionFailedError  	18	6	replace
76	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  permutation.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  permutation.length;  ++i)  {	  for(int    i    =    0;    i    <    diagR.length;    ++i)    {    	compilable	  [FE]  AssertionFailedError  	18	6	replace
77	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  permutation.length;  ++i)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  permutation.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  permutation.length;  ++i)  {	  for(int    i    =    0;    i    <    diagR.length;    ++i)    {    	compilable	  [FE]  AssertionFailedError  	18	6	replace
78	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  works.length;  ++i)  {  [CE]  cannot  find  symbol  works  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  works.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  works.length;  ++i)  {	  for(int    i    =    0;    i    <    diagR.length;    ++i)    {    	non-compiled	[CE]  cannot  find  symbol  works	18	None	replace
79	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work2;  ++i)  {  [CE]  bad  operand  types  for  binary  operator  '<'  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work2;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work2;  ++i)  {	  for(int    i    =    0;    i    <    pj;    ++i)    {    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '<'	7	None	replace
80	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {	  	non-compiled	[CE]  illegal  start  of  expression	19	None	add
81	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  For(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [CE]  '.class'  expected  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  For(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    For(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {	  	non-compiled	[CE]  '.class'  expected	19	None	add
82	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [CE]  >  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {	  	non-compiled	[CE]  >  expected	19	None	add
83	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[pj]  /  dxNorm;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[j]    *=    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
84	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[j]  /  total;  }  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[j]  /  total;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[j]  /  total;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[j]    *=    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
85	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[j]  /  permutation[j];  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[j]  /  permutation[j];  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[j]  /  permutation[j];  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[j]    *=    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
86	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {	  	non-compiled	[CE]  illegal  start  of  expression	10	None	add
87	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  For(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [CE]  '.class'  expected  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  For(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    For(int  i  =  0;  i  <  Math.abs(j);  ++i)  {	  	non-compiled	[CE]  '.class'  expected	10	None	add
88	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [CE]  >  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    int  i  =  0;  i  <  Math.abs(j);  ++i)  {	  	non-compiled	[CE]  >  expected	10	None	add
89	[BUG]  [BUGGY]  double  s  =  Math.abs(work2[pj]  *  work1[pj]);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =  Math.abs(work2[pj]  *  work1[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =  Math.abs(work2[pj]  *  work1[pj]);	      double    s    =    Math.abs(work1[pj]    *    work2[pj]);    	non-compiled	[CE]  <identifier>  expected	26	None	replace
90	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]);  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[0]);	      double    diagR[pj]    =    Math.sqrt(rank);    	non-compiled	[CE]  ']'  expected	14	None	replace
91	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue());  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue());  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue());	      double    diagR[pj]    =    Math.sqrt(rank);    	non-compiled	[CE]  ']'  expected	14	None	replace
92	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR);  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(diagR);	      double    diagR[pj]    =    Math.sqrt(rank);    	non-compiled	[CE]  ']'  expected	14	None	replace
93	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  (int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  (int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    (int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {	  	non-compiled	[CE]  ')'  expected	19	None	add
94	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  (int  i  =  0;  i  <  diagR.length;  ++i)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  (int  i  =  0;  i  <  diagR.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    diagR.length;    ++i)    {    (int  i  =  0;  i  <  diagR.length;  ++i)  {	  	non-compiled	[CE]  ')'  expected	17	None	add
95	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work2.length);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  Math.abs(work2.length);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	compilable	  [FE]  AssertionFailedError  	11	6	replace
96	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work2.length);  ++i)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work2.length);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.abs(work2.length);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	compilable	  [FE]  AssertionFailedError  	11	6	replace
97	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diag[pj];  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diag[pj];  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  diag[pj];	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    	non-compiled	[CE]  <identifier>  expected	23	None	replace
98	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  dxNorm;  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  dxNorm;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  dxNorm;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum2    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	25	None	replace
99	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1)/  diagR[pj];  sum2  +=  s  *  dxNorm;  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1)/  diagR[pj];  sum2  +=  s  *  dxNorm;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1)/  diagR[pj];  sum2  +=  s  *  dxNorm;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum2    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	25	None	replace
100	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  qy;  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  qy;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  qy;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum2    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	25	None	replace
101	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  foundCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  foundCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  foundCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[j]    *=    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
102	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvesCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvesCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvesCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[j]    *=    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
103	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvesCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvesCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvesCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    Math.abs(work1[j]    *    Math.abs(diag[j]));    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
104	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(work2[j]  *  Math.abs(diag[j]));  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(work2[j]  *  Math.abs(diag[j]));  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(work2[j]  *  Math.abs(diag[j]));  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    Math.abs(work1[j]    *    Math.abs(diag[j]));    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
105	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  work2.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  work2.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  j  <  work2.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work1[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
106	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  work2;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  work2;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  j  <  work2;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work1[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
107	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  (int  i  =  0;  i  <  pj;  ++i)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  (int  i  =  0;  i  <  pj;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    pj;    ++i)    {    (int  i  =  0;  i  <  pj;  ++i)  {	  	non-compiled	[CE]  ')'  expected	6	None	add
108	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  if(int  i  =  0;  i  <  pj;  ++i)  {  [CE]  '.class'  expected  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  if(int  i  =  0;  i  <  pj;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    pj;    ++i)    {    if(int  i  =  0;  i  <  pj;  ++i)  {	  	non-compiled	[CE]  '.class'  expected	6	None	add
109	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  diagR.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  j  <  diagR.length;  ++i)  {	  for(int    i    =    0;    j    <    solvedCols;    ++i)    {    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	9	13	replace
110	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  diagR.length;  ++i)  {  [FE]  ArrayIndexOutOfBoundsException  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  diagR.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  j  <  diagR.length;  ++i)  {	  for(int    i    =    0;    j    <    solvedCols;    ++i)    {    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	9	13	replace
111	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  ratio;  ++i)  {  [CE]  cannot  find  symbol  ratio  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  ratio;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  ratio;  ++i)  {	  for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    	non-compiled	[CE]  cannot  find  symbol  ratio	20	None	replace
112	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.min(work1.length,  work2.length));  ++i)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.min(work1.length,  work2.length));  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.min(work1.length,  work2.length));  ++i)  {	  for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    	non-compiled	[CE]  ';'  expected	20	None	replace
113	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR  *  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR  *  sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(diagR  *  sum);	      double    diagR[pj]    =    Math.sqrt(solvedCols    *    sum);    	non-compiled	[CE]  ']'  expected	16	None	replace
114	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(log  *  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(log  *  sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(log  *  sum);	      double    diagR[pj]    =    Math.sqrt(solvedCols    *    sum);    	non-compiled	[CE]  ']'  expected	16	None	replace
115	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvesCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  solvesCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  solvesCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    work1[j]    *    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
116	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  jacobian.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  jacobian.length;  ++i)  {	  for(int    i    =    0;    i    <    n;    ++i)    {    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	21	10	replace
117	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  jacobian.length;  ++i)  {  [FE]  ArrayIndexOutOfBoundsException  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  jacobian.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  jacobian.length;  ++i)  {	  for(int    i    =    0;    i    <    n;    ++i)    {    	compilable	  [FE]  ArrayIndexOutOfBoundsException  	21	10	replace
118	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum2,  solvedCols);  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum2,  solvedCols);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(sum2,  solvedCols);	      double    diagR[pj]    =    Math.sqrt(solvedCols,    sum2);    	non-compiled	[CE]  ']'  expected	15	None	replace
119	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR,  sum2);  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR,  sum2);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(diagR,  sum2);	      double    diagR[pj]    =    Math.sqrt(solvedCols,    sum2);    	non-compiled	[CE]  ']'  expected	15	None	replace
120	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  (int  i  =  0;  j  <  solvedCols;  ++i)  {  [CE]  ')'  expected  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  (int  i  =  0;  j  <  solvedCols;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    j    <    solvedCols;    ++i)    {    (int  i  =  0;  j  <  solvedCols;  ++i)  {	  	non-compiled	[CE]  ')'  expected	8	None	add
121	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  if(i  =  0;  j  <  solvedCols;  ++i)  {  [CE]  ')'  expected  [FE]      ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  if(i  =  0;  j  <  solvedCols;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    j    <    solvedCols;    ++i)    {    if(i  =  0;  j  <  solvedCols;  ++i)  {	  	non-compiled	[CE]  ')'  expected	8	None	add
122	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  (int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [CE]  ')'  expected  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  (int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    (int  i  =  0;  i  <  Math.abs(j);  ++i)  {	  	non-compiled	[CE]  ')'  expected	10	None	add
123	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  for(int  i  =  0;  i  <  Math.abs(je);  ++i)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  for(int  i  =  0;  i  <  Math.abs(je);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    for(int  i  =  0;  i  <  Math.abs(je);  ++i)  {	  	non-compiled	[CE]  illegal  start  of  expression	10	None	add
124	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR,  sum);  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR,  sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(diagR,  sum);	      double    diagR[pj]    =    Math.sqrt(solvedCols,    sum);    	non-compiled	[CE]  ']'  expected	12	None	replace
125	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag,  sum);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag,  sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(diag,  sum);	      double    diagR[pj]    =    Math.sqrt(solvedCols,    sum);    	non-compiled	[CE]  ']'  expected	12	None	replace
126	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
127	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work2.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
128	[BUG]  [BUGGY]  double  s  =(work2[pj]  -  work1[pj]  *  diagR[pj]);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work2[pj]  -  work1[pj]  *  diagR[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work2[pj]  -  work1[pj]  *  diagR[pj]);	      double    s    =(work1[pj]    -    work1[pj]    *    diagR[pj]);    	non-compiled	[CE]  <identifier>  expected	24	None	replace
129	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj]  *  diag[pj]);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj]  *  diag[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj]  *  diag[pj]);	      double    s    =(work1[pj]    -    work1[pj]    *    diagR[pj]);    	non-compiled	[CE]  <identifier>  expected	24	None	replace
130	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];  sum  +=  s  *  s;  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];  sum  +=  s  *  s;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];  sum  +=  s  *  s;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	27	None	replace
131	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];  sum  +=  s  *  dxNorm;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];  sum  +=  s  *  dxNorm;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work2[pj])/  diagR[pj];  sum  +=  s  *  dxNorm;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	27	None	replace
132	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  for(int  i  =  0;  j  <  solvedCOLs;  ++i)  {  [CE]  illegal  start  of  expression  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  for(int  i  =  0;  j  <  solvedCOLs;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    j    <    solvedCols;    ++i)    {    for(int  i  =  0;  j  <  solvedCOLs;  ++i)  {	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
133	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj]  *  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj]  *  sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[pj]  *  sum);	      double    diagR[pj]    =    Math.sqrt(solvedCols    *    sum);    	non-compiled	[CE]  ']'  expected	16	None	replace
134	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols  *  sum2);  [CE]  ']'  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(solvedCols  *  sum2);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(solvedCols  *  sum2);	      double    diagR[pj]    =    Math.sqrt(solvedCols    *    sum);    	non-compiled	[CE]  ']'  expected	16	None	replace
135	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  FOR(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [CE]  '.class'  expected  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  FOR(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    FOR(int  i  =  0;  i  <  Math.abs(j);  ++i)  {	  	non-compiled	[CE]  '.class'  expected	10	None	add
136	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  diagR.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work1[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
137	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  work3.length;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work1[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	2	None	replace
138	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work1,  j);  ++i)  {  [CE]  no  suitable  method  found  for  abs(double[],int)  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work1,  j);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.abs(work1,  j);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	non-compiled	[CE]  no  suitable  method  found  for  abs(double[],int)	11	None	replace
139	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work1,  pj);  ++i)  {  [CE]  no  suitable  method  found  for  abs(double[],int)  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(work1,  pj);  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.abs(work1,  pj);  ++i)  {	  for(int    i    =    0;    i    <    Math.abs(j);    ++i)    {    	non-compiled	[CE]  no  suitable  method  found  for  abs(double[],int)	11	None	replace
140	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  assignments.length;  ++i)  {  [CE]  cannot  find  symbol  assignments  [FE]    ArrayIndexOutOfBoundsException    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  j  <  assignments.length;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  j  <  assignments.length;  ++i)  {	  for(int    i    =    0;    j    <    solvedCols;    ++i)    {    	non-compiled	[CE]  cannot  find  symbol  assignments	9	None	replace
141	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[pj]  *  dxNorm;  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[pj]  *  dxNorm;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[pj]  *  dxNorm;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	27	None	replace
142	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[pj]  *  s;  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[pj]  *  s;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  jacobian[pj]  *  s;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	27	None	replace
143	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1)/  diagR[pj];  sum  +=  jacobian[pj]  *  dxNorm;  [CE]  <identifier>  expected  [FE]                    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1)/  diagR[pj];  sum  +=  jacobian[pj]  *  dxNorm;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1)/  diagR[pj];  sum  +=  jacobian[pj]  *  dxNorm;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	27	None	replace
144	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    Math.abs(work1[j]    *    Math.abs(diag[j]));    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
145	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  problemsCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  problemsCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  problemsCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    Math.abs(work1[j]    *    Math.abs(diag[j]));    }    	non-compiled	[CE]  <identifier>  expected	5	None	replace
146	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diagR.length;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  diagR.length;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  diagR.length;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    work1[j]    *    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
147	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  doneCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  doneCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  doneCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    work1[j]    *    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
148	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  resolvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    work1[j]    *    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	3	None	replace
149	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum1,  sum2);  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum1,  sum2);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(sum1,  sum2);	      double    diagR[pj]    =    Math.sqrt(solvedCols,    sum2);    	non-compiled	[CE]  ']'  expected	15	None	replace
150	[BUG]  [BUGGY]  double  s  =  Math.abs(work1[pj]  *  work2[pj],  sum);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =  Math.abs(work1[pj]  *  work2[pj],  sum);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =  Math.abs(work1[pj]  *  work2[pj],  sum);	      double    s    =    Math.abs(work1[pj]    *    work2[pj]);    	non-compiled	[CE]  <identifier>  expected	26	None	replace
151	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  FOR(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [CE]  '.class'  expected  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  FOR(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    FOR(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {	  	non-compiled	[CE]  '.class'  expected	19	None	add
152	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  double  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [CE]  >  expected  [FE]      AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  double  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    double  i  =  0;  i  <  qrRankingThreshold;  ++i)  {	  	non-compiled	[CE]  >  expected	19	None	add
153	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  diagR.length;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  diagR.length;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  diagR.length;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[j]    *=    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
154	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  doneCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  j  =  0;  j  <  doneCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  j  =  0;  j  <  doneCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }	      for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[j]    *=    work2[j]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	1	None	replace
155	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.min(work1,  pj));  ++i)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.min(work1,  pj));  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.min(work1,  pj));  ++i)  {	  for(int    i    =    0;    i    <    pj;    ++i)    {    	non-compiled	[CE]  ';'  expected	7	None	replace
156	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum2);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum2);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(sum2);	      double    diagR[pj]    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  ']'  expected	13	None	replace
157	[BUG]  [BUGGY]  double  s  =(diagR[pj]  -  work1[pj]  *  work1[pj]);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(diagR[pj]  -  work1[pj]  *  work1[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(diagR[pj]  -  work1[pj]  *  work1[pj]);	      double    s    =(work1[pj]    -    work1[pj]    *    diagR[pj]);    	non-compiled	[CE]  <identifier>  expected	24	None	replace
158	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(rank));  ++i)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  Math.abs(rank));  ++i)  {  [BUGGY]    sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.abs(rank));  ++i)  {	  for(int    i    =    0;    i    <    qrRankingThreshold;    ++i)    {    	non-compiled	[CE]  ';'  expected	20	None	replace
159	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work3[pj]);  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  diagR[pj]  =  Math.sqrt(work3[pj]);  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  diagR[pj]  =  Math.sqrt(work3[pj]);	      double    diagR[pj]    =    Math.sqrt(rank);    	non-compiled	[CE]  ']'  expected	14	None	replace
160	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  jacobian[pj]  *  dxNorm;  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  jacobian[pj]  *  dxNorm;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  jacobian[pj]  *  dxNorm;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum2    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	25	None	replace
161	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  parl;  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  parl;  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  parl;	      double    s    =(work1[pj]    -    work1[pj])/    diagR[pj];    sum2    +=    s    *    s;    	non-compiled	[CE]  <identifier>  expected	25	None	replace
162	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  diagR.length;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
163	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  gNorm;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;    [BUGGY]  for(int  i  =  0;  i  <  gNorm;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [BUGGY]    for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  gNorm;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }	      for(int    i    =    0;    i    <    j;    ++i)    {    sum    +=    work1[i][pj]    *    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  <identifier>  expected	4	None	replace
