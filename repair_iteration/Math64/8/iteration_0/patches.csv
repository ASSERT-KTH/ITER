bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[j]  *=  work2[j]  /  dxNorm;  }		non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
2	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  array  required,  but  double  found  [FE]      AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work1[i][pj]  *  work1[pj]  /  dxNorm;  }		non-compiled	[CE]  array  required,  but  double  found	16	None	add
3	[BUG]  [BUGGY]    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[j]  *  work2[j]  /  dxNorm;  }		non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
4	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [CE]  array  required,  but  double  found  [FE]          AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }		non-compiled	[CE]  array  required,  but  double  found	16	None	add
5	[BUG]  [BUGGY]    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  Math.abs(work1[j]  *  Math.abs(diag[j]));  }		non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
6	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  pj;  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	compilable	  [FE]  AssertionFailedError  	15	6	replace
7	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  pj;  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	compilable	  [FE]  AssertionFailedError  	15	6	replace
8	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]      AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  j  <  solvedCols;  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	compilable	  [FE]  ArrayIndexOutOfBoundsException  	15	13	replace
9	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  [FE]  ArrayIndexOutOfBoundsException  [FE]      AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  j  <  solvedCols;  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	compilable	  [FE]  ArrayIndexOutOfBoundsException  	15	13	replace
10	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	compilable	  [FE]  AssertionFailedError  	15	2	replace
11	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  Math.abs(j);  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	compilable	  [FE]  AssertionFailedError  	15	2	replace
12	[BUG]  [BUGGY]    double  diagR[pj]  =  Math.sqrt(solvedCols,  sum);  [CE]  ']'  expected  [FE]    AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    double  diagR[pj]  =  Math.sqrt(solvedCols,  sum);  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    double  diagR[pj]  =  Math.sqrt(solvedCols,  sum);		non-compiled	[CE]  ']'  expected	16	None	add
13	[BUG]  [BUGGY]    double  diagR[pj]  =  Math.sqrt(solvedCols);  [CE]  ']'  expected  [FE]      AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    double  diagR[pj]  =  Math.sqrt(solvedCols);  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    double  diagR[pj]  =  Math.sqrt(solvedCols);		non-compiled	[CE]  ']'  expected	16	None	add
14	[BUG]  [BUGGY]    double  diagR[pj]  =  Math.sqrt(rank);  [CE]  ']'  expected  [FE]        AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    double  diagR[pj]  =  Math.sqrt(rank);  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    double  diagR[pj]  =  Math.sqrt(rank);		non-compiled	[CE]  ']'  expected	16	None	add
15	[BUG]  [BUGGY]    double  diagR[pj]  =  Math.sqrt(solvedCols,  sum2);  [CE]  ']'  expected  [FE]          AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    double  diagR[pj]  =  Math.sqrt(solvedCols,  sum2);  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    double  diagR[pj]  =  Math.sqrt(solvedCols,  sum2);		non-compiled	[CE]  ']'  expected	16	None	add
16	[BUG]  [BUGGY]    double  diagR[pj]  =  Math.sqrt(solvedCols  *  sum);  [CE]  ']'  expected  [FE]            AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    double  diagR[pj]  =  Math.sqrt(solvedCols  *  sum);  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    double  diagR[pj]  =  Math.sqrt(solvedCols  *  sum);		non-compiled	[CE]  ']'  expected	16	None	add
17	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  diagR.length;  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	compilable	  [FE]  AssertionFailedError  	15	6	replace
18	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  diagR.length;  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	compilable	  [FE]  AssertionFailedError  	15	6	replace
19	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	add	for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	compilable	  [FE]  AssertionFailedError  	15	7	replace
20	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	compilable	  [FE]  AssertionFailedError  	15	7	replace
21	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  n;  ++i)  {  [CE]  cannot  find  symbol  n  [FE]        AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  i  <  n;  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  n;  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	non-compiled	[CE]  cannot  find  symbol  n	15	None	replace
22	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  ns;  ++i)  {  [CE]  cannot  find  symbol  ns  [FE]    AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]  for(int  i  =  0;  i  <  ns;  ++i)  {  [BUGGY]  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	for(int  i  =  0;  i  <  ns;  ++i)  {	for  (int  i  =  0;  i  <  j;  ++i)  {  	non-compiled	[CE]  cannot  find  symbol  ns	15	None	replace
23	[BUG]  [BUGGY]    double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];		non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
24	[BUG]  [BUGGY]    double  s  =(work1[pj]  -  work1[pj]  *  diagR[pj]);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    double  s  =(work1[pj]  -  work1[pj]  *  diagR[pj]);  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    double  s  =(work1[pj]  -  work1[pj]  *  diagR[pj]);		non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
25	[BUG]  [BUGGY]    double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  s;  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  s;  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum2  +=  s  *  s;		non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
26	[BUG]  [BUGGY]    double  s  =  Math.abs(work1[pj]  *  work2[pj]);  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    double  s  =  Math.abs(work1[pj]  *  work2[pj]);  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    double  s  =  Math.abs(work1[pj]  *  work2[pj]);		non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
27	[BUG]  [BUGGY]    double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  s  *  s;  [CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError  [CONTEXT]  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  [BUGGY]    double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  s  *  s;  [BUGGY]  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	538	538	2	replace	    double  s  =(work1[pj]  -  work1[pj])/  diagR[pj];  sum  +=  s  *  s;		non-compiled	[CE]  variable  s  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	add
