bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1,  work3);  [CE]  no  suitable  method  found  for  min(int,double[],double[])  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1,  work3);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work1,  work3);	      int    solvedCols    =    Math.min(solvedCols,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  min(int,double[],double[])	11	None	replace
2	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work2,  work3);  [CE]  no  suitable  method  found  for  min(int,double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work2,  work3);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work2,  work3);	      int    solvedCols    =    Math.min(solvedCols,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  min(int,double[],double[])	11	None	replace
3	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1,  work2);  [CE]  no  suitable  method  found  for  min(int,double[],double[])  [FE]                    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1,  work2);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work1,  work2);	      int    solvedCols    =    Math.min(solvedCols,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  min(int,double[],double[])	11	None	replace
4	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work3,  work1.length);  [CE]  no  suitable  method  found  for  min(int,double[],int)  [FE]                      AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work3,  work1.length);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work3,  work1.length);	      int    solvedCols    =    Math.min(solvedCols,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  min(int,double[],int)	11	None	replace
5	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1[j]);  [CE]  cannot  find  symbol  j  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1[j]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work1[j]);	      int    solvedCols    =    Math.min(solvedCols,    work2[j]);    	non-compiled	[CE]  cannot  find  symbol  j	9	None	replace
6	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work3[j]);  [CE]  cannot  find  symbol  j  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work3[j]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work3[j]);	      int    solvedCols    =    Math.min(solvedCols,    work2[j]);    	non-compiled	[CE]  cannot  find  symbol  j	9	None	replace
7	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work2[j]  -  work1.length);  [CE]  cannot  find  symbol  j  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work2[j]  -  work1.length);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work2[j]  -  work1.length);	      int    solvedCols    =    Math.min(solvedCols,    work2[j]);    	non-compiled	[CE]  cannot  find  symbol  j	9	None	replace
8	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1[pj]  *  diagR[pj]);  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1[pj]  *  diagR[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work1[pj]  *  diagR[pj]);	      double    solvedCols    =    Math.min(solvedCols,    work2[pj]    *    diagR[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	16	None	replace
9	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[j]  *  diagR[j]);  [CE]  cannot  find  symbol  j  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[j]  *  diagR[j]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work2[j]  *  diagR[j]);	      double    solvedCols    =    Math.min(solvedCols,    work2[pj]    *    diagR[pj]);    	non-compiled	[CE]  cannot  find  symbol  j	16	None	replace
10	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[pj]  *  work3[pj]);  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[pj]  *  work3[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work2[pj]  *  work3[pj]);	      double    solvedCols    =    Math.min(solvedCols,    work2[pj]    *    diagR[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	16	None	replace
11	[BUG]  [BUGGY]  double  s  =(work1[j]  -  work1)/  diagR[j];  [CE]  cannot  find  symbol  j  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  s  =(work1[j]  -  work1)/  diagR[j];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  s  =(work1[j]  -  work1)/  diagR[j];	      double    s    =(work1[pj]    -    work1)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  j	19	None	replace
12	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1)/  jacobian[pj];  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  s  =(work1[pj]  -  work1)/  jacobian[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  s  =(work1[pj]  -  work1)/  jacobian[pj];	      double    s    =(work1[pj]    -    work1)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	19	None	replace
13	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1)/  diagR[dxNorm];  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  s  =(work1[pj]  -  work1)/  diagR[dxNorm];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  s  =(work1[pj]  -  work1)/  diagR[dxNorm];	      double    s    =(work1[pj]    -    work1)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	19	None	replace
14	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  work1);  [CE]  no  suitable  method  found  for  max(double,double[])  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(sum2,  work1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(sum2,  work1);	  sum2    =    Math.max(sum2,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double[])	22	None	replace
15	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  work1,  work3);  [CE]  no  suitable  method  found  for  max(double,double[],double[])  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(sum2,  work1,  work3);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(sum2,  work1,  work3);	  sum2    =    Math.max(sum2,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double[],double[])	22	None	replace
16	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  work2);  [CE]  no  suitable  method  found  for  max(double,double[])  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(sum2,  work2);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(sum2,  work2);	  sum2    =    Math.max(sum2,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double[])	22	None	replace
17	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  work1,  work2);  [CE]  no  suitable  method  found  for  max(double,double[],double[])  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(sum2,  work1,  work2);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(sum2,  work1,  work2);	  sum2    =    Math.max(sum2,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double[],double[])	22	None	replace
18	[BUG]  [BUGGY]  sum2  -=  parl;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  -=  parl;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  -=  parl;	  sum2    -=    0;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	12	None	replace
19	[BUG]  [BUGGY]  sum2  -=  Math.max(sum2,  parl);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  -=  Math.max(sum2,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  -=  Math.max(sum2,  parl);	  sum2    -=    0;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	12	None	replace
20	[BUG]  [BUGGY]  sum2  -=  1;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  -=  1;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  -=  1;	  sum2    -=    0;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	12	None	replace
21	[BUG]  [BUGGY]  sum2  -=  Math.max(parl,  parl);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  -=  Math.max(parl,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  -=  Math.max(parl,  parl);	  sum2    -=    0;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	12	None	replace
22	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  Math.abs(diagR[pj]));  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  Math.abs(diagR[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(work1[pj]  *  Math.abs(diagR[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work1[pj]));    	non-compiled	[CE]  ']'  expected	20	None	replace
23	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj]  *  Math.abs(work1[pj]));  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj]  *  Math.abs(work1[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  work1[pj]  =  Math.abs(diagR[pj]  *  Math.abs(work1[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work1[pj]));    	non-compiled	[CE]  ']'  expected	20	None	replace
24	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[pj]  *  Math.abs(diagR[pj]));  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[pj]  *  Math.abs(diagR[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  work2[pj]  =  Math.abs(work1[pj]  *  Math.abs(diagR[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work1[pj]));    	non-compiled	[CE]  ']'  expected	20	None	replace
25	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]  *  Math.abs(work1[pj]));  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]  *  Math.abs(work1[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj]  *  Math.abs(work1[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work1[pj]));    	non-compiled	[CE]  ']'  expected	20	None	replace
26	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  parl  +  1);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(sum2,  parl  +  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(sum2,  parl  +  1);	  sum2    =    Math.max(sum2,    parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	1	None	replace
27	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  parj);  [CE]  cannot  find  symbol  parj  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(sum2,  parj);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(sum2,  parj);	  sum2    =    Math.max(sum2,    parl);    	non-compiled	[CE]  cannot  find  symbol  parj	1	None	replace
28	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  parl  -  1);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(sum2,  parl  -  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(sum2,  parl  -  1);	  sum2    =    Math.max(sum2,    parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	1	None	replace
29	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(work1[pj]);	      double[]    diagR[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	8	None	replace
30	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj]);  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  work1[pj]  =  Math.abs(diagR[pj]);	      double[]    diagR[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	8	None	replace
31	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]);  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj]);	      double[]    diagR[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	8	None	replace
32	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]);  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[0]);	      double[]    diagR[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	8	None	replace
33	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  parl);	      double    solvedCols    =    Math.min(solvedCols,    solveCols);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	14	None	replace
34	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  sum2);	      double    solvedCols    =    Math.min(solvedCols,    solveCols);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	14	None	replace
35	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  j);  [CE]  cannot  find  symbol  j  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  j);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  j);	      double    solvedCols    =    Math.min(solvedCols,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  j	14	None	replace
36	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  sum2  =  parl;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	add	sum2    =    parl;    sum2  =  parl;	  	compilable	  [FE]  AssertionFailedError  	2	2	add
37	[BUG]  [BUGGY]  sum2  =  parl;  sum2  =  parl;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  sum2  =  parl;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    sum2  =  parl;	  	compilable	  [FE]  AssertionFailedError  	2	2	add
38	[BUG]  [BUGGY]  sum2  =  parl;  double  parl  =  parl;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  double  parl  =  parl;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    double  parl  =  parl;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	2	None	add
39	[BUG]  [BUGGY]  sum2  =  parl;  Sum2  =  parl;  [CE]  cannot  find  symbol  Sum2  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  Sum2  =  parl;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    Sum2  =  parl;	  	non-compiled	[CE]  cannot  find  symbol  Sum2	2	None	add
40	[BUG]  [BUGGY]  sum2  =  parl;  total2  =  parl;  [CE]  cannot  find  symbol  total2  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  total2  =  parl;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    total2  =  parl;	  	non-compiled	[CE]  cannot  find  symbol  total2	2	None	add
41	[BUG]  [BUGGY]  sum2  =  parl;  sum2  =  parl;  i  =  0;  [CE]  cannot  find  symbol  i  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  sum2  =  parl;  i  =  0;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    sum2  =  parl;  i  =  0;	  	non-compiled	[CE]  cannot  find  symbol  i	2	None	add
42	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl  +  1;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	add	sum2  =  parl  +  1;	  sum2    =    parl;    	compilable	  [FE]  AssertionFailedError  	3	3	replace
43	[BUG]  [BUGGY]  sum2  =  parl  +  1;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl  +  1;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  parl  +  1;	  sum2    =    parl;    	compilable	  [FE]  AssertionFailedError  	3	3	replace
44	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagR[j],  solveCols)/  diagR[pj].doubleValue();  [CE]  cannot  find  symbol  j  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(diagR[j],  solveCols)/  diagR[pj].doubleValue();  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(diagR[j],  solveCols)/  diagR[pj].doubleValue();	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj].doubleValue();    	non-compiled	[CE]  cannot  find  symbol  j	17	None	replace
45	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagR[pj],  solveCols)/  diagR[pj].doubleValue();  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(diagR[pj],  solveCols)/  diagR[pj].doubleValue();  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(diagR[pj],  solveCols)/  diagR[pj].doubleValue();	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj].doubleValue();    	non-compiled	[CE]  cannot  find  symbol  pj	17	None	replace
46	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl)/  diagR[pj].doubleValue();  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl)/  diagR[pj].doubleValue();  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  parl)/  diagR[pj].doubleValue();	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj].doubleValue();    	non-compiled	[CE]  cannot  find  symbol  pj	17	None	replace
47	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  solveCols)/  work1[pj].doubleValue();  [CE]  cannot  find  symbol  solveCols  [FE]                    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  solveCols)/  work1[pj].doubleValue();  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  solveCols)/  work1[pj].doubleValue();	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj].doubleValue();    	non-compiled	[CE]  cannot  find  symbol  solveCols	17	None	replace
48	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  1;  sum2  =  1;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	add	sum2    =    1;    sum2  =  1;	  	compilable	  [FE]  AssertionFailedError  	4	2	add
49	[BUG]  [BUGGY]  sum2  =  1;  sum2  =  1;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  1;  sum2  =  1;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    1;    sum2  =  1;	  	compilable	  [FE]  AssertionFailedError  	4	2	add
50	[BUG]  [BUGGY]  sum2  =  1;  Sum2  =  1;  [CE]  cannot  find  symbol  Sum2  [FE]      AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  1;  Sum2  =  1;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    1;    Sum2  =  1;	  	non-compiled	[CE]  cannot  find  symbol  Sum2	4	None	add
51	[BUG]  [BUGGY]  sum2  =  1;  int  sum2  =  1;  [CE]  variable  sum2  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  1;  int  sum2  =  1;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    1;    int  sum2  =  1;	  	non-compiled	[CE]  variable  sum2  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	4	None	add
52	[BUG]  [BUGGY]  sum2  =  1;  double  sum2  =  1;  [CE]  variable  sum2  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  1;  double  sum2  =  1;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    1;    double  sum2  =  1;	  	non-compiled	[CE]  variable  sum2  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	4	None	add
53	[BUG]  [BUGGY]  sum2  =  1;  total2  =  1;  [CE]  cannot  find  symbol  total2  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  1;  total2  =  1;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    1;    total2  =  1;	  	non-compiled	[CE]  cannot  find  symbol  total2	4	None	add
54	[BUG]  [BUGGY]  sum2  =  Math.min(sum2,  pj);  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.min(sum2,  pj);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.min(sum2,  pj);	  sum2    =    Math.min(sum2,    parl);    	non-compiled	[CE]  cannot  find  symbol  pj	13	None	replace
55	[BUG]  [BUGGY]  sum2  =  Math.min(sum2,  parl  +  1);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.min(sum2,  parl  +  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.min(sum2,  parl  +  1);	  sum2    =    Math.min(sum2,    parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	13	None	replace
56	[BUG]  [BUGGY]  sum2  =  Math.min(sum2,  parl  -  1);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.min(sum2,  parl  -  1);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.min(sum2,  parl  -  1);	  sum2    =    Math.min(sum2,    parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	13	None	replace
57	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work2[pj]);  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work2[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work2[pj]);	      int    solvedCols    =    Math.min(solvedCols,    work1[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	10	None	replace
58	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[pj]  /  dxNorm;  }	      	non-compiled	[CE]  cannot  find  symbol  sum	6	None	replace
59	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work1[i]  /  dxNorm;  }  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work1[i]  /  dxNorm;  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work1[i]  /  dxNorm;  }	      	non-compiled	[CE]  cannot  find  symbol  sum	6	None	replace
60	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i]  /  dxNorm;  }  [CE]  cannot  find  symbol  sum  [FE]                  AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i]  /  dxNorm;  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i]  /  dxNorm;  }	      	non-compiled	[CE]  cannot  find  symbol  sum	6	None	replace
61	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  j  =  solved[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  cannot  find  symbol  solved  [FE]                    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  j  =  solved[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  j  =  solved[i][pj]  *  work1[pj]  /  dxNorm;  }	      	non-compiled	[CE]  cannot  find  symbol  solved	6	None	replace
62	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1[pj])/  diagR[pj];  [CE]  cannot  find  symbol  pj  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1[pj])/  diagR[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work1[pj])/  diagR[pj];	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	15	None	replace
63	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  solveCols)/  work1[pj];  [CE]  cannot  find  symbol  solveCols  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  solveCols)/  work1[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  solveCols)/  work1[pj];	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  solveCols	15	None	replace
64	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagR[pj],  solveCols)/  diagR[pj];  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(diagR[pj],  solveCols)/  diagR[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(diagR[pj],  solveCols)/  diagR[pj];	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	15	None	replace
65	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum)/  diagR[pj];  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum)/  diagR[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  sum)/  diagR[pj];	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  sum	15	None	replace
66	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);	      double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	7	None	replace
67	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj].doubleValue());  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj].doubleValue());  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(work1[pj].doubleValue());	      double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	7	None	replace
68	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  2);  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  2);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  2);	      double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	7	None	replace
69	[BUG]  [BUGGY]  sum2  -=  2;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  -=  2;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  -=  2;	  sum2    =    1;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	5	None	replace
70	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1[j]);  [CE]  cannot  find  symbol  j  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1[j]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work1[j]);	      double    solvedCols    =    Math.min(solvedCols,    work2[pj]);    	non-compiled	[CE]  cannot  find  symbol  j	18	None	replace
71	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1[pj]);  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work1[pj]);	      double    solvedCols    =    Math.min(solvedCols,    work2[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	18	None	replace
72	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[j]);  [CE]  cannot  find  symbol  j  [FE]                    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[j]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work2[j]);	      double    solvedCols    =    Math.min(solvedCols,    work2[pj]);    	non-compiled	[CE]  cannot  find  symbol  j	18	None	replace
73	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1,  work2[j]);  [CE]  cannot  find  symbol  j  [FE]                      AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1,  work2[j]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work1,  work2[j]);	      double    solvedCols    =    Math.min(solvedCols,    work2[pj]);    	non-compiled	[CE]  cannot  find  symbol  j	18	None	replace
74	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  Math.abs(work2[pj]));  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  Math.abs(work2[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(work1[pj]  *  Math.abs(work2[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work2[pj]));    	non-compiled	[CE]  ']'  expected	21	None	replace
75	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]  *  Math.abs(work2[pj]));  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]  *  Math.abs(work2[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj]  *  Math.abs(work2[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work2[pj]));    	non-compiled	[CE]  ']'  expected	21	None	replace
76	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1.length  *  Math.abs(work2[pj]));  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1.length  *  Math.abs(work2[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(work1.length  *  Math.abs(work2[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work2[pj]));    	non-compiled	[CE]  ']'  expected	21	None	replace
77	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  qy);  [CE]  no  suitable  method  found  for  max(double,double[])  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(sum2,  qy);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(sum2,  qy);	  sum2    =    Math.max(sum2,    parl);    	non-compiled	[CE]  no  suitable  method  found  for  max(double,double[])	1	None	replace
78	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(rank,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	add	sum2  =  Math.max(rank,  parl);	  sum2    =    Math.max(sum2,    parl);    	compilable	  [FE]  AssertionFailedError  	1	4	replace
79	[BUG]  [BUGGY]  sum2  =  Math.max(rank,  parl);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(rank,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(rank,  parl);	  sum2    =    Math.max(sum2,    parl);    	compilable	  [FE]  AssertionFailedError  	1	4	replace
80	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work2)/  diagR[pj];  [CE]  cannot  find  symbol  pj  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  s  =(work1[pj]  -  work2)/  diagR[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  s  =(work1[pj]  -  work2)/  diagR[pj];	      double    s    =(work1[pj]    -    work1)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	19	None	replace
81	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2)/  diagR[pj];  [CE]  no  suitable  method  found  for  min(double,double[])  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2)/  diagR[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work2)/  diagR[pj];	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj];    	non-compiled	[CE]  no  suitable  method  found  for  min(double,double[])	15	None	replace
82	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(rank,  solveCols)/  diagR[pj];  [CE]  cannot  find  symbol  solveCols  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(rank,  solveCols)/  diagR[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(rank,  solveCols)/  diagR[pj];	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  solveCols	15	None	replace
83	[BUG]  [BUGGY]  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
84	[BUG]  [BUGGY]  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
85	[BUG]  [BUGGY]  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  diagR[pj];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  diagR[pj];  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  diagR[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
86	[BUG]  [BUGGY]  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  diagR[pj];  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  diagR[pj];  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  diagR[pj];  }	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
87	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.abs(parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	add	sum2  =  Math.abs(parl);	  sum2    =    parl;    	compilable	  [FE]  AssertionFailedError  	3	2	replace
88	[BUG]  [BUGGY]  sum2  =  Math.abs(parl);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.abs(parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.abs(parl);	  sum2    =    parl;    	compilable	  [FE]  AssertionFailedError  	3	2	replace
89	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work3[pj]  *  Math.abs(work2[pj]));  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(work3[pj]  *  Math.abs(work2[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(work3[pj]  *  Math.abs(work2[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work2[pj]));    	non-compiled	[CE]  ']'  expected	21	None	replace
90	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work2[pj]  *  work1[pj]);  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(work2[pj]  *  work1[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(work2[pj]  *  work1[pj]);	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work2[pj]));    	non-compiled	[CE]  ']'  expected	21	None	replace
91	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1[0]);  [CE]  possible  loss  of  precision  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1[0]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work1[0]);	      int    solvedCols    =    Math.min(solvedCols,    work1[pj]);    	non-compiled	[CE]  possible  loss  of  precision	10	None	replace
92	[BUG]  [BUGGY]  double[]  work3[pj]  =  Math.abs(diagR[pj]);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  work3[pj]  =  Math.abs(diagR[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  work3[pj]  =  Math.abs(diagR[pj]);	      double[]    diagR[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	8	None	replace
93	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  work3);  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  work3);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  work3);	      double[]    diagR[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	8	None	replace
94	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  work2[pj]);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  work2[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(work1[pj]  *  work2[pj]);	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work1[pj]));    	non-compiled	[CE]  ']'  expected	20	None	replace
95	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  work3);  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  work3);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(work1[pj]  *  work3);	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work1[pj]));    	non-compiled	[CE]  ']'  expected	20	None	replace
96	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  work3[pj]);  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  work3[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagR[pj]  =  Math.abs(work1[pj]  *  work3[pj]);	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work1[pj]));    	non-compiled	[CE]  ']'  expected	20	None	replace
97	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  diagR.length);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  diagR.length);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  diagR.length);	      double    solvedCols    =    Math.min(solvedCols,    solveCols);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	14	None	replace
98	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.min(rank,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	add	sum2  =  Math.min(rank,  parl);	  sum2    =    Math.min(sum2,    parl);    	compilable	  [FE]  AssertionFailedError  	13	2	replace
99	[BUG]  [BUGGY]  sum2  =  Math.min(rank,  parl);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.min(rank,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.min(rank,  parl);	  sum2    =    Math.min(sum2,    parl);    	compilable	  [FE]  AssertionFailedError  	13	2	replace
100	[BUG]  [BUGGY]  sum2  =  Math.min(sum2,  qy);  [CE]  no  suitable  method  found  for  min(double,double[])  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.min(sum2,  qy);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.min(sum2,  qy);	  sum2    =    Math.min(sum2,    parl);    	non-compiled	[CE]  no  suitable  method  found  for  min(double,double[])	13	None	replace
101	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work2[0]);  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work2[0]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work2[0]);	      int    solvedCols    =    Math.min(solvedCols,    work2[j]);    	non-compiled	[CE]  possible  loss  of  precision	9	None	replace
102	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());	      	non-compiled	[CE]  ']'  expected	6	None	replace
103	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  Math.abs(parl));  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  Math.abs(parl));  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  *  Math.abs(parl));	      	non-compiled	[CE]  ']'  expected	6	None	replace
104	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]);  [CE]  ']'  expected  [FE]                  AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]);	      	non-compiled	[CE]  ']'  expected	6	None	replace
105	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(rank);  [CE]  ']'  expected  [FE]                    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  diagR[pj]  =  Math.sqrt(rank);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  diagR[pj]  =  Math.sqrt(rank);	      	non-compiled	[CE]  ']'  expected	6	None	replace
106	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work2);  [CE]  no  suitable  method  found  for  min(int,double[])  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work2);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work2);	      int    solvedCols    =    Math.min(solvedCols,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  min(int,double[])	11	None	replace
107	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[0]);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[0]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work2[0]);	      double    solvedCols    =    Math.min(solvedCols,    work2[pj]);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	18	None	replace
108	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagR[0],  solveCols)/  diagR[pj].doubleValue();  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(diagR[0],  solveCols)/  diagR[pj].doubleValue();  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(diagR[0],  solveCols)/  diagR[pj].doubleValue();	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj].doubleValue();    	non-compiled	[CE]  cannot  find  symbol  solveCols	17	None	replace
109	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(rank,  solveCols)/  diagR[pj].doubleValue();  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(rank,  solveCols)/  diagR[pj].doubleValue();  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(rank,  solveCols)/  diagR[pj].doubleValue();	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj].doubleValue();    	non-compiled	[CE]  cannot  find  symbol  solveCols	17	None	replace
110	[BUG]  [BUGGY]  sum2  -=  Math.pow(10,  parl);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  -=  Math.pow(10,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  -=  Math.pow(10,  parl);	  sum2    -=    0;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	12	None	replace
111	[BUG]  [BUGGY]  sum2  -=  Math.sqrt(rank);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  -=  Math.sqrt(rank);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  -=  Math.sqrt(rank);	  sum2    -=    0;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	12	None	replace
112	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  1;  sum2  =  2;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	add	sum2    =    1;    sum2  =  2;	  	compilable	  [FE]  AssertionFailedError  	4	2	add
113	[BUG]  [BUGGY]  sum2  =  1;  sum2  =  2;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  1;  sum2  =  2;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    1;    sum2  =  2;	  	compilable	  [FE]  AssertionFailedError  	4	2	add
114	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1,  work2[pj]);  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1,  work2[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work1,  work2[pj]);	      int    solvedCols    =    Math.min(solvedCols,    work1[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	10	None	replace
115	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1[pj]  *  work3);  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work1[pj]  *  work3);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(solvedCols,  work1[pj]  *  work3);	      int    solvedCols    =    Math.min(solvedCols,    work1[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	10	None	replace
116	[BUG]  [BUGGY]  double[]diagR[pj]  =  work3;  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]diagR[pj]  =  work3;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]diagR[pj]  =  work3;	      	non-compiled	[CE]  ']'  expected	6	None	replace
117	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[pj]  *  Math.abs(work2[pj]));  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[pj]  *  Math.abs(work2[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  workR[pj]  =  Math.abs(workR[pj]  *  Math.abs(work2[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work2[pj]));    	non-compiled	[CE]  ']'  expected	21	None	replace
118	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[pj]  *  Math.abs(work1[pj]));  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  workR[pj]  =  Math.abs(workR[pj]  *  Math.abs(work1[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  workR[pj]  =  Math.abs(workR[pj]  *  Math.abs(work1[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work2[pj]));    	non-compiled	[CE]  ']'  expected	21	None	replace
119	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(work1,  solvedCols);  [CE]  no  suitable  method  found  for  min(double[],int)  [FE]                AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  int  solvedCols  =  Math.min(work1,  solvedCols);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	int  solvedCols  =  Math.min(work1,  solvedCols);	      int    solvedCols    =    Math.min(solvedCols,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],int)	11	None	replace
120	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  diagR[pj]);  [CE]  cannot  find  symbol  pj  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(sum2,  diagR[pj]);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(sum2,  diagR[pj]);	  sum2    =    Math.max(sum2,    parl);    	non-compiled	[CE]  cannot  find  symbol  pj	1	None	replace
121	[BUG]  [BUGGY]  sum2  /=  parl;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  /=  parl;  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  /=  parl;	  sum2    =    parl;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	3	None	replace
122	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  solvedCols);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  solvedCols);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  solvedCols);	      double    solvedCols    =    Math.min(solvedCols,    solveCols);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	14	None	replace
123	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  resolvedCols);  [CE]  cannot  find  symbol  resolvedCols  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  resolvedCols);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  resolvedCols);	      double    solvedCols    =    Math.min(solvedCols,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	14	None	replace
124	[BUG]  [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue());  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue());  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue());	      double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	7	None	replace
125	[BUG]  [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);	      double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	7	None	replace
126	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[pj]  *  work1[pj]);  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[pj]  *  work1[pj]);  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work2[pj]  *  work1[pj]);	      double    solvedCols    =    Math.min(solvedCols,    work2[pj]    *    diagR[pj]);    	non-compiled	[CE]  cannot  find  symbol  pj	16	None	replace
127	[BUG]  [BUGGY]  sum2  =  Math.max(work3,  sum2);  [CE]  no  suitable  method  found  for  max(double[],double)  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  Math.max(work3,  sum2);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  =  Math.max(work3,  sum2);	  sum2    =    Math.max(sum2,    work3);    	non-compiled	[CE]  no  suitable  method  found  for  max(double[],double)	22	None	replace
128	[BUG]  [BUGGY]  sum2  -=  Math.pow(0,  parl);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  -=  Math.pow(0,  parl);  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2  -=  Math.pow(0,  parl);	  sum2    -=    0;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	12	None	replace
129	[BUG]  [BUGGY]  sum2  =  parl;  if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  work1[pj]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
130	[BUG]  [BUGGY]  sum2  =  parl;  if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[pj]  *  work1[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  work1[pj]  *  work1[pj]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
131	[BUG]  [BUGGY]  sum2  =  parl;  if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  work1[pj]  *  work1[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  work1[pj]  *  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  sum  +=  work1[pj]  *  work1[pj]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
132	[BUG]  [BUGGY]  sum2  =  parl;  if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work1[pj]  /  dxNorm;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  sum2  =  parl;  if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work1[pj]  /  dxNorm;  }  [BUGGY]    for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	sum2    =    parl;    if(sum2  <  parl)  {  sum2  =  parl;  }  else  {  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work1[pj]  /  dxNorm;  }	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
133	[BUG]  [BUGGY]  double  s  =(work1[pj]  -  work1)/  logR[pj];  [CE]  cannot  find  symbol  pj  [FE]        AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  s  =(work1[pj]  -  work1)/  logR[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  s  =(work1[pj]  -  work1)/  logR[pj];	      double    s    =(work1[pj]    -    work1)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	19	None	replace
134	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1[pj])/  diagR[pj].doubleValue();  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1[pj])/  diagR[pj].doubleValue();  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work1[pj])/  diagR[pj].doubleValue();	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj].doubleValue();    	non-compiled	[CE]  cannot  find  symbol  pj	17	None	replace
135	[BUG]  [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(work1[pj]  *  Math.abs(diagR[pj]));  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(work1[pj]  *  Math.abs(diagR[pj]));  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double[]  diagnosticR[pj]  =  Math.abs(work1[pj]  *  Math.abs(diagR[pj]));	      double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    Math.abs(work1[pj]));    	non-compiled	[CE]  ']'  expected	20	None	replace
136	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1)/  diagR[pj];  [CE]  no  suitable  method  found  for  min(double,double[])  [FE]          AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work1)/  diagR[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work1)/  diagR[pj];	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj];    	non-compiled	[CE]  no  suitable  method  found  for  min(double,double[])	15	None	replace
137	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[pj])/  diagR[pj];  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work2[pj])/  diagR[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  work2[pj])/  diagR[pj];	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	15	None	replace
138	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  diagR[pj])/  work1[pj];  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError    [CONTEXT]        double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  *=  diag[pj]  /  dxNorm;  }    [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  diagR[pj])/  work1[pj];  [BUGGY]    sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	534	534	2	replace	double  solvedCols  =  Math.min(solvedCols,  diagR[pj])/  work1[pj];	      double    solvedCols    =    Math.min(solvedCols,    solveCols)/    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	15	None	replace
