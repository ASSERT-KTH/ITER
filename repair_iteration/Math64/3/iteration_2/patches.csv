bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  int  work2[pj]  *=  diag[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  work2[pj]  *=  diag[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    int    work2[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	63	None	replace
2	[BUG]  [BUGGY]  double  work2[pj]  *=  diag[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  work2[pj]  *=  diag[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    int    work2[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	63	None	replace
3	[BUG]  [BUGGY]  int  work2[pj]  *=  diagnostic[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  work2[pj]  *=  diagnostic[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  work2[pj]  *=  diagnostic[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    int    work2[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	63	None	replace
4	[BUG]  [BUGGY]  int  work2[pj]  *=  diag[pj]  /  2;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  work2[pj]  *=  diag[pj]  /  2;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  work2[pj]  *=  diag[pj]  /  2;	  work2[pj]    *=    diag[pj]    /    dxNorm;    int    work2[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	63	None	replace
5	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]  *=  work2.length  /  dxNorm;	  work1[pj]    *=    work1.length    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	132	10	replace
6	[BUG]  [BUGGY]  work1[pj]  *=  work2.length  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2.length  /  dxNorm;	  work1[pj]    *=    work1.length    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	132	10	replace
7	[BUG]  [BUGGY]  work1[pj]  *=  work2  /  dxNorm;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2  /  dxNorm;	  work1[pj]    *=    work1.length    /    dxNorm;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	132	None	replace
8	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]  *=  work3.length  /  dxNorm;	  work1[pj]    *=    work1.length    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	132	10	replace
9	[BUG]  [BUGGY]  work1[pj]  *=  work3.length  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work3.length  /  dxNorm;	  work1[pj]    *=    work1.length    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	132	10	replace
10	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  work1.length  /  dxNorm;	  work1[pj]    *=    work1.length    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	132	7	replace
11	[BUG]  [BUGGY]  work2[pj]  *=  work1.length  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work1.length  /  dxNorm;	  work1[pj]    *=    work1.length    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	132	7	replace
12	[BUG]  [BUGGY]  double  work1[pj]  *=  work3[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  work1[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  work1[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    double    work1[pj]    *=    work3[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	113	None	replace
13	[BUG]  [BUGGY]  double  work2[pj]  *=  work3[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  work2[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    double    work1[pj]    *=    work3[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	113	None	replace
14	[BUG]  [BUGGY]  double  work1[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  work1[pj]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    double    work1[pj]    *=    work3[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	113	None	replace
15	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	11	add
16	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	11	add
17	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	10	add
18	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	10	add
19	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	10	add
20	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	10	add
21	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[j]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work1[j]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	11	add
22	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[j]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[j]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work1[j]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	11	add
23	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  Work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  Work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    Work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work1	134	None	add
24	[BUG]  [BUGGY]  double[]  work3[pj]  =  Math.abs(work1[pj]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work3[pj]  =  Math.abs(work1[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work3[pj]  =  Math.abs(work1[pj]);	  double[]    work3[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	123	None	replace
25	[BUG]  [BUGGY]  double[]  work3[pj]  =  Math.abs(work2[pj]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work3[pj]  =  Math.abs(work2[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work3[pj]  =  Math.abs(work2[pj]);	  double[]    work3[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	123	None	replace
26	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work1[pj]  =  Math.abs(work1[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work1[pj]  =  Math.abs(work1[pj]);	  double[]    work3[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	123	None	replace
27	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work2[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	89	None	replace
28	[BUG]  [BUGGY]  work1[j]  *=  work2[j]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[j]  *=  work2[j]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[j]  *=  work2[j]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work2[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	89	None	replace
29	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	12	add
30	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	12	add
31	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	12	add
32	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	12	add
33	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	13	add
34	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	13	add
35	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	12	add
36	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	12	add
37	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	12	add
38	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	12	add
39	[BUG]  [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);	  double[]    diagnosticR[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	144	None	replace
40	[BUG]  [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  dxNorm);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  dxNorm);	  double[]    diagnosticR[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	144	None	replace
41	[BUG]  [BUGGY]  double  diagR[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double    diagR[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	99	None	replace
42	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  diagR[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	diagR[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double    diagR[pj]    *=    diagR[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	99	13	replace
43	[BUG]  [BUGGY]  diagR[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  diagR[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	diagR[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double    diagR[pj]    *=    diagR[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	99	13	replace
44	[BUG]  [BUGGY]  double  diagR[pj]  *=  work1[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double    diagR[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	99	None	replace
45	[BUG]  [BUGGY]  double  diagR[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double    diagR[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	99	None	replace
46	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm  +  1;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  work2[pj]  /  dxNorm  +  1;	  work2[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	39	7	replace
47	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm  +  1;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm  +  1;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work2[pj]  /  dxNorm  +  1;	  work2[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	39	7	replace
48	[BUG]  [BUGGY]  Work1[pj]  *=  work2[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  Work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	Work1[pj]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    Work1[pj]    *=    work2[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  Work1	116	None	replace
49	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum);	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	45	None	replace
50	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  sum2);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  sum2);	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	45	None	replace
51	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum1);	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	45	None	replace
52	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(pj2));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(pj2));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(pj2));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(work2));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	93	None	replace
53	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work1[pj]  *  sum2);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(work1[pj]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(work1[pj]  *  sum2);	  double    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	30	None	replace
54	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  sum1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  sum1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  *  sum1);	  double    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	30	None	replace
55	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[pj]  *  sum2);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[pj]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[pj]  *  sum2);	  double    dxNorm    =    Math.abs(diag[pj]    *    sum2);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	56	None	replace
56	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  sum2);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  sum2);	  double    dxNorm    =    Math.abs(diag[pj]    *    sum2);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	56	None	replace
57	[BUG]  [BUGGY]  int  pj  =  permutation[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  pj  =  permutation[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  pj  =  permutation[j];	  for(int    i    =    0;    j    <    solvedCols;    ++i)    {    int    pj    =    permutation[j];    }    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	76	None	replace
58	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  permutation[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  permutation[j];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  permutation[j];  }	  for(int    i    =    0;    j    <    solvedCols;    ++i)    {    int    pj    =    permutation[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	76	None	replace
59	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue()  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue()  +  1);	  double    diagR[pj]    =    Math.sqrt(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	105	None	replace
60	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[pj].doubleValue());  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(work1[pj].doubleValue());	  double    diagR[pj]    =    Math.sqrt(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	105	None	replace
61	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue()  +  sum2);  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue()  +  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue()  +  sum2);	  double    diagR[pj]    =    Math.sqrt(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	105	None	replace
62	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[j]  *  sum2);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[j]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[j]  *  sum2);	  double    diagR[pj]    =    Math.sqrt(diagR[j]);    	non-compiled	[CE]  ']'  expected	71	None	replace
63	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.log(diagR[j]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.log(diagR[j]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.log(diagR[j]);	  double    diagR[pj]    =    Math.sqrt(diagR[j]);    	non-compiled	[CE]  ']'  expected	71	None	replace
64	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[j]  *  sum);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[j]  *  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[j]  *  sum);	  double    diagR[pj]    =    Math.sqrt(diagR[j]);    	non-compiled	[CE]  ']'  expected	71	None	replace
65	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(j));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(j));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(j));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(work1));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	130	None	replace
66	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diag[j]));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diag[j]));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diag[j]));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(work1));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	130	None	replace
67	[BUG]  [BUGGY]  job1[pj]  *=  work1[pj]  /  dxNorm;  [CE]  cannot  find  symbol  job1  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  job1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	job1[pj]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    job1[pj]    *=    work1[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  job1	51	None	replace
68	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[0]  *=  diag[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[0]  *=  diag[0]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	62	7	replace
69	[BUG]  [BUGGY]  work2[0]  *=  diag[0]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[0]  *=  diag[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[0]  *=  diag[0]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	62	7	replace
70	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  diag[j]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[j]  *=  diag[j]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	62	7	replace
71	[BUG]  [BUGGY]  work2[j]  *=  diag[j]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  diag[j]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[j]  *=  diag[j]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	62	7	replace
72	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]  *=  diag[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    travail2[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	149	7	replace
73	[BUG]  [BUGGY]  work3[pj]  *=  diag[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  diag[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    travail2[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	149	7	replace
74	[BUG]  [BUGGY]  travail2[pj]  *=  diag[pj]  /  dxNorm;  [CE]  cannot  find  symbol  travail2  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  travail2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	travail2[pj]  *=  diag[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    travail2[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  travail2	149	None	replace
75	[BUG]  [BUGGY]  work1.[pj]  *=  work2[pj]  /  dxNorm;  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1.[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1.[pj]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work1.[pj]    *=    work2[pj]    /    dxNorm;    	non-compiled	[CE]  <identifier>  expected	145	None	replace
76	[BUG]  [BUGGY]  work1.[pj]  *=  work2.[pj]  /  dxNorm;  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1.[pj]  *=  work2.[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1.[pj]  *=  work2.[pj]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work1.[pj]    *=    work2[pj]    /    dxNorm;    	non-compiled	[CE]  <identifier>  expected	145	None	replace
77	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work3[i];  }  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work3[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work3[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work3[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	96	None	replace
78	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i][pj]  *  work3[i];  }  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i][pj]  *  work3[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i][pj]  *  work3[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work3[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	96	None	replace
79	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1.length  *  work3.length;  }  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1.length  *  work3.length;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1.length  *  work3.length;  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work3[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	96	None	replace
80	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  parl);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  parl);	  int    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    parl);    	non-compiled	[CE]  ']'  expected	129	None	replace
81	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  sum2);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  sum2);	  int    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    parl);    	non-compiled	[CE]  ']'  expected	129	None	replace
82	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  parl);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  parl);	  int    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    parl);    	non-compiled	[CE]  ']'  expected	129	None	replace
83	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
84	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
85	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
86	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
87	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
88	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
89	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
90	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
91	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
92	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
93	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	106	2	add
94	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	106	2	add
95	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  Work3[pj]  *=  work2[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work3  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  Work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work2[pj]    /    dxNorm;    Work3[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work3	106	None	add
96	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  work3[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]    *=    work2[pj]    /    dxNorm;    work3[j]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	106	2	add
97	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  work3[j]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  work3[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work2[pj]    /    dxNorm;    work3[j]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	106	2	add
98	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  int  work3[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  int  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work2[pj]    /    dxNorm;    int  work3[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	106	None	add
99	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  double[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  double[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work2[pj]    /    dxNorm;    double[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	106	None	add
100	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(permutation[j]));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(permutation[j]));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(permutation[j]));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(parl));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	91	None	replace
101	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work1.length;  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work1.length;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work1.length;	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    permutation[j];    	non-compiled	[CE]  illegal  start  of  expression	81	None	replace
102	[BUG]  [BUGGY]  work1.[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1.[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1.[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1.[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  <identifier>  expected	136	None	replace
103	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  work1[pj]  /  diagR[pj];	  work1[pj]    *=    work1[pj]    /    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	69	7	replace
104	[BUG]  [BUGGY]  work2[pj]  *=  work1[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work1[pj]  /  diagR[pj];	  work1[pj]    *=    work1[pj]    /    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	69	7	replace
105	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	4	7	replace
106	[BUG]  [BUGGY]  work3[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	4	7	replace
107	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[j]  *=  work3[j]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[j]  *=  work3[j]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	4	7	replace
108	[BUG]  [BUGGY]  work3[j]  *=  work3[j]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[j]  *=  work3[j]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[j]  *=  work3[j]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	4	7	replace
109	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]  *=  work1[pj]  /  diagR[pj];	  work3[pj]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	101	7	replace
110	[BUG]  [BUGGY]  work3[pj]  *=  work1[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  work1[pj]  /  diagR[pj];	  work3[pj]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	101	7	replace
111	[BUG]  [BUGGY]  int  pj  =  solvedCols[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  pj  =  solvedCols[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  pj  =  solvedCols[j];	  for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    solvedCols[j];    }    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	75	None	replace
112	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]    *=    diagR[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	135	7	replace
113	[BUG]  [BUGGY]  work3[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]    *=    diagR[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	135	7	replace
114	[BUG]  [BUGGY]  double  work2[0]  *=  diag[0]  /  dxNorm;  [CE]  ']'  expected  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  work2[0]  *=  diag[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  work2[0]  *=  diag[0]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    double    work2[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	121	None	replace
115	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[0]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[0]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	119	7	replace
116	[BUG]  [BUGGY]  work3[0]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[0]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[0]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	119	7	replace
117	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[j]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	119	7	replace
118	[BUG]  [BUGGY]  work3[j]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[j]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	119	7	replace
119	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj]  *  1);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj]  *  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj]  *  1);	  int    diagR[pj]    =    Math.abs(diagR[pj]    +    1);    	non-compiled	[CE]  ']'  expected	112	None	replace
120	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(work1[pj]  +  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(work1[pj]  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(work1[pj]  +  1);	  int    diagR[pj]    =    Math.abs(diagR[pj]    +    1);    	non-compiled	[CE]  ']'  expected	112	None	replace
121	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj]  /  1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj]  /  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj]  /  1);	  int    diagR[pj]    =    Math.abs(diagR[pj]    +    1);    	non-compiled	[CE]  ']'  expected	112	None	replace
122	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.log(dxNorm);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.log(dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.log(dxNorm);	  double    diagR[pj]    =    Math.sqrt(dxNorm);    	non-compiled	[CE]  ']'  expected	143	None	replace
123	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(tab);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(tab);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(tab);	  double    diagR[pj]    =    Math.sqrt(dxNorm);    	non-compiled	[CE]  ']'  expected	143	None	replace
124	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[j]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	53	9	replace
125	[BUG]  [BUGGY]  work1[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[j]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	53	9	replace
126	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[j]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	53	7	replace
127	[BUG]  [BUGGY]  work2[j]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[j]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	53	7	replace
128	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[j]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	53	7	replace
129	[BUG]  [BUGGY]  work2[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[j]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	53	7	replace
130	[BUG]  [BUGGY]  double  work2[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  work2[pj]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    double    work1[pj]    *=    work2[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	117	None	replace
131	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]  *=  work2[pj]  /  diagR[pj];	  work3[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	107	7	replace
132	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  work2[pj]  /  diagR[pj];	  work3[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	107	7	replace
133	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm  +  1;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]  *=  work2[pj]  /  dxNorm  +  1;	  work3[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	107	7	replace
134	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm  +  1;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm  +  1;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  work2[pj]  /  dxNorm  +  1;	  work3[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	107	7	replace
135	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[pj]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work1[pj]  =  Math.abs(work2[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work1[pj]  =  Math.abs(work2[pj]);	  double[]    work1[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	18	None	replace
136	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj]  *  sum2);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work1[pj]  =  Math.abs(diagR[pj]  *  sum2);	  double[]    work1[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	18	None	replace
137	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	43	None	replace
138	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagr[pj].doubleValue());  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagr[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagr[pj].doubleValue());	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	43	None	replace
139	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[pj]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(work1[pj]);	  double[]    work2[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	17	None	replace
140	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[pj]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(work3[pj]);	  double[]    work2[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	17	None	replace
141	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1.length[pj]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1.length[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(work1.length[pj]);	  double[]    work2[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	17	None	replace
142	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]  *  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]  *  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj]  *  sum);	  double[]    work2[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	17	None	replace
143	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1.length[pj].doubleValue()  +  1);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1.length[pj].doubleValue()  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1.length[pj].doubleValue()  +  1);	  double    dxNorm    =    Math.abs(work1.length[pj].doubleValue());    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	102	None	replace
144	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	11	add
145	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	11	add
146	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
147	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
148	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
149	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
150	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	13	add
151	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	13	add
152	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	11	add
153	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	11	add
154	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[pj]  *  sum);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[pj]  *  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[pj]  *  sum);	  double    dxNorm    =    Math.abs(work1[pj]);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	54	None	replace
155	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
156	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
157	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
158	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
159	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
160	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
161	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
162	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
163	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
164	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
165	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();	  int    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    2);    	non-compiled	[CE]  ']'  expected	120	None	replace
166	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagr[pj].doubleValue());  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagr[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagr[pj].doubleValue());	  int    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    2);    	non-compiled	[CE]  ']'  expected	120	None	replace
167	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	84	13	add
168	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	84	13	add
169	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	84	13	add
170	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	84	13	add
171	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	84	13	add
172	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	84	13	add
173	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  Work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  Work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    Work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work1	84	None	add
174	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1.[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1.[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1.[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  <identifier>  expected	84	None	add
175	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[j]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	109	7	replace
176	[BUG]  [BUGGY]  work3[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[j]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	109	7	replace
177	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[j]  *=  work3[j]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[j]  *=  work3[j]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	2	13	replace
178	[BUG]  [BUGGY]  work1[j]  *=  work3[j]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[j]  *=  work3[j]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[j]  *=  work3[j]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	2	13	replace
179	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj].doubleValue());  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work1[pj]  =  Math.abs(diagR[pj].doubleValue());	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	40	None	replace
180	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue();	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	40	None	replace
181	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	88	None	replace
182	[BUG]  [BUGGY]  work1[j]  *=  work2[j]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[j]  *=  work2[j]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[j]  *=  work2[j]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	88	None	replace
183	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  parl;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  parl;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  parl;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	88	None	replace
184	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[0]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[0]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	49	7	replace
185	[BUG]  [BUGGY]  work2[0]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[0]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[0]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	49	7	replace
186	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  diagR;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  diagR;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work3[pj]  /  diagR;	  work1[pj]    *=    work3[pj]    /    diagR;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	137	None	replace
187	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]  *=  work3[pj]  /  diagR[j];	  work1[pj]    *=    work3[pj]    /    diagR;    	compilable	  [FE]  AssertionFailedError  	137	13	replace
188	[BUG]  [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[j];  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work3[pj]  /  diagR[j];	  work1[pj]    *=    work3[pj]    /    diagR;    	compilable	  [FE]  AssertionFailedError  	137	13	replace
189	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[0];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]  *=  work3[pj]  /  diagR[0];	  work1[pj]    *=    work3[pj]    /    diagR;    	compilable	  [FE]  AssertionFailedError  	137	13	replace
190	[BUG]  [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[0];  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[0];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work3[pj]  /  diagR[0];	  work1[pj]    *=    work3[pj]    /    diagR;    	compilable	  [FE]  AssertionFailedError  	137	13	replace
191	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work1[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(work1[pj].doubleValue()  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(work1[pj].doubleValue()  +  1);	  double    diagR[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	44	None	replace
192	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work2[pj].doubleValue());  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(work2[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(work2[pj].doubleValue());	  double    diagR[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	44	None	replace
193	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work1[pj].doubleValue()  +  sum2);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(work1[pj].doubleValue()  +  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(work1[pj].doubleValue()  +  sum2);	  double    diagR[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	44	None	replace
194	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  sum);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  sum);	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    sum2);    	non-compiled	[CE]  ']'  expected	125	None	replace
195	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  parl);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  parl);	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    sum2);    	non-compiled	[CE]  ']'  expected	125	None	replace
196	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
197	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
198	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
199	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
200	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
201	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
202	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
203	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
204	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
205	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
206	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	86	13	add
207	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	86	13	add
208	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	86	13	add
209	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	86	13	add
210	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  Work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  Work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    Work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work1	86	None	add
211	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  %  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  %  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	86	13	add
212	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  %  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  %  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  %  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	86	13	add
213	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work1[j]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	86	13	add
214	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work1[j]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	86	13	add
215	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	36	2	add
216	[BUG]  [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	36	2	add
217	[BUG]  [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  int  work2[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  int  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    diagR[pj]    /    dxNorm;    int  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	36	None	add
218	[BUG]  [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  double[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  double[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    diagR[pj]    /    dxNorm;    double[pj]  *=  diagR[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	36	None	add
219	[BUG]  [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  Work2[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work2  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  Work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    diagR[pj]    /    dxNorm;    Work2[pj]  *=  diagR[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work2	36	None	add
220	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[j]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]    *=    diagR[pj]    /    dxNorm;    work2[j]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	36	2	add
221	[BUG]  [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[j]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[j]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    diagR[pj]    /    dxNorm;    work2[j]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	36	2	add
222	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[j]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	9	13	replace
223	[BUG]  [BUGGY]  work1[j]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[j]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	9	13	replace
224	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[j]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	9	7	replace
225	[BUG]  [BUGGY]  work2[j]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[j]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	9	7	replace
226	[BUG]  [BUGGY]  Work1[pj]  *=  work3[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  Work1[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	Work1[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    Work1[pj]    *=    work3[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  Work1	7	None	replace
227	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  sum2);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  sum2);	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	42	None	replace
228	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum);	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	42	None	replace
229	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum1);	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	42	None	replace
230	[BUG]  [BUGGY]  int  work1[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  work1[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    int    work1[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	14	None	replace
231	[BUG]  [BUGGY]  int  work1[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  work1[pj]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    int    work1[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	14	None	replace
232	[BUG]  [BUGGY]  int  work1[pj]  *=  work1[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  work1[pj]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    int    work1[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	14	None	replace
233	[BUG]  [BUGGY]  double  work1[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  work1[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    int    work1[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	14	None	replace
234	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(work1[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(work1[pj].doubleValue()  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(work1[pj].doubleValue()  +  1);	  int    diagR[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	83	None	replace
235	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(work2[pj].doubleValue());  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(work2[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(work2[pj].doubleValue());	  int    diagR[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	83	None	replace
236	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	66	13	add
237	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	66	13	add
238	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	66	13	add
239	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	66	13	add
240	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  int  work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  int  work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    int  work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	66	None	add
241	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  double[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  double[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    double[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	66	None	add
242	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	66	13	add
243	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	66	13	add
244	[BUG]  [BUGGY]  int  pj  =  work3[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  pj  =  work3[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  pj  =  work3[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work3[j];    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	140	None	replace
245	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work1.length[j];  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work1.length[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work1.length[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work3[j];    	non-compiled	[CE]  illegal  start  of  expression	140	None	replace
246	[BUG]  [BUGGY]  int  pj  =  work1[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  pj  =  work1[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  pj  =  work1[j];	  for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work1[j];    }    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	77	None	replace
247	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work1.length;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work1.length;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work1.length;  }	  for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work1[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	77	None	replace
248	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  work3[pj]  /  diagR[pj];	  work2[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	33	7	replace
249	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work3[pj]  /  diagR[pj];	  work2[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	33	7	replace
250	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm  +  1;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  work3[pj]  /  dxNorm  +  1;	  work2[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	33	7	replace
251	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm  +  1;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm  +  1;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work3[pj]  /  dxNorm  +  1;	  work2[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	33	7	replace
252	[BUG]  [BUGGY]  double  work1[pj]  *=  work1[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  work1[pj]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    double    work1[pj]    *=    work1[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	110	None	replace
253	[BUG]  [BUGGY]  work1.[pj]  *=  work3[pj]  /  dxNorm;  [CE]  <identifier>  expected  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1.[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1.[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work1.[pj]    *=    work3[pj]    /    dxNorm;    	non-compiled	[CE]  <identifier>  expected	138	None	replace
254	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  work3[j]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[j]  *=  work3[j]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	6	7	replace
255	[BUG]  [BUGGY]  work2[j]  *=  work3[j]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  work3[j]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[j]  *=  work3[j]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	6	7	replace
256	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]  /  dxNorm);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]  /  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[0]  /  dxNorm);	  double[]    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	122	None	replace
257	[BUG]  [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[0]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work1[pj]  =  Math.abs(diagR[0]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work1[pj]  =  Math.abs(diagR[0]);	  double[]    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	122	None	replace
258	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]  *  sum2);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[0]  *  sum2);	  double[]    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	122	None	replace
259	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[1]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[1]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[1]);	  double[]    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	122	None	replace
260	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][j]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][j]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][j]  *  work1[i];  }	          for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	115	None	replace
261	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1.length  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1.length  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1.length  *  work1[i];  }	          for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	115	None	replace
262	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i]  *  work1[i];  }	          for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	115	None	replace
263	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][j]  *  work3[i];  }  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][j]  *  work3[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][j]  *  work3[i];  }	          for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	115	None	replace
264	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(work2[pj]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(work2[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(work2[pj]);	  int    diagR[pj]    =    Math.abs(work1[pj]);    	non-compiled	[CE]  ']'  expected	58	None	replace
265	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(work1[pj]  *  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(work1[pj]  *  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(work1[pj]  *  sum);	  int    diagR[pj]    =    Math.abs(work1[pj]);    	non-compiled	[CE]  ']'  expected	58	None	replace
266	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(work1[pj]  *  sum2);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(work1[pj]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(work1[pj]  *  sum2);	  int    diagR[pj]    =    Math.abs(work1[pj]);    	non-compiled	[CE]  ']'  expected	58	None	replace
267	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diagR[pj].doubleValue()  *  1);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diagR[pj].doubleValue()  *  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diagR[pj].doubleValue()  *  1);	  double    dxNorm    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	23	None	replace
268	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	11	add
269	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	11	add
270	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	10	add
271	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	10	add
272	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	10	add
273	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	10	add
274	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	13	add
275	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	13	add
276	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	13	add
277	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	13	add
278	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	100	2	add
279	[BUG]  [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	100	2	add
280	[BUG]  [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  Work3[pj]  *=  work1[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work3  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  Work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work1[pj]    /    dxNorm;    Work3[pj]  *=  work1[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work3	100	None	add
281	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]    *=    work1[pj]    /    dxNorm;    work3[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	100	2	add
282	[BUG]  [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work1[pj]    /    dxNorm;    work3[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	100	2	add
283	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	100	2	add
284	[BUG]  [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	100	2	add
285	[BUG]  [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  double[pj]  *=  work1[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  double[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work1[pj]    /    dxNorm;    double[pj]  *=  work1[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	100	None	add
286	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]);	  double    dxNorm    =    Math.abs(diag[pj]);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	55	None	replace
287	[BUG]  [BUGGY]  double[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	16	None	replace
288	[BUG]  [BUGGY]  double[pj]  *=  work1[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[pj]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	16	None	replace
289	[BUG]  [BUGGY]  double[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[pj]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	16	None	replace
290	[BUG]  [BUGGY]  double[pj]  *=  work3[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	16	None	replace
291	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][j]  *  work2[i];  }  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][j]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][j]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	97	None	replace
292	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work3[i][j]  *  work2[i];  }  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work3[i][j]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work3[i][j]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	97	None	replace
293	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i][j]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i][j]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i][j]  *  work1[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	97	None	replace
294	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diagR[j]  *  Math.abs(pj));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diagR[j]  *  Math.abs(pj));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diagR[j]  *  Math.abs(pj));	  double    dxNorm    =    Math.abs(work1[j]    *    Math.abs(pj));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	80	None	replace
295	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diagR[pj]));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diagR[pj]));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diagR[pj]));	  double    dxNorm    =    Math.abs(work1[j]    *    Math.abs(pj));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	80	None	replace
296	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diagR[j]));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diagR[j]));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diagR[j]));	  double    dxNorm    =    Math.abs(work1[j]    *    Math.abs(pj));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	80	None	replace
297	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  sum2);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(work1[pj]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(work1[pj]  *  sum2);	  double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	19	None	replace
298	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]  *  sum2);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj]  *  sum2);	  double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	19	None	replace
299	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	38	2	add
300	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	38	2	add
301	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  int  work2[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  int  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work2[pj]    /    dxNorm;    int  work2[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	38	None	add
302	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  Work2[pj]  *=  work2[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work2  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  Work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work2[pj]    /    dxNorm;    Work2[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work2	38	None	add
303	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  job2[pj]  *=  work2[pj]  /  dxNorm;  [CE]  cannot  find  symbol  job2  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  job2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work2[pj]    /    dxNorm;    job2[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  job2	38	None	add
304	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]    *=    work2[pj]    /    dxNorm;    work2[j]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	38	2	add
305	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[j]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work2[pj]    /    dxNorm;    work2[j]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	38	2	add
306	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	11	add
307	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	11	add
308	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	10	add
309	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	10	add
310	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	10	add
311	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	10	add
312	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  Work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  Work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    Work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work1	12	None	add
313	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[j]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work1[j]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	11	add
314	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[j]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[j]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work1[j]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	11	add
315	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(pj  +  1),  sum2);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(pj  +  1),  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(pj  +  1),  sum2);	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(pj    +    1));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	replace
316	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(sum2  +  1));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(sum2  +  1));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(sum2  +  1));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(pj    +    1));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	replace
317	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(pj  +  1),  sum);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(pj  +  1),  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(pj  +  1),  sum);	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(pj    +    1));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	replace
318	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[0]  /  dxNorm);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[0]  /  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[0]  /  dxNorm);	  int    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	60	None	replace
319	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[1]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[1]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[1]);	  int    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	60	None	replace
320	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[0]  -  1);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[0]  -  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[0]  -  1);	  int    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	60	None	replace
321	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	118	13	add
322	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	118	13	add
323	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	118	13	add
324	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	118	13	add
325	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	118	13	add
326	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	118	13	add
327	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  Work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  Work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    Work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work1	118	None	add
328	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work1[j]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	118	13	add
329	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work1[j]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	118	13	add
330	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[pj]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work1[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(work1[pj]);	  double    diagR[pj]    =    Math.sqrt(diagR[pj]);    	non-compiled	[CE]  ']'  expected	70	None	replace
331	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj]  *  sum2);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[pj]  *  sum2);	  double    diagR[pj]    =    Math.sqrt(diagR[pj]);    	non-compiled	[CE]  ']'  expected	70	None	replace
332	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj]  *  sum);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj]  *  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[pj]  *  sum);	  double    diagR[pj]    =    Math.sqrt(diagR[pj]);    	non-compiled	[CE]  ']'  expected	70	None	replace
333	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.log(diagR[pj]);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.log(diagR[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.log(diagR[pj]);	  double    diagR[pj]    =    Math.sqrt(diagR[pj]);    	non-compiled	[CE]  ']'  expected	70	None	replace
334	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[i]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[i]);	  double    diagR[pj]    =    Math.sqrt(diagR);    	non-compiled	[CE]  ']'  expected	104	None	replace
335	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[pj].doubleValue()  +  1);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[pj].doubleValue()  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[pj].doubleValue()  +  1);	  double    dxNorm    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
336	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[pj].doubleValue()  +  sum2);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[pj].doubleValue()  +  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[pj].doubleValue()  +  sum2);	  double    dxNorm    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
337	[BUG]  [BUGGY]  Work1[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  Work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	Work1[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    Work1[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  Work1	15	None	replace
338	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
339	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
340	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
341	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
342	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
343	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
344	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
345	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
346	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
347	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
348	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j].doubleValue());  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j].doubleValue());	  double    dxNorm    =    Math.abs(diag[pj].doubleValue());    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	21	None	replace
349	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[pj].doubleValue()  +  1);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[pj].doubleValue()  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[pj].doubleValue()  +  1);	  double    dxNorm    =    Math.abs(diag[pj].doubleValue());    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	21	None	replace
350	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[pj].doubleValue()  +  sum2);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[pj].doubleValue()  +  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[pj].doubleValue()  +  sum2);	  double    dxNorm    =    Math.abs(diag[pj].doubleValue());    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	21	None	replace
351	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	32	2	add
352	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	32	2	add
353	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  Work2[pj]  *=  work3[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work2  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  Work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work3[pj]    /    dxNorm;    Work2[pj]  *=  work3[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work2	32	None	add
354	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  job2[pj]  *=  work3[pj]  /  dxNorm;  [CE]  cannot  find  symbol  job2  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  job2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work3[pj]    /    dxNorm;    job2[pj]  *=  work3[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  job2	32	None	add
355	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]    *=    work3[pj]    /    dxNorm;    work2[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	32	2	add
356	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work3[pj]    /    dxNorm;    work2[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	32	2	add
357	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  double[pj]  *=  work3[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  double[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work3[pj]    /    dxNorm;    double[pj]  *=  work3[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	32	None	add
358	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
359	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
360	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
361	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
362	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
363	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
364	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
365	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
366	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[j]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[j]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
367	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[j]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work1[j]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[j]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
368	[BUG]  [BUGGY]  Double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  Double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	Double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    2);    	non-compiled	[CE]  ']'  expected	128	None	replace
369	[BUG]  [BUGGY]  []  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  []  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    2);    	non-compiled	[CE]  illegal  start  of  expression	128	None	replace
370	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.rint(rank);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.rint(rank);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.rint(rank);	  double    diagR[pj]    =    Math.log(rank);    	non-compiled	[CE]  ']'  expected	72	None	replace
371	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.log(parl);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.log(parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.log(parl);	  double    diagR[pj]    =    Math.log(rank);    	non-compiled	[CE]  ']'  expected	72	None	replace
372	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  1);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  *  1);	  double    diagR[pj]    =    Math.abs(diagR[pj]    +    1);    	non-compiled	[CE]  ']'  expected	133	None	replace
373	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  /  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  /  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  /  1);	  double    diagR[pj]    =    Math.abs(diagR[pj]    +    1);    	non-compiled	[CE]  ']'  expected	133	None	replace
374	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work1[pj]  +  1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(work1[pj]  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(work1[pj]  +  1);	  double    diagR[pj]    =    Math.abs(diagR[pj]    +    1);    	non-compiled	[CE]  ']'  expected	133	None	replace
375	[BUG]  [BUGGY]  Work2[pj]  *=  diag[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work2  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  Work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	Work2[pj]  *=  diag[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    Work2[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  Work2	64	None	replace
376	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work1[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work3[pj]    /    diagR[pj];    work1[pj]  *=  work3[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	34	13	add
377	[BUG]  [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work1[pj]  *=  work3[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work1[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work3[pj]    /    diagR[pj];    work1[pj]  *=  work3[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	34	13	add
378	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work3[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work3[pj]    /    diagR[pj];    work3[pj]  *=  work3[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	34	13	add
379	[BUG]  [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work3[pj]  *=  work3[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work3[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work3[pj]    /    diagR[pj];    work3[pj]  *=  work3[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	34	13	add
380	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work2[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work3[pj]    /    diagR[pj];    work2[pj]  *=  work3[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	34	13	add
381	[BUG]  [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work2[pj]  *=  work3[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work2[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work3[pj]    /    diagR[pj];    work2[pj]  *=  work3[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	34	13	add
382	[BUG]  [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  Work1[pj]  *=  work3[pj]  /  diagR[pj];  [CE]  cannot  find  symbol  Work1  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  Work1[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work3[pj]    /    diagR[pj];    Work1[pj]  *=  work3[pj]  /  diagR[pj];	  	non-compiled	[CE]  cannot  find  symbol  Work1	34	None	add
383	[BUG]  [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  double[pj]  *=  work3[pj]  /  diagR[pj];  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  double[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work3[pj]    /    diagR[pj];    double[pj]  *=  work3[pj]  /  diagR[pj];	  	non-compiled	[CE]  ']'  expected	34	None	add
384	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work2[pj]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(work2[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(work2[pj]);	  double    diagR[pj]    =    Math.abs(work1[pj]);    	non-compiled	[CE]  ']'  expected	29	None	replace
385	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work1[pj]  *  sum);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(work1[pj]  *  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(work1[pj]  *  sum);	  double    diagR[pj]    =    Math.abs(work1[pj]);    	non-compiled	[CE]  ']'  expected	29	None	replace
386	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  sum;  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  sum;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  sum;	  work1[pj]    *=    work2[pj]    /    sum2;    	non-compiled	[CE]  cannot  find  symbol  sum	28	None	replace
387	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  parl;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]  *=  work2[pj]  /  parl;	  work1[pj]    *=    work2[pj]    /    sum2;    	compilable	  [FE]  AssertionFailedError  	28	13	replace
388	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  parl;  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  parl;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  parl;	  work1[pj]    *=    work2[pj]    /    sum2;    	compilable	  [FE]  AssertionFailedError  	28	13	replace
389	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  jacobian;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  jacobian;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  jacobian;	  work1[pj]    *=    work2[pj]    /    sum2;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	28	None	replace
390	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work1[pj]  *=  work1.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work1.length    /    dxNorm;    work1[pj]  *=  work1.length  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	131	11	add
391	[BUG]  [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work1[pj]  *=  work1.length  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work1[pj]  *=  work1.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1.length    /    dxNorm;    work1[pj]  *=  work1.length  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	131	11	add
392	[BUG]  [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  Work1[pj]  *=  work1.length  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  Work1[pj]  *=  work1.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1.length    /    dxNorm;    Work1[pj]  *=  work1.length  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work1	131	None	add
393	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work2[pj]  *=  work1.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work1.length    /    dxNorm;    work2[pj]  *=  work1.length  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	131	10	add
394	[BUG]  [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work2[pj]  *=  work1.length  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work2[pj]  *=  work1.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1.length    /    dxNorm;    work2[pj]  *=  work1.length  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	131	10	add
395	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work1[pj]  *=  work2.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work1.length    /    dxNorm;    work1[pj]  *=  work2.length  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	131	11	add
396	[BUG]  [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work1[pj]  *=  work2.length  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work1[pj]  *=  work2.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1.length    /    dxNorm;    work1[pj]  *=  work2.length  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	131	11	add
397	[BUG]  [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work1.[pj]  *=  work1.length  /  dxNorm;  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  work1.[pj]  *=  work1.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1.length    /    dxNorm;    work1.[pj]  *=  work1.length  /  dxNorm;	  	non-compiled	[CE]  <identifier>  expected	131	None	add
398	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    work1[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	90	None	replace
399	[BUG]  [BUGGY]  int  work1[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  work1[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  work1[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    work1[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	90	None	replace
400	[BUG]  [BUGGY]  work1[j]  *=  work2[j]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[j]  *=  work2[j]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[j]  *=  work2[j]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    work1[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	90	None	replace
401	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	2	add
402	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	2	add
403	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  double[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  double[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    double[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	61	None	add
404	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[j]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work2[j]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	2	add
405	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[j]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[j]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work2[j]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	2	add
406	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  %  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  %  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	2	add
407	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  %  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  %  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  %  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	2	add
408	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	13	add
409	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	13	add
410	[BUG]  [BUGGY]  Work1[pj]  *=  work1[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  Work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	Work1[pj]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    Work1[pj]    *=    work1[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  Work1	50	None	replace
411	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work1[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work2[pj]    /    diagR[pj];    work1[pj]  *=  work2[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	24	13	add
412	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work1[pj]  *=  work2[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work1[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work2[pj]    /    diagR[pj];    work1[pj]  *=  work2[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	24	13	add
413	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work2[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work2[pj]    /    diagR[pj];    work2[pj]  *=  work2[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	24	13	add
414	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work2[pj]  *=  work2[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work2[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work2[pj]    /    diagR[pj];    work2[pj]  *=  work2[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	24	13	add
415	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  Work1[pj]  *=  work2[pj]  /  diagR[pj];  [CE]  cannot  find  symbol  Work1  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  Work1[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work2[pj]    /    diagR[pj];    Work1[pj]  *=  work2[pj]  /  diagR[pj];	  	non-compiled	[CE]  cannot  find  symbol  Work1	24	None	add
416	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  int  work1[pj]  *=  work2[pj]  /  diagR[pj];  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  int  work1[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work2[pj]    /    diagR[pj];    int  work1[pj]  *=  work2[pj]  /  diagR[pj];	  	non-compiled	[CE]  ']'  expected	24	None	add
417	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  double[pj]  *=  work2[pj]  /  diagR[pj];  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  double[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work2[pj]    /    diagR[pj];    double[pj]  *=  work2[pj]  /  diagR[pj];	  	non-compiled	[CE]  ']'  expected	24	None	add
418	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  work2[j]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[j]  *=  work2[j]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	87	7	replace
419	[BUG]  [BUGGY]  work2[j]  *=  work2[j]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[j]  *=  work2[j]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[j]  *=  work2[j]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	87	7	replace
420	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  /  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  /  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  /  sum);	  double    diagR[pj]    =    Math.abs(diagR[pj]    *    sum);    	non-compiled	[CE]  ']'  expected	31	None	replace
421	[BUG]  [BUGGY]  double[pj]  *=  diag[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[pj]  *=  diag[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    double[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	65	None	replace
422	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
423	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
424	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
425	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
426	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
427	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
428	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
429	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
430	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
431	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
432	[BUG]  [BUGGY]  double  work2[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  work2[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double    work1[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	98	None	replace
433	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work2[j];  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work2[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work2[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work1[j];    	non-compiled	[CE]  illegal  start  of  expression	142	None	replace
434	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum2);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(sum2);	  double    diagR[pj]    =    Math.sqrt(parl);    	non-compiled	[CE]  ']'  expected	73	None	replace
435	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  /  dxNorm);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  /  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[0]  /  dxNorm);	  double    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	114	None	replace
436	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[1]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[1]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[1]);	  double    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	114	None	replace
437	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  *  sum2);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[0]  *  sum2);	  double    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	114	None	replace
438	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  +  sum2);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  +  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[0]  +  sum2);	  double    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	114	None	replace
439	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[0]  *=  work2[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[0]  *=  work2[0]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	147	4	replace
440	[BUG]  [BUGGY]  work1[0]  *=  work2[0]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[0]  *=  work2[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[0]  *=  work2[0]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	147	4	replace
441	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work1[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	95	None	replace
442	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  foundCols;  ++i)  {  sum  +=  work1[i][pj]  *  work1[i];  }  [CE]  cannot  find  symbol  foundCols  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  foundCols;  ++i)  {  sum  +=  work1[i][pj]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  foundCols;  ++i)  {  sum  +=  work1[i][pj]  *  work1[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  foundCols	95	None	replace
443	[BUG]  [BUGGY]  work1.[pj]  *=  work1[pj]  /  dxNorm;  [CE]  <identifier>  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1.[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1.[pj]  *=  work1[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work1.[pj]    *=    work1[pj]    /    dxNorm;    	non-compiled	[CE]  <identifier>  expected	148	None	replace
444	[BUG]  [BUGGY]  work1[pj]  *=  work4[pj]  /  diagR[pj];  [CE]  cannot  find  symbol  work4  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work4[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work4[pj]  /  diagR[pj];	  work1[pj]    *=    work3[pj]    /    diagR[pj];    	non-compiled	[CE]  cannot  find  symbol  work4	35	None	replace
445	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2);	  int    diagR[pj]    =    Math.abs(diagR[pj]    *    sum);    	non-compiled	[CE]  ']'  expected	59	None	replace
446	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  /  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  /  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj]  /  sum);	  double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    sum);    	non-compiled	[CE]  ']'  expected	20	None	replace
447	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	26	2	add
448	[BUG]  [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	26	2	add
449	[BUG]  [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  Work2[pj]  *=  work1[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work2  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  Work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work1[pj]    /    dxNorm;    Work2[pj]  *=  work1[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work2	26	None	add
450	[BUG]  [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  job2[pj]  *=  work1[pj]  /  dxNorm;  [CE]  cannot  find  symbol  job2  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  job2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work1[pj]    /    dxNorm;    job2[pj]  *=  work1[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  job2	26	None	add
451	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]    *=    work1[pj]    /    dxNorm;    work2[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	26	2	add
452	[BUG]  [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work1[pj]    /    dxNorm;    work2[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	26	2	add
453	[BUG]  [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  double[pj]  *=  work1[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  double[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work1[pj]    /    dxNorm;    double[pj]  *=  work1[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	26	None	add
454	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	diag[pj]  *=  diag[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
455	[BUG]  [BUGGY]  diag[pj]  *=  diag[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	diag[pj]  *=  diag[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
456	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  diag[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	diag[pj]  *=  work3[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
457	[BUG]  [BUGGY]  diag[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  diag[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	diag[pj]  *=  work3[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
458	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  diag[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	diag[pj]  *=  work2[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
459	[BUG]  [BUGGY]  diag[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  diag[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	diag[pj]  *=  work2[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
460	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work1[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work1[pj]    /    diagR[pj];    work1[pj]  *=  work1[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	68	7	add
461	[BUG]  [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work1[pj]  *=  work1[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work1[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1[pj]    /    diagR[pj];    work1[pj]  *=  work1[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	68	7	add
462	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work2[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work1[pj]    /    diagR[pj];    work2[pj]  *=  work1[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	68	5	add
463	[BUG]  [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work2[pj]  *=  work1[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work2[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1[pj]    /    diagR[pj];    work2[pj]  *=  work1[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	68	5	add
464	[BUG]  [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  Work1[pj]  *=  work1[pj]  /  diagR[pj];  [CE]  cannot  find  symbol  Work1  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  Work1[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1[pj]    /    diagR[pj];    Work1[pj]  *=  work1[pj]  /  diagR[pj];	  	non-compiled	[CE]  cannot  find  symbol  Work1	68	None	add
465	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work3[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work1[pj]    /    diagR[pj];    work3[pj]  *=  work1[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	68	5	add
466	[BUG]  [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work3[pj]  *=  work1[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work3[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1[pj]    /    diagR[pj];    work3[pj]  *=  work1[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	68	5	add
467	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work1[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work1[pj]    /    diagR[pj];    work1[pj]  *=  work2[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	68	13	add
468	[BUG]  [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work1[pj]  *=  work2[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work1[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1[pj]    /    diagR[pj];    work1[pj]  *=  work2[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	68	13	add
469	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[pj].doubleValue());  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(work1[pj].doubleValue());	  double[]    work2[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	41	None	replace
470	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  1);	  double[]    work2[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	41	None	replace
471	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work1.length[pj].doubleValue());  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(work1.length[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(work1.length[pj].doubleValue());	  double[]    work2[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	41	None	replace
472	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm  +  1;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  work1[pj]  /  dxNorm  +  1;	  work2[pj]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	27	7	replace
473	[BUG]  [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm  +  1;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm  +  1;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work1[pj]  /  dxNorm  +  1;	  work2[pj]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	27	7	replace
474	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	94	None	replace
475	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  foundCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  cannot  find  symbol  foundCols  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  foundCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  foundCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  foundCols	94	None	replace
476	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i][pj]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i][pj]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work2[i][pj]  *  work1[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	94	None	replace
477	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]  *  sum2);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]  *  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[0]  *  sum2);	  double    diagR[pj]    =    Math.sqrt(diagR[0]);    	non-compiled	[CE]  ']'  expected	103	None	replace
478	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]  /  dxNorm);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]  /  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[0]  /  dxNorm);	  double    diagR[pj]    =    Math.sqrt(diagR[0]);    	non-compiled	[CE]  ']'  expected	103	None	replace
479	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[1]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[1]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[1]);	  double    diagR[pj]    =    Math.sqrt(diagR[0]);    	non-compiled	[CE]  ']'  expected	103	None	replace
480	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]  +  dxNorm);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]  +  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[0]  +  dxNorm);	  double    diagR[pj]    =    Math.sqrt(diagR[0]);    	non-compiled	[CE]  ']'  expected	103	None	replace
481	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diagr[pj]);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diagr[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diagr[pj]);	  double    dxNorm    =    Math.abs(work2[pj]);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	127	None	replace
482	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[0]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[0]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	85	4	replace
483	[BUG]  [BUGGY]  work1[0]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[0]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[0]  *=  work2[pj]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	85	4	replace
484	[BUG]  [BUGGY]  work2[pj]  *=  work1[pj]  /  diagR;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  diagR;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work1[pj]  /  diagR;	  work1[pj]    *=    work2[pj]    /    diagR;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	111	None	replace
485	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]  *=  work2[pj]  /  diagR[j];	  work1[pj]    *=    work2[pj]    /    diagR;    	compilable	  [FE]  AssertionFailedError  	111	13	replace
486	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[j];  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  diagR[j];	  work1[pj]    *=    work2[pj]    /    diagR;    	compilable	  [FE]  AssertionFailedError  	111	13	replace
487	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	3	13	add
488	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	3	13	add
489	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	3	13	add
490	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	3	13	add
491	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	3	13	add
492	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	3	13	add
493	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	3	13	add
494	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	3	13	add
495	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	3	13	add
496	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[j]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	3	13	add
497	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[0]  *=  diagR[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[0]  *=  diagR[0]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]    *=    diagR[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	13	7	replace
498	[BUG]  [BUGGY]  work2[0]  *=  diagR[0]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[0]  *=  diagR[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[0]  *=  diagR[0]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]    *=    diagR[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	13	7	replace
499	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(rank));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(rank));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(rank));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(sum2));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	78	None	replace
500	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(sum2),  parl);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(sum2),  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(sum2),  parl);	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(sum2));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	78	None	replace
501	[BUG]  [BUGGY]  int  pj  =  work2[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  pj  =  work2[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  pj  =  work2[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work2[j];    }    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	141	None	replace
502	[BUG]  [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  Work1[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  Work1[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  diagR[pj]  /  dxNorm;  Work1[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    Work1[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  Work1	15	None	replace
503	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm);	  double    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	30	None	replace
504	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm;	  double    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	30	None	replace
505	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  /  sum2);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  /  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  /  sum2);	  double    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	30	None	replace
506	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2)+  1;  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2)+  1;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2)+  1;	  double    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	30	None	replace
507	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  Work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work2  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  Work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    Work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work2	61	None	add
508	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  diagR;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  diagR;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  work2[pj]  /  diagR;	  work3[pj]    *=    work2[pj]    /    dxNorm;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	107	None	replace
509	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  jacobian;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  jacobian;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  work2[pj]  /  jacobian;	  work3[pj]    *=    work2[pj]    /    dxNorm;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	107	None	replace
510	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[pj]);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(work2[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(work2[pj]);	  double[]    work2[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	17	None	replace
511	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work2);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(work2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(work2);	  double[]    work2[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	17	None	replace
512	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue()  +  2);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue()  +  2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[pj].doubleValue()  +  2);	  double    diagR[pj]    =    Math.sqrt(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	105	None	replace
513	[BUG]  [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  int  work2[pj]  *=  work1[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  int  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work1[pj]    /    dxNorm;    int  work2[pj]  *=  work1[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	26	None	add
514	[BUG]  [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  double  work2[pj]  *=  work1[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work1[pj]  /  dxNorm;  double  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work1[pj]    /    dxNorm;    double  work2[pj]  *=  work1[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	26	None	add
515	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[0]);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[0]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[0]);	  double    dxNorm    =    Math.abs(diag[pj]);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	55	None	replace
516	[BUG]  [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  double  work1[pj]  *=  work3[pj]  /  diagR[pj];  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  double  work1[pj]  *=  work3[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work3[pj]    /    diagR[pj];    double  work1[pj]  *=  work3[pj]  /  diagR[pj];	  	non-compiled	[CE]  ']'  expected	34	None	add
517	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	10	add
518	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	10	add
519	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	11	add
520	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	11	add
521	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diagr[pj].doubleValue());  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diagr[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diagr[pj].doubleValue());	  double    dxNorm    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	23	None	replace
522	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(work3[pj].doubleValue());  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(work3[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(work3[pj].doubleValue());	  int    diagR[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	83	None	replace
523	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(parl  +  1));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(parl  +  1));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(parl  +  1));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(pj    +    1));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	replace
524	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(rank  +  1));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(rank  +  1));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(rank  +  1));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(pj    +    1));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	79	None	replace
525	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(work1[pj  +  1));  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(work1[pj  +  1));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(work1[pj  +  1));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(pj    +    1));    	non-compiled	[CE]  ']'  expected	79	None	replace
526	[BUG]  [BUGGY]  work3[pj]  *=  work1[pj]  /  diagR;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  diagR;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  work1[pj]  /  diagR;	  work3[pj]    *=    work1[pj]    /    dxNorm;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	101	None	replace
527	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  work1[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    work1[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  ']'  expected	90	None	replace
528	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm);	  double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    sum);    	non-compiled	[CE]  ']'  expected	20	None	replace
529	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  d  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  d  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  d	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work2[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  ';'  expected	89	None	replace
530	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  diagR;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work2[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work2[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	89	None	replace
531	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work3[pj].doubleValue());  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(work3[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(work3[pj].doubleValue());	  double    diagR[pj]    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	44	None	replace
532	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	40	None	replace
533	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work2[pj].doubleValue());  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work2[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work2[pj].doubleValue());	  double    dxNorm    =    Math.abs(work1[pj].doubleValue());    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
534	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diag);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diag);	  double    diagR[pj]    =    Math.sqrt(dxNorm);    	non-compiled	[CE]  ']'  expected	143	None	replace
535	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]  -  parl);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]  -  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[0]  -  parl);	  double[]    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	122	None	replace
536	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]  +  parl);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]  +  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[0]  +  parl);	  double[]    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	122	None	replace
537	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[0]  *=  work3[0]  /  dxNorm;  work1[0]  *=  work3[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[0]  *=  work3[0]  /  dxNorm;  work1[0]  *=  work3[0]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	2	8	replace
538	[BUG]  [BUGGY]  work1[0]  *=  work3[0]  /  dxNorm;  work1[0]  *=  work3[0]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[0]  *=  work3[0]  /  dxNorm;  work1[0]  *=  work3[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[0]  *=  work3[0]  /  dxNorm;  work1[0]  *=  work3[0]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	2	8	replace
539	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum2)+  1;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum2)+  1;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum2)+  1;	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	42	None	replace
540	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  dxNorm);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  dxNorm);	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	42	None	replace
541	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  total);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  total);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  total);	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	42	None	replace
542	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  pj;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }	          for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	115	None	replace
543	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  qy;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }  [CE]  bad  operand  types  for  binary  operator  '<'  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  qy;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  qy;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }	          for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work1[i];    }    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '<'	115	None	replace
544	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pp;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }  [CE]  cannot  find  symbol  pp  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  pp;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  pp;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }	          for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  pp	115	None	replace
545	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.floor(diagR[pj]);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.floor(diagR[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.floor(diagR[pj]);	  double    diagR[pj]    =    Math.log(rank);    	non-compiled	[CE]  ']'  expected	72	None	replace
546	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.log(diagR);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.log(diagR);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.log(diagR);	  double    diagR[pj]    =    Math.log(rank);    	non-compiled	[CE]  ']'  expected	72	None	replace
547	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum2)+  1;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum2)+  1;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum2)+  1;	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	45	None	replace
548	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  dxNorm);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  dxNorm);	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	45	None	replace
549	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[pj].doubleValue());  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(work3[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(work3[pj].doubleValue());	  double[]    work2[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	41	None	replace
550	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  dxNorm);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(diagR[pj].doubleValue()  +  dxNorm);	  double[]    work2[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	41	None	replace
551	[BUG]  [BUGGY]  int  pj  =  solveCols[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  pj  =  solveCols[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  pj  =  solveCols[j];	  for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    solvedCols[j];    }    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	75	None	replace
552	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  jacobian[pj];  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  jacobian[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  jacobian[pj];	  work1[pj]    *=    work2[pj]    /    diagR[pj];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	25	None	replace
553	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  Work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  Work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    Work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work1	12	None	add
554	[BUG]  [BUGGY]  double  diagR[0]  *=  diagR[0]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[0]  *=  diagR[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[0]  *=  diagR[0]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double    diagR[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	99	None	replace
555	[BUG]  [BUGGY]  double  diagR[pj]  *=  workR[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  *=  workR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  *=  workR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double    diagR[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	99	None	replace
556	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
557	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
558	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
559	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
560	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  work2[pj]  /  diagR[pj];	  work2[pj]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	27	7	replace
561	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work2[pj]  /  diagR[pj];	  work2[pj]    *=    work1[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	27	7	replace
562	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  diagR;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  diagR;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work2[pj]  /  diagR;	  work2[pj]    *=    work1[pj]    /    dxNorm;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	27	None	replace
563	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
564	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	1	13	add
565	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	43	None	replace
566	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work3[pj]);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work3[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work3[pj]);	  double    dxNorm    =    Math.abs(work2[pj]);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	127	None	replace
567	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  work2.length;  ++j)  {  int  pj  =  work3[j];  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  work2.length;  ++j)  {  int  pj  =  work3[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  work2.length;  ++j)  {  int  pj  =  work3[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work3[j];    	non-compiled	[CE]  illegal  start  of  expression	140	None	replace
568	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work[j];  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  work[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work3[j];    	non-compiled	[CE]  illegal  start  of  expression	140	None	replace
569	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  sum  +=  solved[i][pj]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  diagR.length;  ++i)  {  sum  +=  solved[i][pj]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  diagR.length;  ++i)  {  sum  +=  solved[i][pj]  *  work1[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	95	None	replace
570	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][pj]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][pj]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][pj]  *  work1[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	95	None	replace
571	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diag));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diag));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diag));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(work1));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	130	None	replace
572	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  total);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  total);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  *  total);	  double    diagR[pj]    =    Math.abs(diagR[pj]    *    sum);    	non-compiled	[CE]  ']'  expected	31	None	replace
573	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  graph;  [CE]  cannot  find  symbol  graph  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  graph;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  graph;	  work1[pj]    *=    work2[pj]    /    diagR;    	non-compiled	[CE]  cannot  find  symbol  graph	111	None	replace
574	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  Work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work2  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  Work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    Work2[pj]  *=  diag[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work2	66	None	add
575	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work3[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]    *=    work2[pj]    /    diagR[pj];    work3[pj]  *=  work2[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	24	13	add
576	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work3[pj]  *=  work2[pj]  /  diagR[pj];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work3[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work2[pj]    /    diagR[pj];    work3[pj]  *=  work2[pj]  /  diagR[pj];	  	compilable	  [FE]  AssertionFailedError  	24	13	add
577	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  double  work1[pj]  *=  work2[pj]  /  diagR[pj];  [CE]  ']'  expected  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  double  work1[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work2[pj]    /    diagR[pj];    double  work1[pj]  *=  work2[pj]  /  diagR[pj];	  	non-compiled	[CE]  ']'  expected	24	None	add
578	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  work2.length;  ++j)  {  int  pj  =  work1[j];  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  work2.length;  ++j)  {  int  pj  =  work1[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  work2.length;  ++j)  {  int  pj  =  work1[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work1[j];    	non-compiled	[CE]  illegal  start  of  expression	142	None	replace
579	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work2[j]  *  Math.abs(pj));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work2[j]  *  Math.abs(pj));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work2[j]  *  Math.abs(pj));	  double    dxNorm    =    Math.abs(work1[j]    *    Math.abs(pj));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	80	None	replace
580	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(sum2));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(sum2));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(sum2));	  double    dxNorm    =    Math.abs(work1[j]    *    Math.abs(pj));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	80	None	replace
581	[BUG]  [BUGGY]  work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dk;  [CE]  cannot  find  symbol  dk  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dk;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dk;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  dk	13	None	replace
582	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  double  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  double  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    double  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	86	None	add
583	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	86	13	add
584	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	86	13	add
585	[BUG]  [BUGGY]  int  j  =  work3[j];  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  j  =  work3[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  j  =  work3[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work3[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	139	None	replace
586	[BUG]  [BUGGY]  work2[pj]  *=  work4[pj]  /  dxNorm;  [CE]  cannot  find  symbol  work4  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work4[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work4[pj]  /  dxNorm;	  work2[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  work4	37	None	replace
587	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
588	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
589	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
590	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
591	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[0]  *=  work2[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[0]  *=  work2[0]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	119	7	replace
592	[BUG]  [BUGGY]  work3[0]  *=  work2[0]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[0]  *=  work2[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[0]  *=  work2[0]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	119	7	replace
593	[BUG]  [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  double  work1[pj]  *=  work1.length  /  dxNorm;  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1.length  /  dxNorm;  double  work1[pj]  *=  work1.length  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1.length    /    dxNorm;    double  work1[pj]  *=  work1.length  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	131	None	add
594	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj]  +  1);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[pj]  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[pj]  +  1);	  double    diagR[pj]    =    Math.sqrt(diagR[j]);    	non-compiled	[CE]  ']'  expected	71	None	replace
595	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][pj]  *  work3[i];  }  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][pj]  *  work3[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][pj]  *  work3[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work3[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	96	None	replace
596	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  work1[i][pj]  *  work3[i];  }  [CE]  cannot  find  symbol  solvesCols  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  work1[i][pj]  *  work3[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  work1[i][pj]  *  work3[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work3[i];    }    	non-compiled	[CE]  cannot  find  symbol  solvesCols	96	None	replace
597	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work4[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  cannot  find  symbol  work4  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work4[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work4[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  work4	134	None	add
598	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  %  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  %  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	11	add
599	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  %  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  %  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  %  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	11	add
600	[BUG]  [BUGGY]  work1[pj]  *=  diagR[pj]  /  work3;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  diagR[pj]  /  work3;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  diagR[pj]  /  work3;	  work1[pj]    *=    work3[pj]    /    diagR;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	137	None	replace
601	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  +  dxNorm);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  +  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  +  dxNorm);	  double    diagR[pj]    =    Math.abs(diagR[pj]    +    1);    	non-compiled	[CE]  ']'  expected	133	None	replace
602	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm);	  int    diagR[pj]    =    Math.abs(diagR[pj]    *    sum);    	non-compiled	[CE]  ']'  expected	59	None	replace
603	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj]  /  sum);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj]  /  sum);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj]  /  sum);	  int    diagR[pj]    =    Math.abs(diagR[pj]    *    sum);    	non-compiled	[CE]  ']'  expected	59	None	replace
604	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  int  work2[pj]  *=  work3[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  int  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work3[pj]    /    dxNorm;    int  work2[pj]  *=  work3[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	32	None	add
605	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][pj]  *  work2[i];  }  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][pj]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][pj]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	94	None	replace
606	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work3[i][pj]  *  work2[i];  }  [CE]  cannot  find  symbol  sum  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work3[i][pj]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work3[i][pj]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	94	None	replace
607	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  cannot  find  symbol  solvesCols  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvesCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  solvesCols	94	None	replace
608	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  dxNorm);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  +  dxNorm);	  int    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    parl);    	non-compiled	[CE]  ']'  expected	129	None	replace
609	[BUG]  [BUGGY]  double[]  work3[pj]  =  Math.abs(work3[pj]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work3[pj]  =  Math.abs(work3[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work3[pj]  =  Math.abs(work3[pj]);	  double[]    work3[pj]    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  ']'  expected	123	None	replace
610	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  double  work2[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  double  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    work2[pj]    /    dxNorm;    double  work2[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	38	None	add
611	[BUG]  [BUGGY]  work4[pj]  *=  work3[pj]  /  dxNorm;  [CE]  cannot  find  symbol  work4  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work4[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work4[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]    *=    work3[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  work4	4	None	replace
612	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()).doubleValue();	  int    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    1);    	non-compiled	[CE]  ']'  expected	82	None	replace
613	[BUG]  [BUGGY]  Integer  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  Integer  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	Integer  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());	  int    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    2);    	non-compiled	[CE]  ']'  expected	120	None	replace
614	[BUG]  [BUGGY]  int  work2[pj]  *=  work3[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  work2[pj]  *=  work3[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    int    work2[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	63	None	replace
615	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(work3[pj]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(work3[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(work3[pj]);	  double    diagR[pj]    =    Math.abs(work1[pj]);    	non-compiled	[CE]  ']'  expected	29	None	replace
616	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  jacobian;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  jacobian;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work3[pj]  /  jacobian;	  work2[pj]    *=    work3[pj]    /    dxNorm;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	33	None	replace
617	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  dxNorm;	  double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	19	None	replace
618	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  /  sum2);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  /  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj]  /  sum2);	  double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	19	None	replace
619	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2)+  1;  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2)+  1;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2)+  1;	  double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	19	None	replace
620	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  Work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  Work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    Work1[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work1	5	None	add
621	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
622	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	5	13	add
623	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  +  dxNorm);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  +  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[0]  +  dxNorm);	  double    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	114	None	replace
624	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  +  parl);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  +  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[0]  +  parl);	  double    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	114	None	replace
625	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
626	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work1[j]  *=  work3[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work1[j]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work2[j]  *=  work3[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	8	13	add
627	[BUG]  [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  double  work3[pj]  *=  work1[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work1[pj]  /  dxNorm;  double  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work1[pj]    /    dxNorm;    double  work3[pj]  *=  work1[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	100	None	add
628	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  Work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work1  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  Work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    Work1[pj]  *=  work3[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work1	3	None	add
629	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]  *  dxNorm);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0]  *  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[0]  *  dxNorm);	  double    diagR[pj]    =    Math.sqrt(diagR[0]);    	non-compiled	[CE]  ']'  expected	103	None	replace
630	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  sum  +=  solved[i][j]  *  work2[i];  }  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  pj;  ++i)  {  sum  +=  solved[i][j]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  pj;  ++i)  {  sum  +=  solved[i][j]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	97	None	replace
631	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][j]  *  work2[i];  }  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][j]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work[i][j]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	97	None	replace
632	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work2.length[pj].doubleValue());  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work2.length[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work2.length[pj].doubleValue());	  double    dxNorm    =    Math.abs(work1.length[pj].doubleValue());    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	102	None	replace
633	[BUG]  [BUGGY]  work1[0]  *=  work2[0]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[0]  *=  work2[0]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[0]  *=  work2[0]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	88	None	replace
634	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  work2[pj]  /  dxNorm;  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  work1[pj]  *=  work2[pj]  /  dxNorm;  }	  work1[pj]    *=    work2[pj]    /    dxNorm;    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    work1[pj]    *=    work2[pj]    /    dxNorm;    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	88	None	replace
635	[BUG]  [BUGGY]  int  j  =  work1[j];  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  j  =  work1[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  j  =  work1[j];	  for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work1[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	77	None	replace
636	[BUG]  [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  work1[j];  }  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  work1[j];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  work1[j];  }	  for(int    i    =    0;    j    <    solvedCols;    ++i)    {    int    pj    =    permutation[j];    }    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	76	None	replace
637	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[0]  -  parl);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[0]  -  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[0]  -  parl);	  int    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	60	None	replace
638	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[0]  +  dxNorm);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[0]  +  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[0]  +  dxNorm);	  int    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	60	None	replace
639	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[0]  *=  work2[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[0]  *=  work2[0]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	87	7	replace
640	[BUG]  [BUGGY]  work2[0]  *=  work2[0]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[0]  *=  work2[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[0]  *=  work2[0]  /  dxNorm;	  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]    *=    work2[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	87	7	replace
641	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diagR[pj]  *  sum2;  [CE]  ')'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diagR[pj]  *  sum2;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diagR[pj]  *  sum2;	  double    dxNorm    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ')'  expected	126	None	replace
642	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diagR[pj]  *  sum2)+  1;  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diagR[pj]  *  sum2)+  1;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diagR[pj]  *  sum2)+  1;	  double    dxNorm    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	126	None	replace
643	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(level));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(level));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(level));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(sum2));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	78	None	replace
644	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[pj]  *  work3);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[pj]  *  work3);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[pj]  *  work3);	  double    dxNorm    =    Math.abs(diag[pj]    *    sum2);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	56	None	replace
645	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[pj]  *  work3;  [CE]  ')'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[pj]  *  work3;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[pj]  *  work3;	  double    dxNorm    =    Math.abs(diag[pj]    *    sum2);    	non-compiled	[CE]  ')'  expected	56	None	replace
646	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[pj]  *  sum2)+  1;  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[pj]  *  sum2)+  1;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[pj]  *  sum2)+  1;	  double    dxNorm    =    Math.abs(diag[pj]    *    sum2);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	56	None	replace
647	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[pj]  *  sum2;  [CE]  ')'  expected  [FE]                              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[pj]  *  sum2;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[pj]  *  sum2;	  double    dxNorm    =    Math.abs(diag[pj]    *    sum2);    	non-compiled	[CE]  ')'  expected	56	None	replace
648	[BUG]  [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  double  work2[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  double  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    diagR[pj]    /    dxNorm;    double  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	36	None	add
649	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	12	add
650	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	12	add
651	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	13	add
652	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	13	add
653	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(work3[pj]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(work3[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(work3[pj]);	  int    diagR[pj]    =    Math.abs(work1[pj]);    	non-compiled	[CE]  ']'  expected	58	None	replace
654	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  diag[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  work3[pj]  /  dxNorm;  diag[pj]  *=  work3[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
655	[BUG]  [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  diag[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work3[pj]  /  dxNorm;  diag[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work3[pj]  /  dxNorm;  diag[pj]  *=  work3[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
656	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  work3[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
657	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  work3[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
658	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  work2[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
659	[BUG]  [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  work2[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	67	13	replace
660	[BUG]  [BUGGY]  Double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  Double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	Double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue());	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    2);    	non-compiled	[CE]  ']'  expected	124	None	replace
661	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
662	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
663	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
664	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	146	13	add
665	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work1.[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work1.[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work1.[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  <identifier>  expected	118	None	add
666	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  double  work3[pj]  *=  work2[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  double  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work2[pj]    /    dxNorm;    double  work3[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  ']'  expected	106	None	add
667	[BUG]  [BUGGY]  double[0]  *=  diag[0]  /  dxNorm;  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[0]  *=  diag[0]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[0]  *=  diag[0]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    double[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	65	None	replace
668	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[pj]  *  total);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[pj]  *  total);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[pj]  *  total);	  double    dxNorm    =    Math.abs(diag[pj]    *    sum);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	57	None	replace
669	[BUG]  [BUGGY]  int  work2[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  work2[pj]  *=  diagR[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    int    work1[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	14	None	replace
670	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
671	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
672	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
673	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  diagR[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	10	11	add
674	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2;	  double    diagR[pj]    =    Math.abs(diagR[pj]    *    sum);    	non-compiled	[CE]  ']'  expected	31	None	replace
675	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	11	add
676	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	46	11	add
677	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	6	10	replace
678	[BUG]  [BUGGY]  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]    *=    work3[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	6	10	replace
679	[BUG]  [BUGGY]  work1[pj]  *=  work3  /  dxNorm;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work3  /  dxNorm;	  work1[pj]    *=    work1.length    /    dxNorm;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	132	None	replace
680	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	11	add
681	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	11	add
682	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	13	add
683	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work2[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work2[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	12	13	add
684	[BUG]  [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  dxNorm);  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  dxNorm);	  double[]    diagnosticR[pj]    =    Math.abs(diagR[pj].doubleValue());    	non-compiled	[CE]  ']'  expected	144	None	replace
685	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][pj]  *  work2[i];  }  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][pj]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][pj]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	94	None	replace
686	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  solved[i][pj]  *  work2[i];  }  [CE]  cannot  find  symbol  sum  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  solved[i][pj]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  solved[i][pj]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	94	None	replace
687	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work2[j]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
688	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[j]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work1[j]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work2[j]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work1[j]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work2[j]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	52	13	add
689	[BUG]  [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work1.[pj]  *=  work1[pj]  /  diagR[pj];  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work1[pj]  /  diagR[pj];  work1.[pj]  *=  work1[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work1[pj]    /    diagR[pj];    work1.[pj]  *=  work1[pj]  /  diagR[pj];	  	non-compiled	[CE]  <identifier>  expected	68	None	add
690	[BUG]  [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[0]  +  parl);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  diagR[pj]  =  Math.abs(diagR[0]  +  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  diagR[pj]  =  Math.abs(diagR[0]  +  parl);	  int    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	60	None	replace
691	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work3[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	106	2	add
692	[BUG]  [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	106	2	add
693	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work4[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [CE]  cannot  find  symbol  work4  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work2[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work4[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work2[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work4[pj]  /  dxNorm;  work2[pj]  *=  work3[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  work4	5	None	add
694	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
695	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
696	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
697	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work3[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	108	10	add
698	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work3[pj]);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work3[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(work3[pj]);	  double    diagR[pj]    =    Math.sqrt(dxNorm);    	non-compiled	[CE]  ']'  expected	143	None	replace
699	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(work3);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(work3);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(work3);	  double    diagR[pj]    =    Math.sqrt(dxNorm);    	non-compiled	[CE]  ']'  expected	143	None	replace
700	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.log(log0);  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.log(log0);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.log(log0);	  double    diagR[pj]    =    Math.log(rank);    	non-compiled	[CE]  ']'  expected	72	None	replace
701	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.ceil(rank);  [CE]  ']'  expected  [FE]                        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.ceil(rank);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.ceil(rank);	  double    diagR[pj]    =    Math.log(rank);    	non-compiled	[CE]  ']'  expected	72	None	replace
702	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.rint(log(rank));  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.rint(log(rank));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.rint(log(rank));	  double    diagR[pj]    =    Math.log(rank);    	non-compiled	[CE]  ']'  expected	72	None	replace
703	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0],  parl);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.sqrt(diagR[0],  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.sqrt(diagR[0],  parl);	  double    diagR[pj]    =    Math.sqrt(diagR);    	non-compiled	[CE]  ']'  expected	104	None	replace
704	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum2;  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum2;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[pj].doubleValue()  *  sum2;	  double    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	45	None	replace
705	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1.[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;  work1.[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work2[pj]    *=    work2[pj]    /    dxNorm;    work1.[pj]  *=  work2[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  <identifier>  expected	86	None	add
706	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  solvedCols[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  solvedCols[j];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  solvedCols[j];  }	  for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    solvedCols[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	75	None	replace
707	[BUG]  [BUGGY]  double[]  workR[pj]  =  Math.abs(diagR[pj].doubleValue());  [CE]  ']'  expected  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  workR[pj]  =  Math.abs(diagR[pj].doubleValue());  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  workR[pj]  =  Math.abs(diagR[pj].doubleValue());	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    +    2);    	non-compiled	[CE]  ']'  expected	128	None	replace
708	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[pj].doubleValue()  +  parl);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[pj].doubleValue()  +  parl);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[pj].doubleValue()  +  parl);	  double    dxNorm    =    Math.abs(diag[pj].doubleValue());    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	21	None	replace
709	[BUG]  [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  sum2);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  sum2);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagnosticR[pj]  =  Math.abs(diagR[pj].doubleValue()  /  sum2);	  double[]    diagR[pj]    =    Math.abs(diagR[pj].doubleValue()    *    sum2);    	non-compiled	[CE]  ']'  expected	42	None	replace
710	[BUG]  [BUGGY]  work1[pj]  *=  work3[pj]  /  jacobian;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  jacobian;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work3[pj]  /  jacobian;	  work1[pj]    *=    work3[pj]    /    diagR;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	137	None	replace
711	[BUG]  [BUGGY]  double[pj]  *=  work[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[pj]  *=  work[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[pj]  *=  work[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    double[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	65	None	replace
712	[BUG]  [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  travail2[pj]  *=  diagR[pj]  /  dxNorm;  [CE]  cannot  find  symbol  travail2  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagR[pj]  /  dxNorm;  travail2[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]    *=    diagR[pj]    /    dxNorm;    travail2[pj]  *=  diagR[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  travail2	36	None	add
713	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work1[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work1[j];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work1[j];  }	  for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work1[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	77	None	replace
714	[BUG]  [BUGGY]  double  diagR[pj]  *=  work3[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  *=  work3[pj]  /  dxNorm;	  work1[pj]    *=    diagR[pj]    /    dxNorm;    double    diagR[pj]    *=    diagR[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	99	None	replace
715	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[pj]  *  work2[pj]);  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[pj]  *  work2[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[pj]  *  work2[pj]);	  double    dxNorm    =    Math.abs(work1[pj]);    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	54	None	replace
716	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	13	add
717	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	13	add
718	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	11	add
719	[BUG]  [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    diagR[pj]    /    dxNorm;    work3[pj]  *=  diagR[pj]  /  dxNorm;  work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        diagR[pj]        /        dxNorm;        work3[pj]    *=    diagR[pj]    /    dxNorm;    work1[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  diagR[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	134	11	add
720	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  solved[i][pj]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  solved[i][pj]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  solved[i][pj]  *  work1[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	95	None	replace
721	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][pj]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][pj]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][pj]  *  work1[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	95	None	replace
722	[BUG]  [BUGGY]  work3[pj]  *=  work4[pj]  /  dxNorm;  [CE]  cannot  find  symbol  work4  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work3[pj]  *=  work4[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work3[pj]  *=  work4[pj]  /  dxNorm;	  work1[pj]    *=    work1[pj]    /    dxNorm;    work3[pj]    *=    work1[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  work4	109	None	replace
723	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  work1[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  work1[j];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  work1[j];  }	  for(int    i    =    0;    j    <    solvedCols;    ++i)    {    int    pj    =    permutation[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	76	None	replace
724	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  work3[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  work3[j];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  solvedCols;  ++i)  {  int  pj  =  work3[j];  }	  for(int    i    =    0;    j    <    solvedCols;    ++i)    {    int    pj    =    permutation[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	76	None	replace
725	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diagnostic[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [CE]  cannot  find  symbol  diagnostic  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diagnostic[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diagnostic[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  diagnostic	61	None	add
726	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work1[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work1[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	10	add
727	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work1[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work1[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work1[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	10	add
728	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work3[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work3[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	2	add
729	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work3[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  diag[pj]  /  dxNorm;  work3[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        work2[pj]    *=    diag[pj]    /    dxNorm;    work3[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  diag[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	61	2	add
730	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR.length;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]  *=  work2[pj]  /  diagR.length;	  work1[pj]    *=    work2[pj]    /    diagR;    	compilable	  [FE]  AssertionFailedError  	111	13	replace
731	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR.length;  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR.length;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  diagR.length;	  work1[pj]    *=    work2[pj]    /    diagR;    	compilable	  [FE]  AssertionFailedError  	111	13	replace
732	[BUG]  [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work4[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [CE]  cannot  find  symbol  work4  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work3[pj]    /    dxNorm;    work3[pj]  *=  work3[pj]  /  dxNorm;  work1[pj]  *=  work4[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work3[pj]        /        dxNorm;        work3[pj]    *=    work3[pj]    /    dxNorm;    work1[pj]  *=  work4[pj]  /  dxNorm;  work3[pj]  *=  work3[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  work4	3	None	add
733	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  permutation[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  permutation[j];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  permutation[j];  }	  for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    permutation[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	74	None	replace
734	[BUG]  [BUGGY]  double  work2[pj]  *=  diagnostic[pj]  /  dxNorm;  [CE]  ']'  expected  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  work2[pj]  *=  diagnostic[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  work2[pj]  *=  diagnostic[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    double    work2[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  ']'  expected	121	None	replace
735	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1[j]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	84	13	add
736	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work1[pj]  *=  work2[pj]  /  dxNorm;  work1[j]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work1[pj]    *=    work2[pj]    /    dxNorm;    work1[j]  *=  work2[pj]  /  dxNorm;  work1[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	84	13	add
737	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	10	add
738	[BUG]  [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work1[pj]  /  dxNorm;  work2[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work1[pj]        /        dxNorm;        work2[pj]    *=    work1[pj]    /    dxNorm;    work2[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	48	10	add
739	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]  *  dxNorm);  [CE]  ']'  expected  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[0]  *  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[0]  *  dxNorm);	  double[]    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	122	None	replace
740	[BUG]  [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[0]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  work2[pj]  =  Math.abs(diagR[0]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  work2[pj]  =  Math.abs(diagR[0]);	  double[]    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	122	None	replace
741	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work1.[pj]  *=  work2[pj]  /  diagR[pj];  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work1.[pj]  *=  work2[pj]  /  diagR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work2[pj]    /    diagR[pj];    work1.[pj]  *=  work2[pj]  /  diagR[pj];	  	non-compiled	[CE]  <identifier>  expected	24	None	add
742	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work1[pj]  *=  work2[pj]  /  diagR[pj].;  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[pj];  work1[pj]  *=  work2[pj]  /  diagR[pj].;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work2[pj]    /    diagR[pj];    work1[pj]  *=  work2[pj]  /  diagR[pj].;	  	non-compiled	[CE]  <identifier>  expected	24	None	add
743	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  work[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [CE]  cannot  find  symbol  work  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  work2[pj]  *=  work[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]  *=  work[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  work	66	None	add
744	[BUG]  [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  Work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [CE]  cannot  find  symbol  Work2  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]    *=    diag[pj]    /    dxNorm;    diag[pj]  *=  diag[pj]  /  dxNorm;  Work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]        *=        diag[pj]        /        dxNorm;        diag[pj]    *=    diag[pj]    /    dxNorm;    Work2[pj]  *=  work2[pj]  /  dxNorm;  diag[pj]  *=  diag[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  Work2	66	None	add
745	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diagr));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diagr));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(work1[j]  *  Math.abs(diagr));	  double    dxNorm    =    Math.abs(work1[j]    *    Math.abs(pj));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	80	None	replace
746	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  *  dxNorm);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  *  dxNorm);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[0]  *  dxNorm);	  double    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	114	None	replace
747	[BUG]  [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  +  1);  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[pj]  =  Math.abs(diagR[0]  +  1);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[pj]  =  Math.abs(diagR[0]  +  1);	  double    diagR[pj]    =    Math.abs(diagR[0]);    	non-compiled	[CE]  ']'  expected	114	None	replace
748	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }	          for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	115	None	replace
749	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }  [CE]  cannot  find  symbol  sum  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  qrRankingThreshold;  ++i)  {  sum  +=  solved[i][j]  *  work1[i];  }	          for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work1[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	115	None	replace
750	[BUG]  [BUGGY]  int  work2[pj]  =  Math.abs(work1[pj]);  [CE]  ']'  expected  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  int  work2[pj]  =  Math.abs(work1[pj]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	int  work2[pj]  =  Math.abs(work1[pj]);	  int    diagR[pj]    =    Math.abs(work1[pj]);    	non-compiled	[CE]  ']'  expected	58	None	replace
751	[BUG]  [BUGGY]  work2[pj]  *=  diagnostic[pj]  /  dxNorm;  [CE]  cannot  find  symbol  diagnostic  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diagnostic[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  diagnostic[pj]  /  dxNorm;	  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]    *=    diag[pj]    /    dxNorm;    	non-compiled	[CE]  cannot  find  symbol  diagnostic	62	None	replace
752	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diag[pj]  /  2;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work2[pj]  *=  diag[pj]  /  2;	  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	62	7	replace
753	[BUG]  [BUGGY]  work2[pj]  *=  diag[pj]  /  2;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work2[pj]  *=  diag[pj]  /  2;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work2[pj]  *=  diag[pj]  /  2;	  work2[pj]    *=    diag[pj]    /    dxNorm;    work2[pj]    *=    diag[pj]    /    dxNorm;    	compilable	  [FE]  AssertionFailedError  	62	7	replace
754	[BUG]  [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2;  [CE]  ']'  expected  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2;  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double[]  diagR[pj]  =  Math.abs(diagR[pj]  *  sum2;	  double[]    diagR[pj]    =    Math.abs(diagR[pj]    *    sum2);    	non-compiled	[CE]  ']'  expected	19	None	replace
755	[BUG]  [BUGGY]  double  diagR[j]  =  Math.sqrt(diagR[j]);  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  diagR[j]  =  Math.sqrt(diagR[j]);  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  diagR[j]  =  Math.sqrt(diagR[j]);	  double    diagR[pj]    =    Math.sqrt(diagR[j]);    	non-compiled	[CE]  ']'  expected	71	None	replace
756	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[0]  *  Math.abs(parl));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[0]  *  Math.abs(parl));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[0]  *  Math.abs(parl));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(parl));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	91	None	replace
757	[BUG]  [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(sum2  -  parl));  [CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(sum2  -  parl));  [BUGGY]      work1[pj]  *=  diag[pj]  /  dxNorm;  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	double  dxNorm  =  Math.abs(diag[j]  *  Math.abs(sum2  -  parl));	  double    dxNorm    =    Math.abs(diag[j]    *    Math.abs(parl));    	non-compiled	[CE]  variable  dxNorm  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	91	None	replace
758	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[0];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]  *=  work2[pj]  /  diagR[0];	  work1[pj]    *=    work2[pj]    /    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	25	13	replace
759	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[0];  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  diagR[0];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  diagR[0];	  work1[pj]    *=    work2[pj]    /    diagR[pj];    	compilable	  [FE]  AssertionFailedError  	25	13	replace
760	[BUG]  [BUGGY]  work1[pj]  *=  work2[pj]  /  logR[pj];  [CE]  cannot  find  symbol  logR  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work2[pj]  /  logR[pj];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]  *=  work2[pj]  /  logR[pj];	  work1[pj]    *=    work2[pj]    /    sum2;    	non-compiled	[CE]  cannot  find  symbol  logR	28	None	replace
761	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  permutation[j];  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  permutation[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    permutation[j];    	non-compiled	[CE]  illegal  start  of  expression	81	None	replace
762	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	add	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	118	13	add
763	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work1[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	compilable	  [FE]  AssertionFailedError  	118	13	add
764	[BUG]  [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work4[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [CE]  cannot  find  symbol  work4  [FE]      AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]    *=    work2[pj]    /    dxNorm;    work3[pj]  *=  work2[pj]  /  dxNorm;  work4[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]        *=        work2[pj]        /        dxNorm;        work3[pj]    *=    work2[pj]    /    dxNorm;    work4[pj]  *=  work2[pj]  /  dxNorm;  work3[pj]  *=  work2[pj]  /  dxNorm;	  	non-compiled	[CE]  cannot  find  symbol  work4	118	None	add
765	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  solved[i][pj]  *  work3[i];  }  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  solved[i][pj]  *  work3[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  j;  ++i)  {  sum  +=  solved[i][pj]  *  work3[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work3[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	96	None	replace
766	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][pj]  *  work3[i];  }  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][pj]  *  work3[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][pj]  *  work3[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][pj]    *    work3[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	96	None	replace
767	[BUG]  [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work1[pj]  *=  work3[pj]  /  diagR[pj].;  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  work1[pj]  *=  work3[pj]  /  diagR[pj];  work1[pj]  *=  work3[pj]  /  diagR[pj].;  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	work1[pj]    *=    work3[pj]    /    diagR[pj];    work1[pj]  *=  work3[pj]  /  diagR[pj].;	  	non-compiled	[CE]  <identifier>  expected	34	None	add
768	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work1[j];  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work1[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work1[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work1[j];    	non-compiled	[CE]  illegal  start  of  expression	142	None	replace
769	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  doneCols;  ++j)  {  int  pj  =  work1[j];  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  doneCols;  ++j)  {  int  pj  =  work1[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  doneCols;  ++j)  {  int  pj  =  work1[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work1[j];    	non-compiled	[CE]  illegal  start  of  expression	142	None	replace
770	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][j]  *  work2[i];  }  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][j]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  parl;  ++i)  {  sum  +=  solved[i][j]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  sum	97	None	replace
771	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  pp;  ++i)  {  sum  +=  solved[i][j]  *  work2[i];  }  [CE]  cannot  find  symbol  pp  [FE]                AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  i  =  0;  i  <  pp;  ++i)  {  sum  +=  solved[i][j]  *  work2[i];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  i  =  0;  i  <  pp;  ++i)  {  sum  +=  solved[i][j]  *  work2[i];  }	  for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    solved[i][j]    *    work2[i];    }    	non-compiled	[CE]  cannot  find  symbol  pp	97	None	replace
772	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work3[j];  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work3[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work3[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work3[j];    	non-compiled	[CE]  illegal  start  of  expression	140	None	replace
773	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  doneCols;  ++j)  {  int  pj  =  work3[j];  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  doneCols;  ++j)  {  int  pj  =  work3[j];  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  doneCols;  ++j)  {  int  pj  =  work3[j];	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work3[j];    	non-compiled	[CE]  illegal  start  of  expression	140	None	replace
774	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work2[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work2[j];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work2[j];  }	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work2[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	141	None	replace
775	[BUG]  [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work3[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]      }    double  sum2;  double  parl  =  0;  if  (rank  ==  solvedCols)  {  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];      [BUGGY]  for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work3[j];  }  [BUGGY]      }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3922322702763681	532	532	2	replace	for(int  j  =  0;  j  <  parl;  ++j)  {  int  pj  =  work3[j];  }	          for(int    j    =    0;    j    <    solvedCols;    ++j)    {    int    pj    =    work3[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	139	None	replace
