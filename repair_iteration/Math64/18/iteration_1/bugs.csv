bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]    int  pj  =  permutation[j];  [CE]  variable  pj  is  already  defined  in  method  doOptimize()  [FE]    AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    int  pj  =  permutation[j];  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    int  pj  =  permutation[j];		non-compiled	[CE]  variable  pj  is  already  defined  in  method  doOptimize()	36	None	add
2	[BUG]  [BUGGY]    tmpVec  =  Math.sqrt(previousCost);  [CE]  incompatible  types  [FE]      AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    tmpVec  =  Math.sqrt(previousCost);  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    tmpVec  =  Math.sqrt(previousCost);		non-compiled	[CE]  incompatible  types	36	None	add
3	[BUG]  [BUGGY]    tmpVec  =  permutation[j];  [CE]  incompatible  types  [FE]        AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    tmpVec  =  permutation[j];  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    tmpVec  =  permutation[j];		non-compiled	[CE]  incompatible  types	36	None	add
4	[BUG]  [BUGGY]    ((  VectorialPointValuePair)previousCost).setIndex(pj);  [CE]  inconvertible  types  [FE]          AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    ((  VectorialPointValuePair)previousCost).setIndex(pj);  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    ((  VectorialPointValuePair)previousCost).setIndex(pj);		non-compiled	[CE]  inconvertible  types	36	None	add
5	[BUG]  [BUGGY]    ((  VectorialPointValuePair)previousCost).remove(pj);  [CE]  inconvertible  types  [FE]            AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    ((  VectorialPointValuePair)previousCost).remove(pj);  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    ((  VectorialPointValuePair)previousCost).remove(pj);		non-compiled	[CE]  inconvertible  types	36	None	add
6	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[pj]  =  cost;  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	add	point[pj]  =  cost;	point[pj]  =  oldX[pj];  	compilable	  [FE]  AssertionFailedError  	35	12	replace
7	[BUG]  [BUGGY]  point[pj]  =  cost;  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[pj]  =  cost;  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	point[pj]  =  cost;	point[pj]  =  oldX[pj];  	compilable	  [FE]  AssertionFailedError  	35	12	replace
8	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[pj]  =  xNorm;  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	add	point[pj]  =  xNorm;	point[pj]  =  oldX[pj];  	compilable	  [FE]  AssertionFailedError  	35	12	replace
9	[BUG]  [BUGGY]  point[pj]  =  xNorm;  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[pj]  =  xNorm;  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	point[pj]  =  xNorm;	point[pj]  =  oldX[pj];  	compilable	  [FE]  AssertionFailedError  	35	12	replace
10	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[j]  =  oldX[pj];  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	add	point[j]  =  oldX[pj];	point[pj]  =  oldX[pj];  	compilable	  [FE]  AssertionFailedError  	35	6	replace
11	[BUG]  [BUGGY]  point[j]  =  oldX[pj];  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[j]  =  oldX[pj];  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	point[j]  =  oldX[pj];	point[pj]  =  oldX[pj];  	compilable	  [FE]  AssertionFailedError  	35	6	replace
12	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[pj]  =  permutation[pj];  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	add	point[pj]  =  permutation[pj];	point[pj]  =  oldX[pj];  	compilable	  [FE]  AssertionFailedError  	35	11	replace
13	[BUG]  [BUGGY]  point[pj]  =  permutation[pj];  [FE]  AssertionFailedError  [FE]          AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[pj]  =  permutation[pj];  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	point[pj]  =  permutation[pj];	point[pj]  =  oldX[pj];  	compilable	  [FE]  AssertionFailedError  	35	11	replace
14	[BUG]  [BUGGY]  point[pj]  =  value;  [CE]  cannot  find  symbol  value  [FE]    AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[pj]  =  value;  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	point[pj]  =  value;	point[pj]  =  oldX[pj];  	non-compiled	[CE]  cannot  find  symbol  value	35	None	replace
15	[BUG]  [BUGGY]  point[pj]  =  tmpVec;  [CE]  incompatible  types  [FE]      AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[pj]  =  tmpVec;  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	point[pj]  =  tmpVec;	point[pj]  =  oldX[pj];  	non-compiled	[CE]  incompatible  types	35	None	replace
16	[BUG]  [BUGGY]    ((  VectorialPointValuePair)previous).setIndex(pj);  [CE]  cannot  find  symbol  [FE]    AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    ((  VectorialPointValuePair)previous).setIndex(pj);  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    ((  VectorialPointValuePair)previous).setIndex(pj);		non-compiled	[CE]  cannot  find  symbol	36	None	add
17	[BUG]  [BUGGY]    ((  VectorialPointValuePair)last).remove(pj);  [CE]  cannot  find  symbol  last  [FE]      AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    ((  VectorialPointValuePair)last).remove(pj);  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    ((  VectorialPointValuePair)last).remove(pj);		non-compiled	[CE]  cannot  find  symbol  last	36	None	add
18	[BUG]  [BUGGY]    tmpVec  =  cost;  [CE]  incompatible  types  [FE]        AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    tmpVec  =  cost;  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    tmpVec  =  cost;		non-compiled	[CE]  incompatible  types	36	None	add
19	[BUG]  [BUGGY]    ((  VectorialPointValuePair)previous).remove(pj);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    ((  VectorialPointValuePair)previous).remove(pj);  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    ((  VectorialPointValuePair)previous).remove(pj);		non-compiled	[CE]  cannot  find  symbol	36	None	add
20	[BUG]  [BUGGY]  point[pj]  =  cost[cost];  [CE]  possible  loss  of  precision  [FE]    AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]  point[pj]  =  cost[cost];  [BUGGY]  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	point[pj]  =  cost[cost];	point[pj]  =  oldX[pj];  	non-compiled	[CE]  possible  loss  of  precision	35	None	replace
21	[BUG]  [BUGGY]  [FE]  ArrayIndexOutOfBoundsException  [FE]    AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    for(int  i  =  0;  j  <  solvedCols;  ++i)  {  point[pj]  =  oldX[i];  }  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	add	    for(int  i  =  0;  j  <  solvedCols;  ++i)  {  point[pj]  =  oldX[i];  }		compilable	  [FE]  ArrayIndexOutOfBoundsException  	36	15	add
22	[BUG]  [BUGGY]    for(int  i  =  0;  j  <  solvedCols;  ++i)  {  point[pj]  =  oldX[i];  }  [FE]  ArrayIndexOutOfBoundsException  [FE]    AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    for(int  i  =  0;  j  <  solvedCols;  ++i)  {  point[pj]  =  oldX[i];  }  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    for(int  i  =  0;  j  <  solvedCols;  ++i)  {  point[pj]  =  oldX[i];  }		compilable	  [FE]  ArrayIndexOutOfBoundsException  	36	15	add
23	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  oldX  =  oldX[i];  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  oldX  =  oldX[i];  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  int  oldX  =  oldX[i];		non-compiled	[CE]  illegal  start  of  expression	36	None	add
24	[BUG]  [BUGGY]  timeout  [FE]        AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    for(int  i  =  0;  j  <  solvedCols;  ++i)  {  point[pj]  =  cost;  }  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	add	    for(int  i  =  0;  j  <  solvedCols;  ++i)  {  point[pj]  =  cost;  }		compilable	timeout	36	1	add
25	[BUG]  [BUGGY]    for(int  i  =  0;  j  <  solvedCols;  ++i)  {  point[pj]  =  cost;  }  timeout  [FE]        AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    for(int  i  =  0;  j  <  solvedCols;  ++i)  {  point[pj]  =  cost;  }  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    for(int  i  =  0;  j  <  solvedCols;  ++i)  {  point[pj]  =  cost;  }		compilable	timeout	36	1	add
26	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  point[pj]  =  cost;  }  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	add	    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  point[pj]  =  cost;  }		compilable	  [FE]  AssertionFailedError  	36	2	add
27	[BUG]  [BUGGY]    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  point[pj]  =  cost;  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError  [CONTEXT]  }  xNorm  =  Math.sqrt(xNorm);    }  else  {  cost  =  previousCost;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  [BUGGY]    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  point[pj]  =  cost;  }  [BUGGY]  point[pj]  =  oldX[pj];  }  tmpVec=  residuals;  residuals  =  oldRes;  oldRes=  tmpVec;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  doOptimize  [RETURN_TYPE]  VectorialPointValuePair  [VARIABLES]  VectorialPointValuePair  current  previous  int[]  permutation  boolean  firstIteration  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  threshold  tmp  xK  xNorm  xk  int  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	429	429	2	replace	    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  point[pj]  =  cost;  }		compilable	  [FE]  AssertionFailedError  	36	2	add
