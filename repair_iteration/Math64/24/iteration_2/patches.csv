bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  sum2  =  gNorm;  [CE]  cannot  find  symbol  gNorm  [FE]        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  gNorm;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  gNorm;	  sum2    =    s;    	non-compiled	[CE]  cannot  find  symbol  gNorm	58	None	replace
2	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  solvedCols);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solvedCols  =  Math.min(solvedCols,  solvedCols);	  	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	78	None	add
3	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solveCols  =  Math.min(solvedCols,  sum);  [CE]  cannot  find  symbol  sum  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solveCols  =  Math.min(solvedCols,  sum);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solveCols  =  Math.min(solvedCols,  sum);	  	non-compiled	[CE]  cannot  find  symbol  sum	78	None	add
4	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double[]  solvedCols  =  work1[i][pj]  *  diagR[pj];  [CE]  cannot  find  symbol  i  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double[]  solvedCols  =  work1[i][pj]  *  diagR[pj];  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    double[]  solvedCols  =  work1[i][pj]  *  diagR[pj];	  	non-compiled	[CE]  cannot  find  symbol  i	78	None	add
5	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double[]  solvedCols  =  work1[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  i  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double[]  solvedCols  =  work1[i][pj]  *  qy[i];  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    double[]  solvedCols  =  work1[i][pj]  *  qy[i];	  	non-compiled	[CE]  cannot  find  symbol  i	78	None	add
6	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  sum);  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  sum);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solvedCols  =  Math.min(solvedCols,  sum);	  	non-compiled	[CE]  cannot  find  symbol  sum	78	None	add
7	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    sum2  =  parl;  sum2  =  parl;  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2        =        parl;        sum2    =    parl;    sum2  =  parl;  sum2  =  parl;	  	compilable	  [FE]  AssertionFailedError  	27	2	add
8	[BUG]  [BUGGY]  sum2    =    parl;    sum2  =  parl;  sum2  =  parl;  sum2  =  parl;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    sum2  =  parl;  sum2  =  parl;  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        sum2    =    parl;    sum2  =  parl;  sum2  =  parl;	  	compilable	  [FE]  AssertionFailedError  	27	2	add
9	[BUG]  [BUGGY]  sum2    =    parl;    sum2  =  parl;  Sum2  =  parl;  sum2  =  parl;  [CE]  cannot  find  symbol  Sum2  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    sum2  =  parl;  Sum2  =  parl;  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        sum2    =    parl;    Sum2  =  parl;  sum2  =  parl;	  	non-compiled	[CE]  cannot  find  symbol  Sum2	27	None	add
10	[BUG]  [BUGGY]  sum2    =    parl;    sum2  =  parl;  sum1  =  parl;  sum2  =  parl;  [CE]  cannot  find  symbol  sum1  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    sum2  =  parl;  sum1  =  parl;  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        sum2    =    parl;    sum1  =  parl;  sum2  =  parl;	  	non-compiled	[CE]  cannot  find  symbol  sum1	27	None	add
11	[BUG]  [BUGGY]  sum2    =    parl;    sum2  =  parl;  sum2  =  parl;  Sum2  =  parl;  [CE]  cannot  find  symbol  Sum2  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    sum2  =  parl;  sum2  =  parl;  Sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        sum2    =    parl;    sum2  =  parl;  Sum2  =  parl;	  	non-compiled	[CE]  cannot  find  symbol  Sum2	27	None	add
12	[BUG]  [BUGGY]  sum2    =    parl;    sum2  =  parl;  sum2  =  parl;  sum2  =  parl;  }  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    sum2  =  parl;  sum2  =  parl;  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        sum2    =    parl;    sum2  =  parl;  sum2  =  parl;  }	  	non-compiled	[CE]  <identifier>  expected	27	None	add
13	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  parl  +  2;	  sum2    =    parl    +    1;    	compilable	  [FE]  AssertionFailedError  	9	3	replace
14	[BUG]  [BUGGY]  sum2  =  parl  +  2;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  parl  +  2;	  sum2    =    parl    +    1;    	compilable	  [FE]  AssertionFailedError  	9	3	replace
15	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  /  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  parl  /  1;	  sum2    =    parl    +    1;    	compilable	  [FE]  AssertionFailedError  	9	3	replace
16	[BUG]  [BUGGY]  sum2  =  parl  /  1;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  /  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  parl  /  1;	  sum2    =    parl    +    1;    	compilable	  [FE]  AssertionFailedError  	9	3	replace
17	[BUG]  [BUGGY]  sum2  -=  parl  *  gNorm;  [CE]  cannot  find  symbol  gNorm  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  *  gNorm;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  *  gNorm;	  sum2    -=    parl    *    type;    	non-compiled	[CE]  cannot  find  symbol  gNorm	94	None	replace
18	[BUG]  [BUGGY]  sum2  -=  parl  *  delta;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  *  delta;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  *  delta;	  sum2    -=    parl    *    type;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	94	None	replace
19	[BUG]  [BUGGY]  sum2  -=  parl  *  fp;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  *  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  *  fp;	  sum2    -=    parl    *    type;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	94	None	replace
20	[BUG]  [BUGGY]  double  resolvedCols  =  Math.min(solvedCols,  parl);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  resolvedCols  =  Math.min(solvedCols,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  resolvedCols  =  Math.min(solvedCols,  parl);	  double    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	37	None	replace
21	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(parl,  resolvedCols);  [CE]  cannot  find  symbol  resolvedCols  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(parl,  resolvedCols);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(parl,  resolvedCols);	  double    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	37	None	replace
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  sum2  =  Math.max(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.max(solvedCols,    parl);    sum2  =  Math.max(solvedCols,  parl);	  	compilable	  [FE]  AssertionFailedError  	53	2	add
23	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  sum2  =  Math.max(solvedCols,  parl);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  sum2  =  Math.max(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(solvedCols,    parl);    sum2  =  Math.max(solvedCols,  parl);	  	compilable	  [FE]  AssertionFailedError  	53	2	add
24	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  int  solvedCols  =  Math.max(solvedCols,  parl);  [CE]  possible  loss  of  precision  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  int  solvedCols  =  Math.max(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(solvedCols,    parl);    int  solvedCols  =  Math.max(solvedCols,  parl);	  	non-compiled	[CE]  possible  loss  of  precision	53	None	add
25	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  Sum  s  =  Math.max(solvedCols,  parl);  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  Sum  s  =  Math.max(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(solvedCols,    parl);    Sum  s  =  Math.max(solvedCols,  parl);	  	non-compiled	[CE]  cannot  find  symbol	53	None	add
26	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  Math.max(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.max(solvedCols,    parl);    Math.max(solvedCols,  parl);	  	compilable	  [FE]  AssertionFailedError  	53	2	add
27	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  Math.max(solvedCols,  parl);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  Math.max(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(solvedCols,    parl);    Math.max(solvedCols,  parl);	  	compilable	  [FE]  AssertionFailedError  	53	2	add
28	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  Sum.max(solvedCols,  parl);  [CE]  cannot  find  symbol  Sum  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  Sum.max(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(solvedCols,    parl);    Sum.max(solvedCols,  parl);	  	non-compiled	[CE]  cannot  find  symbol  Sum	53	None	add
29	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl  -  1);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  parl  -  1);	  int    solvedCols    =    Math.min(solvedCols,    parl    -    1);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	43	None	replace
30	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  parl  -  1);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solvedCols  =  Math.min(solvedCols,  parl  -  1);	  int    solvedCols    =    Math.min(solvedCols,    parl    -    1);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	43	None	replace
31	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  parl  -  1);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solvedCols  =  Math.min(solvedCols,  parl  -  1);	  int    solvedCols    =    Math.min(solvedCols,    parl    -    1);    	non-compiled	[CE]  possible  loss  of  precision	43	None	replace
32	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(parl,  resolvedCols);  [CE]  cannot  find  symbol  resolvedCols  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(parl,  resolvedCols);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(parl,  resolvedCols);	  int    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	24	None	replace
33	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(diagR,  parl);  [CE]  no  suitable  method  found  for  min(double[],double)  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(diagR,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(diagR,  parl);	  int    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double)	24	None	replace
34	[BUG]  [BUGGY]  Double  solveCols  =  Math.min(solveCols,  parl);  [CE]  variable  solveCols  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solveCols  =  Math.min(solveCols,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solveCols  =  Math.min(solveCols,  parl);	  int    solveCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  variable  solveCols  might  not  have  been  initialized	12	None	replace
35	[BUG]  [BUGGY]  int  solveCols  =  Math.min(solveCols,  parl  -  1);  [CE]  possible  loss  of  precision  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solveCols  =  Math.min(solveCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solveCols  =  Math.min(solveCols,  parl  -  1);	  int    solveCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  possible  loss  of  precision	12	None	replace
36	[BUG]  [BUGGY]  long  solveCols  =  Math.min(solveCols,  parl);  [CE]  possible  loss  of  precision  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solveCols  =  Math.min(solveCols,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solveCols  =  Math.min(solveCols,  parl);	  int    solveCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  possible  loss  of  precision	12	None	replace
37	[BUG]  [BUGGY]  sum2  =  Math.min(sum1,  parl);  [CE]  cannot  find  symbol  sum1  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(sum1,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(sum1,  parl);	  sum2    =    Math.min(sum,    parl);    	non-compiled	[CE]  cannot  find  symbol  sum1	40	None	replace
38	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work2[parl];  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work2[parl];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work2[parl];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[parl];    	non-compiled	[CE]  possible  loss  of  precision	33	None	replace
39	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work3[parl];  [CE]  possible  loss  of  precision  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work3[parl];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work3[parl];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[parl];    	non-compiled	[CE]  possible  loss  of  precision	33	None	replace
40	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work2)/  work1[parl];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work2)/  work1[parl];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  work2)/  work1[parl];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[parl];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	33	None	replace
41	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  sum2  =  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    fp;    sum2  =  fp;	  	compilable	  [FE]  AssertionFailedError  	59	2	add
42	[BUG]  [BUGGY]  sum2  =  fp;  sum2  =  fp;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  sum2  =  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    sum2  =  fp;	  	compilable	  [FE]  AssertionFailedError  	59	2	add
43	[BUG]  [BUGGY]  sum2  =  fp;  int  fp  =  Math.min(sum2,  parl);  sum2  =  fp;  [CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  int  fp  =  Math.min(sum2,  parl);  sum2  =  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    int  fp  =  Math.min(sum2,  parl);  sum2  =  fp;	  	non-compiled	[CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	59	None	add
44	[BUG]  [BUGGY]  sum2  =  fp;  Sum  fp  =  fp;  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  Sum  fp  =  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    Sum  fp  =  fp;	  	non-compiled	[CE]  cannot  find  symbol	59	None	add
45	[BUG]  [BUGGY]  sum2  =  fp;  int  fp  =  Math.floor(parl);  sum2  =  fp;  [CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  int  fp  =  Math.floor(parl);  sum2  =  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    int  fp  =  Math.floor(parl);  sum2  =  fp;	  	non-compiled	[CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	59	None	add
46	[BUG]  [BUGGY]  sum2  =  fp;  int  fp  =  Math.min(sum,  parl);  sum2  =  fp;  [CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  int  fp  =  Math.min(sum,  parl);  sum2  =  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    int  fp  =  Math.min(sum,  parl);  sum2  =  fp;	  	non-compiled	[CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	59	None	add
47	[BUG]  [BUGGY]  Math.sqrt(work1[pj]);  sum2  =  parl;  [CE]  cannot  find  symbol  pj  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Math.sqrt(work1[pj]);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Math.sqrt(work1[pj]);  sum2  =  parl;	  sum2    =    parl;    Math.sqrt(parl);    sum2    =    parl;    	non-compiled	[CE]  cannot  find  symbol  pj	99	None	replace
48	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	Math.sqrt(parl);  sum2  =  parl;	  sum2    =    parl;    Math.sqrt(parl);    sum2    =    parl;    	compilable	  [FE]  AssertionFailedError  	99	3	replace
49	[BUG]  [BUGGY]  Math.sqrt(parl);  sum2  =  parl;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Math.sqrt(parl);  sum2  =  parl;	  sum2    =    parl;    Math.sqrt(parl);    sum2    =    parl;    	compilable	  [FE]  AssertionFailedError  	99	3	replace
50	[BUG]  [BUGGY]  sum2  =  Math.sqrt(sum2);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.sqrt(sum2);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.sqrt(sum2);	  sum2    =    parl;    Math.sqrt(parl);    sum2    =    parl;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	99	None	replace
51	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(diagR[parl]);  [CE]  possible  loss  of  precision  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(diagR[parl]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(diagR[parl]);	  double    solvedCols    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  possible  loss  of  precision	51	None	replace
52	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(diag[parl]);  [CE]  possible  loss  of  precision  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(diag[parl]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(diag[parl]);	  double    solvedCols    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  possible  loss  of  precision	51	None	replace
53	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(diagR[0]);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(diagR[0]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(diagR[0]);	  double    solvedCols    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	51	None	replace
54	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(diag[0]);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(diag[0]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(diag[0]);	  double    solvedCols    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	51	None	replace
55	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp  /(delta  *  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  fp  /(delta  *  parl);	  sum2    =    fp    /(delta    *    sum2);    	compilable	  [FE]  AssertionFailedError  	7	5	replace
56	[BUG]  [BUGGY]  sum2  =  fp  /(delta  *  parl);  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp  /(delta  *  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  fp  /(delta  *  parl);	  sum2    =    fp    /(delta    *    sum2);    	compilable	  [FE]  AssertionFailedError  	7	5	replace
57	[BUG]  [BUGGY]  sum2  =  fp  /(parl  *  sum2);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp  /(parl  *  sum2);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  fp  /(parl  *  sum2);	  sum2    =    fp    /(delta    *    sum2);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	7	None	replace
58	[BUG]  [BUGGY]  sum2  =  sum  /(delta  *  sum2);  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  sum  /(delta  *  sum2);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  sum  /(delta  *  sum2);	  sum2    =    fp    /(delta    *    sum2);    	non-compiled	[CE]  cannot  find  symbol  sum	7	None	replace
59	[BUG]  [BUGGY]  sum2  =  parl  /(delta  *  sum2);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  /(delta  *  sum2);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  parl  /(delta  *  sum2);	  sum2    =    fp    /(delta    *    sum2);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	7	None	replace
60	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  parl  -  2;	  sum2    =    parl    -    1;    	compilable	  [FE]  AssertionFailedError  	90	15	replace
61	[BUG]  [BUGGY]  sum2  =  parl  -  2;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  parl  -  2;	  sum2    =    parl    -    1;    	compilable	  [FE]  AssertionFailedError  	90	15	replace
62	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  *  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  parl  *  1;	  sum2    =    parl    -    1;    	compilable	  [FE]  AssertionFailedError  	90	3	replace
63	[BUG]  [BUGGY]  sum2  =  parl  *  1;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  *  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  parl  *  1;	  sum2    =    parl    -    1;    	compilable	  [FE]  AssertionFailedError  	90	3	replace
64	[BUG]  [BUGGY]  sum2  -=  parl;  double  parl  =  parl;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl;  double  parl  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl;  double  parl  =  parl;	  sum2    =    parl;    double    parl    =    parl;    	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	95	None	replace
65	[BUG]  [BUGGY]  sum2  =  s;  double  parl  =  s;  [CE]  cannot  find  symbol  s  [FE]          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  s;  double  parl  =  s;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  s;  double  parl  =  s;	  sum2    =    parl;    double    parl    =    parl;    	non-compiled	[CE]  cannot  find  symbol  s	95	None	replace
66	[BUG]  [BUGGY]  sum2  =  fp;  double  parl  =  fp;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  double  parl  =  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  fp;  double  parl  =  fp;	  sum2    =    parl;    double    parl    =    parl;    	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	95	None	replace
67	[BUG]  [BUGGY]  double  solveCols  =  Math.min(solvedCols,  parl);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solveCols  =  Math.min(solvedCols,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solveCols  =  Math.min(solvedCols,  parl);	  double    solvedCols    =    Math.min(solvedCols,    gNorm);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	70	None	replace
68	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  tmpVec);  [CE]  cannot  find  symbol  tmpVec  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  tmpVec);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  tmpVec);	  double    solvedCols    =    Math.min(solvedCols,    gNorm);    	non-compiled	[CE]  cannot  find  symbol  tmpVec	70	None	replace
69	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(diagR[0],  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  Math.min(diagR[0],  parl);	  sum2    =    Math.min(diagR[pj],    parl);    	compilable	  [FE]  AssertionFailedError  	74	11	replace
70	[BUG]  [BUGGY]  sum2  =  Math.min(diagR[0],  parl);  [FE]  AssertionFailedError  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(diagR[0],  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(diagR[0],  parl);	  sum2    =    Math.min(diagR[pj],    parl);    	compilable	  [FE]  AssertionFailedError  	74	11	replace
71	[BUG]  [BUGGY]  sum2  =  Math.min(diagR[parl],  parl);  [CE]  possible  loss  of  precision  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(diagR[parl],  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(diagR[parl],  parl);	  sum2    =    Math.min(diagR[pj],    parl);    	non-compiled	[CE]  possible  loss  of  precision	74	None	replace
72	[BUG]  [BUGGY]  sum2  =  Math.min(diagR[pj],  gNorm);  [CE]  cannot  find  symbol  pj  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(diagR[pj],  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(diagR[pj],  gNorm);	  sum2    =    Math.min(diagR[pj],    parl);    	non-compiled	[CE]  cannot  find  symbol  pj	74	None	replace
73	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR[0]);  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR[0]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  diagR[0]);	  int    solvedCols    =    Math.min(diagR,    solvedCols);    	non-compiled	[CE]  possible  loss  of  precision	92	None	replace
74	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR);  [CE]  no  suitable  method  found  for  min(int,double[])  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  diagR);	  int    solvedCols    =    Math.min(diagR,    solvedCols);    	non-compiled	[CE]  no  suitable  method  found  for  min(int,double[])	92	None	replace
75	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR[pj]);  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR[pj]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  diagR[pj]);	  int    solvedCols    =    Math.min(diagR,    solvedCols);    	non-compiled	[CE]  cannot  find  symbol  pj	92	None	replace
76	[BUG]  [BUGGY]  solvedCols  =  Math.min(solvedCols,  pj);  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  solvedCols  =  Math.min(solvedCols,  pj);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	solvedCols  =  Math.min(solvedCols,  pj);	  solvedCols    =    Math.min(solvedCols,    gNorm);    	non-compiled	[CE]  cannot  find  symbol  pj	3	None	replace
77	[BUG]  [BUGGY]  solvedCols  =  Math.min(solvedCols,  sum);  [CE]  cannot  find  symbol  sum  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  solvedCols  =  Math.min(solvedCols,  sum);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	solvedCols  =  Math.min(solvedCols,  sum);	  solvedCols    =    Math.min(solvedCols,    gNorm);    	non-compiled	[CE]  cannot  find  symbol  sum	3	None	replace
78	[BUG]  [BUGGY]  if(delta  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(delta  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(delta  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
79	[BUG]  [BUGGY]  if(delta  ==  2)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(delta  ==  2)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(delta  ==  2)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
80	[BUG]  [BUGGY]  if(delta  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(delta  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(delta  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
81	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(delta  ==  0.0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(delta  ==  0.0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
82	[BUG]  [BUGGY]  sum2  -=  parl  *  2;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  *  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  *  2;	  sum2    -=    parl    +    2;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	88	None	replace
83	[BUG]  [BUGGY]  sum  -=  parl  +  1;  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  parl  +  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  parl  +  1;	  sum2    -=    parl    +    2;    	non-compiled	[CE]  cannot  find  symbol  sum	88	None	replace
84	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  sum2  =  parl  +  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    parl    +    1;    sum2  =  parl  +  1;	  	compilable	  [FE]  AssertionFailedError  	8	2	add
85	[BUG]  [BUGGY]  sum2  =  parl  +  1;  sum2  =  parl  +  1;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  sum2  =  parl  +  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    sum2  =  parl  +  1;	  	compilable	  [FE]  AssertionFailedError  	8	2	add
86	[BUG]  [BUGGY]  sum2  =  parl  +  1;  if(parl  <  =  0)  {  sum2  =  parl  +  1;  }  else  {  sum  +=  permutation[i][pj]  *  work1[i];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  if(parl  <  =  0)  {  sum2  =  parl  +  1;  }  else  {  sum  +=  permutation[i][pj]  *  work1[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    if(parl  <  =  0)  {  sum2  =  parl  +  1;  }  else  {  sum  +=  permutation[i][pj]  *  work1[i];  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
87	[BUG]  [BUGGY]  sum2  =  parl  +  1;  if(parl  <  =  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  else  {  sum2  =  parl  +  1;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  if(parl  <  =  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  else  {  sum2  =  parl  +  1;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    if(parl  <  =  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  else  {  sum2  =  parl  +  1;  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
88	[BUG]  [BUGGY]  sum2  =  parl  +  1;  if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  else  {  sum  +=  parl  +  1;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  else  {  sum  +=  parl  +  1;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  else  {  sum  +=  parl  +  1;  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
89	[BUG]  [BUGGY]  sum2  =  parl  +  1;  if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  work1[i];  }  else  {  sum  +=  parl  +  1;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  work1[i];  }  else  {  sum  +=  parl  +  1;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  work1[i];  }  else  {  sum  +=  parl  +  1;  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
90	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl.length);  [CE]  double  cannot  be  dereferenced  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  parl.length);	  double    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  double  cannot  be  dereferenced	84	None	replace
91	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(parl,  diagR.length);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(parl,  diagR.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(parl,  diagR.length);	  double    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	84	None	replace
92	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagR,  diag.length);  [CE]  no  suitable  method  found  for  min(double[],int)  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(diagR,  diag.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(diagR,  diag.length);	  double    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],int)	84	None	replace
93	[BUG]  [BUGGY]  sum2  -=  1;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  1;	  sum2    -=    2;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	19	None	replace
94	[BUG]  [BUGGY]  sum  -=  2;  [CE]  cannot  find  symbol  sum  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  2;	  sum2    -=    2;    	non-compiled	[CE]  cannot  find  symbol  sum	19	None	replace
95	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(permutation[0]  -  parl)/  permutation[0];  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(permutation[0]  -  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(permutation[0]  -  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(parl    -    permutation[0])/    permutation[0];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	6	None	replace
96	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(permutation  -  parl[0])/  parl;  [CE]  array  required,  but  double  found  [FE]                          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(permutation  -  parl[0])/  parl;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(permutation  -  parl[0])/  parl;	  double    solvedCols    =    Math.abs(parl    -    permutation[0])/    permutation[0];    	non-compiled	[CE]  array  required,  but  double  found	6	None	replace
97	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  permutation[0])/  work1[0];  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  permutation[0])/  work1[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  permutation[0])/  work1[0];	  double    solvedCols    =    Math.abs(parl    -    permutation[0])/    permutation[0];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	6	None	replace
98	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(permutation  -  parl[0])/  permutation[0];  [CE]  array  required,  but  double  found  [FE]                              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(permutation  -  parl[0])/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(permutation  -  parl[0])/  permutation[0];	  double    solvedCols    =    Math.abs(parl    -    permutation[0])/    permutation[0];    	non-compiled	[CE]  array  required,  but  double  found	6	None	replace
99	[BUG]  [BUGGY]  sum  -=  parl  *  delta;  [CE]  cannot  find  symbol  sum  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  parl  *  delta;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  parl  *  delta;	  sum2    -=    delta    *    parl;    	non-compiled	[CE]  cannot  find  symbol  sum	48	None	replace
100	[BUG]  [BUGGY]  sum1  -=  parl  *  delta;  [CE]  cannot  find  symbol  sum1  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum1  -=  parl  *  delta;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum1  -=  parl  *  delta;	  sum2    -=    delta    *    parl;    	non-compiled	[CE]  cannot  find  symbol  sum1	48	None	replace
101	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  gNorm);  [CE]  cannot  find  symbol  gNorm  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.max(parl,  gNorm);	  sum2    =    Math.max(parl,    sum);    	non-compiled	[CE]  cannot  find  symbol  gNorm	14	None	replace
102	[BUG]  [BUGGY]  sum  -=  Math.sqrt(parl);  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  Math.sqrt(parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  Math.sqrt(parl);	  sum2    -=    Math.sqrt(parl);    	non-compiled	[CE]  cannot  find  symbol  sum	75	None	replace
103	[BUG]  [BUGGY]  sum2  -=  Math.sqrt(gNorm);  [CE]  cannot  find  symbol  gNorm  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  Math.sqrt(gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  Math.sqrt(gNorm);	  sum2    -=    Math.sqrt(parl);    	non-compiled	[CE]  cannot  find  symbol  gNorm	75	None	replace
104	[BUG]  [BUGGY]  sum2  -=  Math.sqrt(delta);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  Math.sqrt(delta);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  Math.sqrt(delta);	  sum2    -=    Math.sqrt(parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	75	None	replace
105	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  parl);  [CE]  possible  loss  of  precision  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solvedCols  =  Math.min(solvedCols,  parl);	  int    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  possible  loss  of  precision	10	None	replace
106	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  parl);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solvedCols  =  Math.min(solvedCols,  parl);	  int    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	10	None	replace
107	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  s);  [CE]  cannot  find  symbol  s  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(sum2,  s);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.max(sum2,  s);	  sum2    =    Math.max(sum2,    gNorm);    	non-compiled	[CE]  cannot  find  symbol  s	55	None	replace
108	[BUG]  [BUGGY]  Sum2  =  Math.max(sum2,  parl);  [CE]  cannot  find  symbol  Sum2  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Sum2  =  Math.max(sum2,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Sum2  =  Math.max(sum2,  parl);	  sum2    =    Math.max(sum2,    gNorm);    	non-compiled	[CE]  cannot  find  symbol  Sum2	55	None	replace
109	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  sum2  =  Math.max(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.max(parl,    parl);    sum2  =  Math.max(parl,  parl);	  	compilable	  [FE]  AssertionFailedError  	82	2	add
110	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  parl);  sum2  =  Math.max(parl,  parl);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  sum2  =  Math.max(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(parl,    parl);    sum2  =  Math.max(parl,  parl);	  	compilable	  [FE]  AssertionFailedError  	82	2	add
111	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  parl);  Sum2  =  Math.max(parl,  parl);  [CE]  cannot  find  symbol  Sum2  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  Sum2  =  Math.max(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(parl,    parl);    Sum2  =  Math.max(parl,  parl);	  	non-compiled	[CE]  cannot  find  symbol  Sum2	82	None	add
112	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  parl);  double  parl  =  Math.max(parl,  parl);  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  double  parl  =  Math.max(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(parl,    parl);    double  parl  =  Math.max(parl,  parl);	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	82	None	add
113	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  parl);  Sum  s  =  Math.max(parl,  parl);  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  Sum  s  =  Math.max(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(parl,    parl);    Sum  s  =  Math.max(parl,  parl);	  	non-compiled	[CE]  cannot  find  symbol	82	None	add
114	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  Math.max(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.max(parl,    parl);    Math.max(parl,  parl);	  	compilable	  [FE]  AssertionFailedError  	82	2	add
115	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  parl);  Math.max(parl,  parl);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  Math.max(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(parl,    parl);    Math.max(parl,  parl);	  	compilable	  [FE]  AssertionFailedError  	82	2	add
116	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  sum2  =  parl  -  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    parl    -    1;    sum2  =  parl  -  1;	  	compilable	  [FE]  AssertionFailedError  	89	2	add
117	[BUG]  [BUGGY]  sum2  =  parl  -  1;  sum2  =  parl  -  1;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  sum2  =  parl  -  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    -    1;    sum2  =  parl  -  1;	  	compilable	  [FE]  AssertionFailedError  	89	2	add
118	[BUG]  [BUGGY]  sum2  =  parl  -  1;  if(parl  <  =  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  else  {  sum2  =  parl  -  1;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  if(parl  <  =  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  else  {  sum2  =  parl  -  1;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    -    1;    if(parl  <  =  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  else  {  sum2  =  parl  -  1;  }	  	non-compiled	[CE]  illegal  start  of  expression	89	None	add
119	[BUG]  [BUGGY]  sum2  =  parl  -  1;  if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  else  {  sum2  =  parl  -  1;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  else  {  sum2  =  parl  -  1;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    -    1;    if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  else  {  sum2  =  parl  -  1;  }	  	non-compiled	[CE]  illegal  start  of  expression	89	None	add
120	[BUG]  [BUGGY]  sum2  =  parl  -  1;  if(parl  <  =  0)  {  sum  +=  work1[pj]  *  qy[i];  }  else  {  sum2  =  parl  -  1;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  if(parl  <  =  0)  {  sum  +=  work1[pj]  *  qy[i];  }  else  {  sum2  =  parl  -  1;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    -    1;    if(parl  <  =  0)  {  sum  +=  work1[pj]  *  qy[i];  }  else  {  sum2  =  parl  -  1;  }	  	non-compiled	[CE]  illegal  start  of  expression	89	None	add
121	[BUG]  [BUGGY]  sum2  =  parl  -  1;  if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  else  {  sum  +=  parl  -  1;  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  else  {  sum  +=  parl  -  1;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    -    1;    if(parl  <  =  0)  {  sum  +=  permutation[i][pj]  *  qy[i];  }  else  {  sum  +=  parl  -  1;  }	  	non-compiled	[CE]  illegal  start  of  expression	89	None	add
122	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	30	None	replace
123	[BUG]  [BUGGY]  if(solveCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solveCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solveCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	30	None	replace
124	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	30	None	replace
125	[BUG]  [BUGGY]  if(solveCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solveCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solveCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	30	None	replace
126	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work1[0];  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work1[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work1[0];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[pj];    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	56	None	replace
127	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work1[pj])/  work1[pj];  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work1[pj])/  work1[pj];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  work1[pj])/  work1[pj];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	56	None	replace
128	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(parl,  solveCols);  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(parl,  solveCols);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(parl,  solveCols);	  int    solvedCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  solveCols	11	None	replace
129	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(permutation  -  parl)/  parl[0];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(permutation  -  parl)/  parl[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(permutation  -  parl)/  parl[0];	  double    solvedCols    =    Math.abs(param    -    parl)/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	5	None	replace
130	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(permutation  -  parl)/  permutation[0];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(permutation  -  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(permutation  -  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(param    -    parl)/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	5	None	replace
131	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  sum2  =  Math.min(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.min(parl,    parl);    sum2  =  Math.min(parl,  parl);	  	compilable	  [FE]  AssertionFailedError  	41	2	add
132	[BUG]  [BUGGY]  sum2  =  Math.min(parl,  parl);  sum2  =  Math.min(parl,  parl);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  sum2  =  Math.min(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(parl,    parl);    sum2  =  Math.min(parl,  parl);	  	compilable	  [FE]  AssertionFailedError  	41	2	add
133	[BUG]  [BUGGY]  sum2  =  Math.min(parl,  parl);  double  parl  =  Math.min(parl,  parl);  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  double  parl  =  Math.min(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(parl,    parl);    double  parl  =  Math.min(parl,  parl);	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	41	None	add
134	[BUG]  [BUGGY]  sum2  =  Math.min(parl,  parl);  Sum2  =  Math.min(parl,  parl);  [CE]  cannot  find  symbol  Sum2  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  Sum2  =  Math.min(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(parl,    parl);    Sum2  =  Math.min(parl,  parl);	  	non-compiled	[CE]  cannot  find  symbol  Sum2	41	None	add
135	[BUG]  [BUGGY]  sum2  =  Math.min(parl,  parl);  if(parl!=  null)  {  sum2  =  Math.min(parl,  parl);  }  [CE]  incomparable  types:  double  and  <null>  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  if(parl!=  null)  {  sum2  =  Math.min(parl,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(parl,    parl);    if(parl!=  null)  {  sum2  =  Math.min(parl,  parl);  }	  	non-compiled	[CE]  incomparable  types:  double  and  <null>	41	None	add
136	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  Math.min(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.min(parl,    parl);    Math.min(parl,  parl);	  	compilable	  [FE]  AssertionFailedError  	41	2	add
137	[BUG]  [BUGGY]  sum2  =  Math.min(parl,  parl);  Math.min(parl,  parl);  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  Math.min(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(parl,    parl);    Math.min(parl,  parl);	  	compilable	  [FE]  AssertionFailedError  	41	2	add
138	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagR[0],  diagR[0]);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(diagR[0],  diagR[0]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(diagR[0],  diagR[0]);	  int    solvedCols    =    Math.min(diagR[0],    diagR[0]);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	25	None	replace
139	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(diagR[0],  diagR[0]);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solvedCols  =  Math.min(diagR[0],  diagR[0]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solvedCols  =  Math.min(diagR[0],  diagR[0]);	  int    solvedCols    =    Math.min(diagR[0],    diagR[0]);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	25	None	replace
140	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagr[0],  diagR[0]);  [CE]  cannot  find  symbol  diagr  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(diagr[0],  diagR[0]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(diagr[0],  diagR[0]);	  int    solvedCols    =    Math.min(diagR[0],    diagR[0]);    	non-compiled	[CE]  cannot  find  symbol  diagr	25	None	replace
141	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(diagR[0],  diagR[0]);  [CE]  possible  loss  of  precision  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solvedCols  =  Math.min(diagR[0],  diagR[0]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solvedCols  =  Math.min(diagR[0],  diagR[0]);	  int    solvedCols    =    Math.min(diagR[0],    diagR[0]);    	non-compiled	[CE]  possible  loss  of  precision	25	None	replace
142	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2        =        parl;        if(sum2    ==    parl)    {    sum2    =    parl;    }    if(sum2  ==  parl)  {  sum2  =  parl;  }	  	compilable	  [FE]  AssertionFailedError  	96	2	add
143	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2    ==    parl)    {    sum2    =    parl;    }    if(sum2  ==  parl)  {  sum2  =  parl;  }	  	compilable	  [FE]  AssertionFailedError  	96	2	add
144	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2    ==    parl)    {    sum2    =    parl;    }    if(sum2  ==  parl)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }	  	non-compiled	[CE]  illegal  start  of  expression	96	None	add
145	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum  =  parl;  }  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2    ==    parl)    {    sum2    =    parl;    }    if(sum2  ==  parl)  {  sum  =  parl;  }	  	non-compiled	[CE]  cannot  find  symbol  sum	96	None	add
146	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum1  =  parl;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum1  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2    ==    parl)    {    sum2    =    parl;    }    if(sum2  ==  parl)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum1  =  parl;  }	  	non-compiled	[CE]  illegal  start  of  expression	96	None	add
147	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  int  solveCols  =  Math.min(solvedCols,  sum);  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  int  solveCols  =  Math.min(solvedCols,  sum);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2    ==    parl)    {    sum2    =    parl;    }    int  solveCols  =  Math.min(solvedCols,  sum);	  	non-compiled	[CE]  cannot  find  symbol  sum	96	None	add
148	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(resolveCols,  parl);  [CE]  cannot  find  symbol  resolveCols  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(resolveCols,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(resolveCols,  parl);	  int    solvedCols    =    Math.min(solveCols,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  resolveCols	71	None	replace
149	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solveCols,  sum);  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solveCols,  sum);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solveCols,  sum);	  int    solvedCols    =    Math.min(solveCols,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  solveCols	71	None	replace
150	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2  /  2.0);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  sum2  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    sum2    /    2.0);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	62	None	replace
151	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  sum2  /  2.0);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  sum2  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solvedCols  =  Math.min(solvedCols,  sum2  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    sum2    /    2.0);    	non-compiled	[CE]  possible  loss  of  precision	62	None	replace
152	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(sum2,  solvedCols  /  2.0);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(sum2,  solvedCols  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(sum2,  solvedCols  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    sum2    /    2.0);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	62	None	replace
153	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  fp  -  1);  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  fp  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  fp  -  1);	  int    solvedCols    =    Math.min(solvedCols,    pj    -    1);    	non-compiled	[CE]  possible  loss  of  precision	91	None	replace
154	[BUG]  [BUGGY]  double  solveCols  =  Math.min(solveCols,  parl  -  1);  [CE]  variable  solveCols  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solveCols  =  Math.min(solveCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solveCols  =  Math.min(solveCols,  parl  -  1);	  double    solveCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  variable  solveCols  might  not  have  been  initialized	36	None	replace
155	[BUG]  [BUGGY]  double  solveCols  =  Math.min(solveCols,  parl  +  1);  [CE]  variable  solveCols  might  not  have  been  initialized  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solveCols  =  Math.min(solveCols,  parl  +  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solveCols  =  Math.min(solveCols,  parl  +  1);	  double    solveCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  variable  solveCols  might  not  have  been  initialized	36	None	replace
156	[BUG]  [BUGGY]  double  solveCols  =  Math.min(diagR[pj],  parl);  [CE]  cannot  find  symbol  pj  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solveCols  =  Math.min(diagR[pj],  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solveCols  =  Math.min(diagR[pj],  parl);	  double    solveCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  pj	36	None	replace
157	[BUG]  [BUGGY]  sum1  -=  parl.length;  [CE]  cannot  find  symbol  sum1  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum1  -=  parl.length;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum1  -=  parl.length;	  sum2    -=    parl.length;    	non-compiled	[CE]  cannot  find  symbol  sum1	22	None	replace
158	[BUG]  [BUGGY]  Sum2  -=  parl.length;  [CE]  cannot  find  symbol  Sum2  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Sum2  -=  parl.length;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Sum2  -=  parl.length;	  sum2    -=    parl.length;    	non-compiled	[CE]  cannot  find  symbol  Sum2	22	None	replace
159	[BUG]  [BUGGY]  sum2,  -=  parl.length;  [CE]  not  a  statement  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2,  -=  parl.length;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2,  -=  parl.length;	  sum2    -=    parl.length;    	non-compiled	[CE]  not  a  statement	22	None	replace
160	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(work1  -  parl)/  permutation[0];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(work1  -  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(work1  -  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(parl    -    work1)/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	87	None	replace
161	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(work2  -  parl)/  permutation[0];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(work2  -  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(work2  -  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(parl    -    work1)/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	87	None	replace
162	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(work1.length  -  parl)/  permutation[0];  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(work1.length  -  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(work1.length  -  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(parl    -    work1)/    permutation[0];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	87	None	replace
163	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(permutation[0  -  parl)/  parl[0];  [CE]  ']'  expected  [FE]                          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(permutation[0  -  parl)/  parl[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(permutation[0  -  parl)/  parl[0];	  double    solvedCols    =    Math.abs(parl    -    work1)/    permutation[0];    	non-compiled	[CE]  ']'  expected	87	None	replace
164	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  incompatible  types	77	None	replace
165	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	compilable	  [FE]  AssertionFailedError  	77	3	replace
166	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	compilable	  [FE]  AssertionFailedError  	77	3	replace
167	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  parl)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	77	None	replace
168	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  }  [CE]  variable  sum2  might  not  have  been  initialized  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	77	None	replace
169	[BUG]  [BUGGY]  Sum2  =  parl;  [CE]  cannot  find  symbol  Sum2  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Sum2  =  parl;	  sum2    =    parl;    Sum2    =    parl;    	non-compiled	[CE]  cannot  find  symbol  Sum2	81	None	replace
170	[BUG]  [BUGGY]  Sum2  =  sum;  [CE]  cannot  find  symbol  Sum2  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Sum2  =  sum;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Sum2  =  sum;	  sum2    =    parl;    Sum2    =    parl;    	non-compiled	[CE]  cannot  find  symbol  Sum2	81	None	replace
171	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(parl,  solvedCols);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(parl,  solvedCols);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(parl,  solvedCols);	  int    solvedCols    =    Math.min(parl,    solvedCols);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	23	None	replace
172	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(parl,  solvedCols);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solvedCols  =  Math.min(parl,  solvedCols);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solvedCols  =  Math.min(parl,  solvedCols);	  int    solvedCols    =    Math.min(parl,    solvedCols);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	23	None	replace
173	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(parl,  gNorm);  [CE]  cannot  find  symbol  gNorm  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(parl,  gNorm);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(parl,  gNorm);	  double    solvedCols    =    Math.min(parl,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  gNorm	38	None	replace
174	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  fp  /  2.0);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  fp  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  fp  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    fp    /    2.0);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	63	None	replace
175	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  fp  /  2.0);  [CE]  possible  loss  of  precision  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  fp  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solvedCols  =  Math.min(solvedCols,  fp  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    fp    /    2.0);    	non-compiled	[CE]  possible  loss  of  precision	63	None	replace
176	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  fp  /  2.0);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  fp  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solvedCols  =  Math.min(solvedCols,  fp  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    fp    /    2.0);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	63	None	replace
177	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  parl)/  permutation[1];  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  parl)/  permutation[1];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  parl)/  permutation[1];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    permutation[1];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	57	None	replace
178	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(param  -  parl)/  permutation[1];  [CE]  cannot  find  symbol  param  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(param  -  parl)/  permutation[1];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(param  -  parl)/  permutation[1];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    permutation[1];    	non-compiled	[CE]  cannot  find  symbol  param	57	None	replace
179	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  sum2  =  Math.min(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.min(solvedCols,    parl);    sum2  =  Math.min(solvedCols,  parl);	  	compilable	  [FE]  AssertionFailedError  	72	2	add
180	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  sum2  =  Math.min(solvedCols,  parl);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  sum2  =  Math.min(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(solvedCols,    parl);    sum2  =  Math.min(solvedCols,  parl);	  	compilable	  [FE]  AssertionFailedError  	72	2	add
181	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum2  =  Math.min(solvedCols,  parl);  }  [CE]  incomparable  types:  int  and  <null>  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum2  =  Math.min(solvedCols,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(solvedCols,    parl);    if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum2  =  Math.min(solvedCols,  parl);  }	  	non-compiled	[CE]  incomparable  types:  int  and  <null>	72	None	add
182	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum  +=  solvedCols[i][pj]  *  work1[i];  }  [CE]  incomparable  types:  int  and  <null>  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum  +=  solvedCols[i][pj]  *  work1[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(solvedCols,    parl);    if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum  +=  solvedCols[i][pj]  *  work1[i];  }	  	non-compiled	[CE]  incomparable  types:  int  and  <null>	72	None	add
183	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  incomparable  types:  int  and  <null>  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(solvedCols,    parl);    if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  incomparable  types:  int  and  <null>	72	None	add
184	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  Sum  s  =  Math.min(solvedCols,  parl);  sum2  =  Math.min(solvedCols,  parl);  [CE]  cannot  find  symbol  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  Sum  s  =  Math.min(solvedCols,  parl);  sum2  =  Math.min(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(solvedCols,    parl);    Sum  s  =  Math.min(solvedCols,  parl);  sum2  =  Math.min(solvedCols,  parl);	  	non-compiled	[CE]  cannot  find  symbol	72	None	add
185	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  parl.length);  [CE]  double  cannot  be  dereferenced  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  parl.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  parl.length);	  int    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  double  cannot  be  dereferenced	64	None	replace
186	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(parl,  diagR.length);  [CE]  possible  loss  of  precision  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(parl,  diagR.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(parl,  diagR.length);	  int    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  possible  loss  of  precision	64	None	replace
187	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(diagR,  diag.length);  [CE]  no  suitable  method  found  for  min(double[],int)  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(diagR,  diag.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(diagR,  diag.length);	  int    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],int)	64	None	replace
188	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(diagR,  parl.length);  [CE]  double  cannot  be  dereferenced  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(diagR,  parl.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(diagR,  parl.length);	  int    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  double  cannot  be  dereferenced	64	None	replace
189	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum!=  0)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum!=  0)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  if(sum!=  0)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	79	None	replace
190	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum!=  0)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum!=  0)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  if(sum!=  0)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	79	None	replace
191	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  if(sum!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	79	None	replace
192	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work2[pj];  [CE]  cannot  find  symbol  pj  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work2[pj];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work2[pj];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    permutation[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	35	None	replace
193	[BUG]  [BUGGY]  sum2  -=  solvedCols;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  solvedCols;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  solvedCols;	  sum2    -=    solveCols;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	69	None	replace
194	[BUG]  [BUGGY]  sum  -=  parl  *  parl;  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  parl  *  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  parl  *  parl;	  sum2    -=    parl    *    parl;    	non-compiled	[CE]  cannot  find  symbol  sum	47	None	replace
195	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl  /  2.0);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  parl  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  parl  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    parl    /    2.0);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	16	None	replace
196	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  parl  /  2.0);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  parl  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solvedCols  =  Math.min(solvedCols,  parl  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    parl    /    2.0);    	non-compiled	[CE]  possible  loss  of  precision	16	None	replace
197	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  parl  /  2.0);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  parl  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solvedCols  =  Math.min(solvedCols,  parl  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    parl    /    2.0);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	16	None	replace
198	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  solvedCols);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solvedCols  =  Math.min(solvedCols,  solvedCols);	  	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	76	None	add
199	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solveCols  =  Math.min(solvedCols,  sum);  [CE]  cannot  find  symbol  sum  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solveCols  =  Math.min(solvedCols,  sum);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solveCols  =  Math.min(solvedCols,  sum);	  	non-compiled	[CE]  cannot  find  symbol  sum	76	None	add
200	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double[]  solvedCols  =  work1[i][pj]  *  diagR[pj];  [CE]  cannot  find  symbol  i  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double[]  solvedCols  =  work1[i][pj]  *  diagR[pj];  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    double[]  solvedCols  =  work1[i][pj]  *  diagR[pj];	  	non-compiled	[CE]  cannot  find  symbol  i	76	None	add
201	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double[]  solvedCols  =  work1[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  i  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double[]  solvedCols  =  work1[i][pj]  *  qy[i];  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    double[]  solvedCols  =  work1[i][pj]  *  qy[i];	  	non-compiled	[CE]  cannot  find  symbol  i	76	None	add
202	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  sum);  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  sum);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solvedCols  =  Math.min(solvedCols,  sum);	  	non-compiled	[CE]  cannot  find  symbol  sum	76	None	add
203	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(diagR,  parl  -  parl)/  permutation[0];  [CE]  no  suitable  method  found  for  abs(double[],double)  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(diagR,  parl  -  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(diagR,  parl  -  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(diagR    -    parl)/    permutation[0];    	non-compiled	[CE]  no  suitable  method  found  for  abs(double[],double)	68	None	replace
204	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  diagR)/  permutation[0];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  diagR)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  diagR)/  permutation[0];	  double    solvedCols    =    Math.abs(diagR    -    parl)/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	68	None	replace
205	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(diagR  *  parl)/  permutation[0];  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]                        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(diagR  *  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(diagR  *  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(diagR    -    parl)/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	68	None	replace
206	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(diagR  /  parl)/  permutation[0];  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]                          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(diagR  /  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(diagR  /  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(diagR    -    parl)/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	68	None	replace
207	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  Math.max(solvedCols,  parl  +  1);	  sum2    =    Math.max(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	54	3	replace
208	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  parl  +  1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.max(solvedCols,  parl  +  1);	  sum2    =    Math.max(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	54	3	replace
209	[BUG]  [BUGGY]  sum2  =  Math.min(sum2,  solvedCols);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(sum2,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(sum2,  solvedCols);	  sum2    =    Math.max(solvedCols,    parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	54	None	replace
210	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl  -  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  Math.max(solvedCols,  parl  -  1);	  sum2    =    Math.max(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	54	3	replace
211	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  parl  -  1);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl  -  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.max(solvedCols,  parl  -  1);	  sum2    =    Math.max(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	54	3	replace
212	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  Math.max(solvedCols,  solvedCols);	  sum2    =    Math.max(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	54	3	replace
213	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  solvedCols);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.max(solvedCols,  solvedCols);	  sum2    =    Math.max(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	54	3	replace
214	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  Math.min(solvedCols,  solvedCols);	  sum2    =    Math.min(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	73	3	replace
215	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  solvedCols);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(solvedCols,  solvedCols);	  sum2    =    Math.min(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	73	3	replace
216	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  Math.min(solvedCols,  parl  +  1);	  sum2    =    Math.min(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	73	3	replace
217	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl  +  1);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl  +  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(solvedCols,  parl  +  1);	  sum2    =    Math.min(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	73	3	replace
218	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl  -  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  Math.min(solvedCols,  parl  -  1);	  sum2    =    Math.min(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	73	15	replace
219	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl  -  1);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl  -  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(solvedCols,  parl  -  1);	  sum2    =    Math.min(solvedCols,    parl);    	compilable	  [FE]  AssertionFailedError  	73	15	replace
220	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(resolveCols,  parl);  [CE]  cannot  find  symbol  resolveCols  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(resolveCols,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(resolveCols,  parl);	  double    solvedCols    =    Math.min(solveCols,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  resolveCols	67	None	replace
221	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  +  1);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  +  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  +  1);	  double    solvedCols    =    Math.abs(parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	49	None	replace
222	[BUG]  [BUGGY]  double  solveCols  =  Math.min(solvedCols,  parl  /  2.0);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solveCols  =  Math.min(solvedCols,  parl  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solveCols  =  Math.min(solvedCols,  parl  /  2.0);	  int    solveCols    =    Math.min(solvedCols,    parl    /    2.0);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	17	None	replace
223	[BUG]  [BUGGY]  Double  solveCols  =  Math.min(solvedCols,  parl  /  2.0);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solveCols  =  Math.min(solvedCols,  parl  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solveCols  =  Math.min(solvedCols,  parl  /  2.0);	  int    solveCols    =    Math.min(solvedCols,    parl    /    2.0);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	17	None	replace
224	[BUG]  [BUGGY]  long  solveCols  =  Math.min(solvedCols,  parl  /  2.0);  [CE]  possible  loss  of  precision  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solveCols  =  Math.min(solvedCols,  parl  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solveCols  =  Math.min(solvedCols,  parl  /  2.0);	  int    solveCols    =    Math.min(solvedCols,    parl    /    2.0);    	non-compiled	[CE]  possible  loss  of  precision	17	None	replace
225	[BUG]  [BUGGY]  double  solveCols  =  Math.min(solvedCols,  parl  -  1);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solveCols  =  Math.min(solvedCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solveCols  =  Math.min(solvedCols,  parl  -  1);	  int    solveCols    =    Math.min(solvedCols,    parl    -    1);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	44	None	replace
226	[BUG]  [BUGGY]  Double  solveCols  =  Math.min(solvedCols,  parl  -  1);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solveCols  =  Math.min(solvedCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solveCols  =  Math.min(solvedCols,  parl  -  1);	  int    solveCols    =    Math.min(solvedCols,    parl    -    1);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	44	None	replace
227	[BUG]  [BUGGY]  long  solveCols  =  Math.min(solvedCols,  parl  -  1);  [CE]  possible  loss  of  precision  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solveCols  =  Math.min(solvedCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solveCols  =  Math.min(solvedCols,  parl  -  1);	  int    solveCols    =    Math.min(solvedCols,    parl    -    1);    	non-compiled	[CE]  possible  loss  of  precision	44	None	replace
228	[BUG]  [BUGGY]  sum  -=  1;  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  1;	  sum    -=    0;    	non-compiled	[CE]  cannot  find  symbol  sum	18	None	replace
229	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  parl;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  parl;	  sum2    =    parl;    int    solvedCols    =    Math.min(sum2,    solvedCols);    sum2    =    parl;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	80	None	replace
230	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(sum2,  solveCols);  sum2  =  parl;  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(sum2,  solveCols);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(sum2,  solveCols);  sum2  =  parl;	  sum2    =    parl;    int    solvedCols    =    Math.min(sum2,    solvedCols);    sum2    =    parl;    	non-compiled	[CE]  cannot  find  symbol  solveCols	80	None	replace
231	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  parl;  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  parl;	  sum2    =    parl;    int    solvedCols    =    Math.min(sum2,    solvedCols);    sum2    =    parl;    	non-compiled	[CE]  possible  loss  of  precision	80	None	replace
232	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(sum2,  solveCols);  sum2  =  parl;  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(sum2,  solveCols);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(sum2,  solveCols);  sum2  =  parl;	  sum2    =    parl;    int    solvedCols    =    Math.min(sum2,    solvedCols);    sum2    =    parl;    	non-compiled	[CE]  cannot  find  symbol  solveCols	80	None	replace
233	[BUG]  [BUGGY]  sum  -=  parl.length;  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  parl.length;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  parl.length;	  sum    -=    parl;    	non-compiled	[CE]  cannot  find  symbol  sum	20	None	replace
234	[BUG]  [BUGGY]  sum  -=  parl2;  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  parl2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  parl2;	  sum    -=    parl;    	non-compiled	[CE]  cannot  find  symbol  sum	20	None	replace
235	[BUG]  [BUGGY]  sum  -=  solvedCols  *  parl;  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  solvedCols  *  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  solvedCols  *  parl;	  sum2    -=    solvedCols    *    parl;    	non-compiled	[CE]  cannot  find  symbol  sum	52	None	replace
236	[BUG]  [BUGGY]  sum2  -=  solvedCols  *  parl.length;  [CE]  double  cannot  be  dereferenced  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  solvedCols  *  parl.length;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  solvedCols  *  parl.length;	  sum2    -=    solvedCols    *    parl;    	non-compiled	[CE]  double  cannot  be  dereferenced	52	None	replace
237	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagR[pj],  parl);  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(diagR[pj],  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(diagR[pj],  parl);	  double    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  pj	2	None	replace
238	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagR[parl],  parl);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(diagR[parl],  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(diagR[parl],  parl);	  double    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  possible  loss  of  precision	2	None	replace
239	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagR,  parl);  [CE]  no  suitable  method  found  for  min(double[],double)  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(diagR,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(diagR,  parl);	  double    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double)	2	None	replace
240	[BUG]  [BUGGY]  sum2  -=  fp;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  fp;	  sum2    =    fp;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	60	None	replace
241	[BUG]  [BUGGY]  sum2  /=  fp;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  /=  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  /=  fp;	  sum2    =    fp;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	60	None	replace
242	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	32	None	replace
243	[BUG]  [BUGGY]  if(solveCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solveCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solveCols)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	32	None	replace
244	[BUG]  [BUGGY]  if(solveCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solveCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solveCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	32	None	replace
245	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	32	None	replace
246	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  parl)/  work1[0];  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  parl)/  work1[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  parl)/  work1[0];	  double    solvedCols    =    Math.abs(parl    -    parl)/    permutation[0];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	4	None	replace
247	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(permutation[0]  -  parl)/  parl;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(permutation[0]  -  parl)/  parl;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(permutation[0]  -  parl)/  parl;	  double    solvedCols    =    Math.abs(parl    -    parl)/    permutation[0];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	4	None	replace
248	[BUG]  [BUGGY]  solvedCols  =  Math.min(solvedCols,  parl  +  1);  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  solvedCols  =  Math.min(solvedCols,  parl  +  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	solvedCols  =  Math.min(solvedCols,  parl  +  1);	  solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  possible  loss  of  precision	1	None	replace
249	[BUG]  [BUGGY]  solvedCols  =  Math.min(solvedCols,  parl,  sum);  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  solvedCols  =  Math.min(solvedCols,  parl,  sum);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	solvedCols  =  Math.min(solvedCols,  parl,  sum);	  solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  sum	1	None	replace
250	[BUG]  [BUGGY]  solvedCols  =  Math.min(solvedCols,  parl  -  1);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  solvedCols  =  Math.min(solvedCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	solvedCols  =  Math.min(solvedCols,  parl  -  1);	  solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  possible  loss  of  precision	1	None	replace
251	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  pj);  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  pj);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  pj);	  int    solvedCols    =    Math.min(solvedCols,    gNorm);    	non-compiled	[CE]  cannot  find  symbol  pj	26	None	replace
252	[BUG]  [BUGGY]  sum2  -=  parl  *  1;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  *  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  *  1;	  sum2    -=    parl    +    1;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	21	None	replace
253	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);	  int    solvedCols    =    Math.min(solvedCols,    sum2    -    1);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	61	None	replace
254	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(sum2,  sum2  -  1);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(sum2,  sum2  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(sum2,  sum2  -  1);	  int    solvedCols    =    Math.min(solvedCols,    sum2    -    1);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	61	None	replace
255	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solvedCols  =  Math.min(solvedCols,  sum2  -  1);	  int    solvedCols    =    Math.min(solvedCols,    sum2    -    1);    	non-compiled	[CE]  possible  loss  of  precision	61	None	replace
256	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(work1  -  parl)/  work1.length;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(work1  -  parl)/  work1.length;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(work1  -  parl)/  work1.length;	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1.length;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	34	None	replace
257	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  work1)/  work1.length;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  work1)/  work1.length;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  work1)/  work1.length;	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1.length;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	34	None	replace
258	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  work1.length)/  work1.length;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  work1.length)/  work1.length;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  work1.length)/  work1.length;	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1.length;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	34	None	replace
259	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(work1.length  -  parl)/  work1.length;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(work1.length  -  parl)/  work1.length;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(work1.length  -  parl)/  work1.length;	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1.length;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	34	None	replace
260	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;	  	compilable	  [FE]  AssertionFailedError  	98	2	add
261	[BUG]  [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;	  	compilable	  [FE]  AssertionFailedError  	98	2	add
262	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;	  	compilable	  [FE]  AssertionFailedError  	98	2	add
263	[BUG]  [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;	  	compilable	  [FE]  AssertionFailedError  	98	2	add
264	[BUG]  [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  sum1  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [CE]  cannot  find  symbol  sum1  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  sum1  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    sum1  =  parl;  Math.sqrt(parl);  sum2  =  parl;	  	non-compiled	[CE]  cannot  find  symbol  sum1	98	None	add
265	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  sum2  =  parl;  Math.sqrt(parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    sum2  =  parl;  Math.sqrt(parl);	  	compilable	  [FE]  AssertionFailedError  	98	2	add
266	[BUG]  [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  sum2  =  parl;  Math.sqrt(parl);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  sum2  =  parl;  Math.sqrt(parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    sum2  =  parl;  Math.sqrt(parl);	  	compilable	  [FE]  AssertionFailedError  	98	2	add
267	[BUG]  [BUGGY]  if(delta  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(delta  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(delta  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	31	None	replace
268	[BUG]  [BUGGY]  if(delta  ==  2)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(delta  ==  2)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(delta  ==  2)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	31	None	replace
269	[BUG]  [BUGGY]  if(delta!=  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(delta!=  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(delta!=  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	31	None	replace
270	[BUG]  [BUGGY]  if(delta  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(delta  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(delta  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	31	None	replace
271	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  sum2);	  int    solvedCols    =    Math.min(solvedCols,    sum2);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	65	None	replace
272	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  long  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	long  solvedCols  =  Math.min(solvedCols,  sum2);	  int    solvedCols    =    Math.min(solvedCols,    sum2);    	non-compiled	[CE]  possible  loss  of  precision	65	None	replace
273	[BUG]  [BUGGY]  float  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  possible  loss  of  precision  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  float  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	float  solvedCols  =  Math.min(solvedCols,  sum2);	  int    solvedCols    =    Math.min(solvedCols,    sum2);    	non-compiled	[CE]  possible  loss  of  precision	65	None	replace
274	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solvedCols  =  Math.min(solvedCols,  sum2);	  int    solvedCols    =    Math.min(solvedCols,    sum2);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	65	None	replace
275	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  Sum2  =  Math.max(solvedCols,  parl);  [CE]  cannot  find  symbol  Sum2  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  Sum2  =  Math.max(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(solvedCols,    parl);    Sum2  =  Math.max(solvedCols,  parl);	  	non-compiled	[CE]  cannot  find  symbol  Sum2	53	None	add
276	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  double  solvedCols  =  Math.max(solvedCols,  parl);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  double  solvedCols  =  Math.max(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(solvedCols,    parl);    double  solvedCols  =  Math.max(solvedCols,  parl);	  	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	53	None	add
277	[BUG]  [BUGGY]  sum2  -=  parl  *  solvedCols;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  *  solvedCols;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  *  solvedCols;	  sum2    -=    solvedCols    *    parl;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	52	None	replace
278	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  if(sum1  ==  parl)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  if(sum1  ==  parl)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2    ==    parl)    {    sum2    =    parl;    }    if(sum2  ==  parl)  {  sum2  =  parl;  if(sum1  ==  parl)  {  sum2  =  parl;  }	  	non-compiled	[CE]  illegal  start  of  expression	96	None	add
279	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum3  =  parl;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  if(sum2  ==  parl)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum3  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2    ==    parl)    {    sum2    =    parl;    }    if(sum2  ==  parl)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum3  =  parl;  }	  	non-compiled	[CE]  illegal  start  of  expression	96	None	add
280	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(permutation.length  -  parl)/  permutation[0];  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(permutation.length  -  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(permutation.length  -  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(param    -    parl)/    permutation[0];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	5	None	replace
281	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  fp);  [CE]  possible  loss  of  precision  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  fp);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  fp);	  int    solvedCols    =    Math.min(solvedCols,    gNorm);    	non-compiled	[CE]  possible  loss  of  precision	26	None	replace
282	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  1);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  1);	  double    solvedCols    =    Math.abs(parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	49	None	replace
283	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  sum1);  [CE]  cannot  find  symbol  sum1  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  sum1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  sum1);	  int    solvedCols    =    Math.min(solvedCols,    sum2);    	non-compiled	[CE]  cannot  find  symbol  sum1	65	None	replace
284	[BUG]  [BUGGY]  sum2  -=  parl  *  qy;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  *  qy;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  *  qy;	  sum2    -=    parl    *    parl;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	47	None	replace
285	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(work2  -  parl)/  work1.length;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(work2  -  parl)/  work1.length;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(work2  -  parl)/  work1.length;	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1.length;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	34	None	replace
286	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(work3  -  parl)/  work1.length;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(work3  -  parl)/  work1.length;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(work3  -  parl)/  work1.length;	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1.length;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	34	None	replace
287	[BUG]  [BUGGY]  sum2  -=  Math.pow(10,  parl);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  Math.pow(10,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  Math.pow(10,  parl);	  sum2    -=    delta    *    parl;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	48	None	replace
288	[BUG]  [BUGGY]  sum2  -=  Math.abs(delta  *  parl);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  Math.abs(delta  *  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  Math.abs(delta  *  parl);	  sum2    -=    delta    *    parl;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	48	None	replace
289	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(delta);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(delta);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(delta);	  double    solvedCols    =    Math.abs(param);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	50	None	replace
290	[BUG]  [BUGGY]  sum2  =  Math.min(sum2,  gNorm);  [CE]  cannot  find  symbol  gNorm  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(sum2,  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(sum2,  gNorm);	  sum2    =    Math.min(s,    parl);    	non-compiled	[CE]  cannot  find  symbol  gNorm	39	None	replace
291	[BUG]  [BUGGY]  sum2  -=  parl  +  3;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  +  3;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  +  3;	  sum2    -=    parl    +    2;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	88	None	replace
292	[BUG]  [BUGGY]  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	solvedCols  =  Math.min(solvedCols,  sum2);	  solvedCols    =    Math.min(solvedCols,    gNorm);    	non-compiled	[CE]  possible  loss  of  precision	3	None	replace
293	[BUG]  [BUGGY]  solvedCols  =  Math.min(solvedCols,  diagR.length);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  solvedCols  =  Math.min(solvedCols,  diagR.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	solvedCols  =  Math.min(solvedCols,  diagR.length);	  solvedCols    =    Math.min(solvedCols,    gNorm);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	3	None	replace
294	[BUG]  [BUGGY]  sum  -=  solveCols;  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  solveCols;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  solveCols;	  sum    -=    parl;    	non-compiled	[CE]  cannot  find  symbol  sum	20	None	replace
295	[BUG]  [BUGGY]  sum  -=  solvedCols;  [CE]  cannot  find  symbol  sum  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  solvedCols;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  solvedCols;	  sum    -=    parl;    	non-compiled	[CE]  cannot  find  symbol  sum	20	None	replace
296	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(diagR[i]);  [CE]  cannot  find  symbol  i  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(diagR[i]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(diagR[i]);	  double    solvedCols    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  cannot  find  symbol  i	51	None	replace
297	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solvedCols  =  Math.min(solvedCols,  sum2  -  1);	  int    solvedCols    =    Math.min(solvedCols,    sum2    -    1);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	61	None	replace
298	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solveCols,  diagR.length);  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solveCols,  diagR.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solveCols,  diagR.length);	  int    solvedCols    =    Math.min(solveCols,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  solveCols	71	None	replace
299	[BUG]  [BUGGY]  if(solves  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solves  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solves  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	30	None	replace
300	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work1[pj])/  work1[parl];  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work1[pj])/  work1[parl];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  work1[pj])/  work1[parl];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[parl];    	non-compiled	[CE]  cannot  find  symbol  pj	33	None	replace
301	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work1)/  work3[parl];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work1)/  work3[parl];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  work1)/  work3[parl];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[parl];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	33	None	replace
302	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR.length  -  1);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR.length  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  diagR.length  -  1);	  int    solvedCols    =    Math.min(solvedCols,    pj    -    1);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	91	None	replace
303	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work3  -  1);  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  work3  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  work3  -  1);	  int    solvedCols    =    Math.min(solvedCols,    pj    -    1);    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	91	None	replace
304	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  diagR[pj]);  [CE]  cannot  find  symbol  pj  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  diagR[pj]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  diagR[pj]);	  double    solvedCols    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  cannot  find  symbol  pj	85	None	replace
305	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  diagR[0]);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  diagR[0]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  diagR[0]);	  double    solvedCols    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	85	None	replace
306	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(parl,  sum2);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(parl,  sum2);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(parl,  sum2);	  double    solvedCols    =    Math.min(parl,    solveCols);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	38	None	replace
307	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(diagR.length,  diagR.length);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(diagR.length,  diagR.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(diagR.length,  diagR.length);	  int    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	64	None	replace
308	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	77	None	replace
309	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  1)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  1)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  1)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	77	None	replace
310	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  0;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  0;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  0;  }	  sum2    =    parl;    if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	77	None	replace
311	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  1)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  1)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  1)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	77	None	replace
312	[BUG]  [BUGGY]  sum2  =  Math.max(sum2,  solvedCols);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(sum2,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.max(sum2,  solvedCols);	  sum2    =    Math.max(solvedCols,    parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	54	None	replace
313	[BUG]  [BUGGY]  sum2  =  parl  -  1;  double  parl  =  parl  -  1;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  double  parl  =  parl  -  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    -    1;    double  parl  =  parl  -  1;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	89	None	add
314	[BUG]  [BUGGY]  sum2  =  parl  -  1;  Sum2  =  parl  -  1;  [CE]  cannot  find  symbol  Sum2  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  Sum2  =  parl  -  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    -    1;    Sum2  =  parl  -  1;	  	non-compiled	[CE]  cannot  find  symbol  Sum2	89	None	add
315	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  double  parl2  =  parl  -  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    parl    -    1;    double  parl2  =  parl  -  1;	  	compilable	  [FE]  AssertionFailedError  	89	2	add
316	[BUG]  [BUGGY]  sum2  =  parl  -  1;  double  parl2  =  parl  -  1;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  double  parl2  =  parl  -  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    -    1;    double  parl2  =  parl  -  1;	  	compilable	  [FE]  AssertionFailedError  	89	2	add
317	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  if(sum2  >=  0)  {  sum2  =  parl  -  1;  }  else  {  sum2  =  parl  -  1;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    parl    -    1;    if(sum2  >=  0)  {  sum2  =  parl  -  1;  }  else  {  sum2  =  parl  -  1;  }	  	compilable	  [FE]  AssertionFailedError  	89	2	add
318	[BUG]  [BUGGY]  sum2  =  parl  -  1;  if(sum2  >=  0)  {  sum2  =  parl  -  1;  }  else  {  sum2  =  parl  -  1;  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  if(sum2  >=  0)  {  sum2  =  parl  -  1;  }  else  {  sum2  =  parl  -  1;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    -    1;    if(sum2  >=  0)  {  sum2  =  parl  -  1;  }  else  {  sum2  =  parl  -  1;  }	  	compilable	  [FE]  AssertionFailedError  	89	2	add
319	[BUG]  [BUGGY]  sum2  -=  Math.sqrt(diagR[pj]);  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  Math.sqrt(diagR[pj]);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  Math.sqrt(diagR[pj]);	  sum2    -=    Math.sqrt(parl);    	non-compiled	[CE]  cannot  find  symbol  pj	75	None	replace
320	[BUG]  [BUGGY]  sum  -=  Math.sqrt(delta);  [CE]  cannot  find  symbol  sum  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  Math.sqrt(delta);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  Math.sqrt(delta);	  sum2    -=    Math.sqrt(parl);    	non-compiled	[CE]  cannot  find  symbol  sum	75	None	replace
321	[BUG]  [BUGGY]  sum2  -=  Math.sqrt(solvedCols);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  Math.sqrt(solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  Math.sqrt(solvedCols);	  sum2    -=    Math.sqrt(parl);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	75	None	replace
322	[BUG]  [BUGGY]  sum2  =  qy;  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  qy;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  qy;	  sum2    =    parl;    sum2    =    parl;    	non-compiled	[CE]  incompatible  types	28	None	replace
323	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  [CE]  cannot  find  symbol  sum  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  =  Math.sqrt(sum);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  =  Math.sqrt(sum);	  sum2    =    parl;    Math.sqrt(parl);    sum2    =    parl;    	non-compiled	[CE]  cannot  find  symbol  sum	99	None	replace
324	[BUG]  [BUGGY]  Math.sqrt(parl);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Math.sqrt(parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Math.sqrt(parl);	  sum2    =    parl;    Math.sqrt(parl);    sum2    =    parl;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	99	None	replace
325	[BUG]  [BUGGY]  Math.sqrt(sum);  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Math.sqrt(sum);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Math.sqrt(sum);	  sum2    =    parl;    Math.sqrt(parl);    sum2    =    parl;    	non-compiled	[CE]  cannot  find  symbol  sum	99	None	replace
326	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(resolvedCols,  parl  -  1);  [CE]  cannot  find  symbol  resolvedCols  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(resolvedCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(resolvedCols,  parl  -  1);	  double    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	37	None	replace
327	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(resolvedCols,  parl  +  1);  [CE]  cannot  find  symbol  resolvedCols  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(resolvedCols,  parl  +  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(resolvedCols,  parl  +  1);	  double    solvedCols    =    Math.min(resolvedCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  resolvedCols	37	None	replace
328	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  sum2  /  2.0);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Double  solvedCols  =  Math.min(solvedCols,  sum2  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Double  solvedCols  =  Math.min(solvedCols,  sum2  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    sum2    /    2.0);    	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	62	None	replace
329	[BUG]  [BUGGY]  sum2  =  fp;  double  fp  =  fp;  [CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  double  fp  =  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    double  fp  =  fp;	  	non-compiled	[CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	59	None	add
330	[BUG]  [BUGGY]  sum2  =  fp;  Sum2  =  fp;  [CE]  cannot  find  symbol  Sum2  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  Sum2  =  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    Sum2  =  fp;	  	non-compiled	[CE]  cannot  find  symbol  Sum2	59	None	add
331	[BUG]  [BUGGY]  sum2  =  fp;  int  solvedCols  =  Math.min(sum2,  solvedCols);  [CE]  possible  loss  of  precision  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  int  solvedCols  =  Math.min(sum2,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    int  solvedCols  =  Math.min(sum2,  solvedCols);	  	non-compiled	[CE]  possible  loss  of  precision	59	None	add
332	[BUG]  [BUGGY]  sum2  =  fp;  int  solvedCols  =  Math.min(solvedCols,  solveCols);  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  int  solvedCols  =  Math.min(solvedCols,  solveCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    int  solvedCols  =  Math.min(solvedCols,  solveCols);	  	non-compiled	[CE]  cannot  find  symbol  solveCols	59	None	add
333	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  Sum2  =  Math.min(solvedCols,  parl);  [CE]  cannot  find  symbol  Sum2  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  Sum2  =  Math.min(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(solvedCols,    parl);    Sum2  =  Math.min(solvedCols,  parl);	  	non-compiled	[CE]  cannot  find  symbol  Sum2	72	None	add
334	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(sum2  ==  0)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum2  =  Math.min(solvedCols,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.min(solvedCols,    parl);    if(sum2  ==  0)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum2  =  Math.min(solvedCols,  parl);  }	  	compilable	  [FE]  AssertionFailedError  	72	2	add
335	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(sum2  ==  0)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum2  =  Math.min(solvedCols,  parl);  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(sum2  ==  0)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum2  =  Math.min(solvedCols,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(solvedCols,    parl);    if(sum2  ==  0)  {  sum2  =  Math.min(solvedCols,  parl);  }  else  {  sum2  =  Math.min(solvedCols,  parl);  }	  	compilable	  [FE]  AssertionFailedError  	72	2	add
336	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  double  solvedCols  =  Math.min(solvedCols,  parl);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  double  solvedCols  =  Math.min(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(solvedCols,    parl);    double  solvedCols  =  Math.min(solvedCols,  parl);	  	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	72	None	add
337	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  Math.min(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.min(solvedCols,    parl);    Math.min(solvedCols,  parl);	  	compilable	  [FE]  AssertionFailedError  	72	2	add
338	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  Math.min(solvedCols,  parl);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  Math.min(solvedCols,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(solvedCols,    parl);    Math.min(solvedCols,  parl);	  	compilable	  [FE]  AssertionFailedError  	72	2	add
339	[BUG]  [BUGGY]  sum2  -=  parl  *  solveCols;  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  *  solveCols;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  *  solveCols;	  sum2    -=    parl    *    s;    	non-compiled	[CE]  cannot  find  symbol  solveCols	46	None	replace
340	[BUG]  [BUGGY]  if(diagR  ==  null)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(diagR  ==  null)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(diagR  ==  null)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
341	[BUG]  [BUGGY]  if(diagR[pj]  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(diagR[pj]  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(diagR[pj]  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
342	[BUG]  [BUGGY]  if(delta!=  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(delta!=  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(delta!=  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
343	[BUG]  [BUGGY]  sum2  -=  permutation.length;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  permutation.length;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  permutation.length;	  sum2    -=    parl.length;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	22	None	replace
344	[BUG]  [BUGGY]  sum2  -=  permutation[l.length;  [CE]  ']'  expected  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  permutation[l.length;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  permutation[l.length;	  sum2    -=    parl.length;    	non-compiled	[CE]  ']'  expected	22	None	replace
345	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work3[pj];  [CE]  cannot  find  symbol  pj  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work3[pj];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  parl)/  work3[pj];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    permutation[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	35	None	replace
346	[BUG]  [BUGGY]  if(solvedCols  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	31	None	replace
347	[BUG]  [BUGGY]  if(diagR  ==  null)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(diagR  ==  null)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(diagR  ==  null)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	31	None	replace
348	[BUG]  [BUGGY]  if(solvedCols!=  null)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols!=  null)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols!=  null)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	31	None	replace
349	[BUG]  [BUGGY]  sum2  =  fp  /(delta  *  sum1);  [CE]  cannot  find  symbol  sum1  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp  /(delta  *  sum1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  fp  /(delta  *  sum1);	  sum2    =    fp;    	non-compiled	[CE]  cannot  find  symbol  sum1	60	None	replace
350	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(diagR[0],  diagR[1]);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(diagR[0],  diagR[1]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(diagR[0],  diagR[1]);	  int    solvedCols    =    Math.min(diagR[0],    diagR[0]);    	non-compiled	[CE]  possible  loss  of  precision	25	None	replace
351	[BUG]  [BUGGY]  float  solvedCols  =  Math.min(diagR[0],  diagR[0]);  [CE]  possible  loss  of  precision  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  float  solvedCols  =  Math.min(diagR[0],  diagR[0]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	float  solvedCols  =  Math.min(diagR[0],  diagR[0]);	  int    solvedCols    =    Math.min(diagR[0],    diagR[0]);    	non-compiled	[CE]  possible  loss  of  precision	25	None	replace
352	[BUG]  [BUGGY]  int  solveCols  =  Math.min(solveCols,  solveCols);  [CE]  variable  solveCols  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solveCols  =  Math.min(solveCols,  solveCols);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solveCols  =  Math.min(solveCols,  solveCols);	  int    solveCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  variable  solveCols  might  not  have  been  initialized	12	None	replace
353	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  permutation[0])/  work3;  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]                        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  permutation[0])/  work3;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  permutation[0])/  work3;	  double    solvedCols    =    Math.abs(parl    -    permutation[0])/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	6	None	replace
354	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  permutation[0])/  work2[0];  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  permutation[0])/  work2[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  permutation[0])/  work2[0];	  double    solvedCols    =    Math.abs(parl    -    permutation[0])/    permutation[0];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	6	None	replace
355	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagR,  parl.length);  [CE]  double  cannot  be  dereferenced  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(diagR,  parl.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(diagR,  parl.length);	  double    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  double  cannot  be  dereferenced	84	None	replace
356	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  solveCols);  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  solveCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solvedCols  =  Math.min(solvedCols,  solveCols);	  	non-compiled	[CE]  cannot  find  symbol  solveCols	78	None	add
357	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double  solvedCols  =  Math.abs(solvedCols);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double  solvedCols  =  Math.abs(solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    double  solvedCols  =  Math.abs(solvedCols);	  	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	78	None	add
358	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  sum  -  solveCols);  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  sum  -  solveCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solvedCols  =  Math.min(solvedCols,  sum  -  solveCols);	  	non-compiled	[CE]  cannot  find  symbol  sum	78	None	add
359	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  sum2);  [CE]  possible  loss  of  precision  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  sum2);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solvedCols  =  Math.min(solvedCols,  sum2);	  	non-compiled	[CE]  possible  loss  of  precision	78	None	add
360	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solveCols,  parl  -  1);  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solveCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solveCols,  parl  -  1);	  int    solvedCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  solveCols	11	None	replace
361	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solveCols,  parl  +  1);  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solveCols,  parl  +  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solveCols,  parl  +  1);	  int    solvedCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  solveCols	11	None	replace
362	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	97	None	replace
363	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum2  ==  0)  {  sum2  =  0;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum2  ==  0)  {  sum2  =  0;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  if(sum2  ==  0)  {  sum2  =  0;  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	97	None	replace
364	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	97	None	replace
365	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum2  ==  1)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum2  ==  1)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  if(sum2  ==  1)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	97	None	replace
366	[BUG]  [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  Sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [CE]  cannot  find  symbol  Sum2  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  Sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    Sum2  =  parl;  Math.sqrt(parl);  sum2  =  parl;	  	non-compiled	[CE]  cannot  find  symbol  Sum2	98	None	add
367	[BUG]  [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  double  parl  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  double  parl  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    double  parl  =  parl;  Math.sqrt(parl);  sum2  =  parl;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	98	None	add
368	[BUG]  [BUGGY]  sum2  =  Math.max(sum1,  parl);  [CE]  cannot  find  symbol  sum1  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(sum1,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.max(sum1,  parl);	  sum2    =    Math.max(s,    parl);    	non-compiled	[CE]  cannot  find  symbol  sum1	13	None	replace
369	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR.length  /  2.0);  [CE]  possible  loss  of  precision  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR.length  /  2.0);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  diagR.length  /  2.0);	  int    solvedCols    =    Math.min(solvedCols,    pj    /    2.0);    	non-compiled	[CE]  possible  loss  of  precision	93	None	replace
370	[BUG]  [BUGGY]  sum2  =  qy;  double  parl  =  qy;  [CE]  incompatible  types  [FE]        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  qy;  double  parl  =  qy;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  qy;  double  parl  =  qy;	  sum2    =    parl;    double    parl    =    parl;    	non-compiled	[CE]  incompatible  types	95	None	replace
371	[BUG]  [BUGGY]  sum2  =  sum;  double  parl  =  sum;  [CE]  cannot  find  symbol  sum  [FE]          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  sum;  double  parl  =  sum;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  sum;  double  parl  =  sum;	  sum2    =    parl;    double    parl    =    parl;    	non-compiled	[CE]  cannot  find  symbol  sum	95	None	replace
372	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  solveCols);  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  solveCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solvedCols  =  Math.min(solvedCols,  solveCols);	  	non-compiled	[CE]  cannot  find  symbol  solveCols	76	None	add
373	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  sum  -  solveCols);  [CE]  cannot  find  symbol  sum  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solvedCols  =  Math.min(solvedCols,  sum  -  solveCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solvedCols  =  Math.min(solvedCols,  sum  -  solveCols);	  	non-compiled	[CE]  cannot  find  symbol  sum	76	None	add
374	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double  solvedCols  =  Math.abs(solvedCols);  [CE]  variable  solvedCols  might  not  have  been  initialized  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  double  solvedCols  =  Math.abs(solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    double  solvedCols  =  Math.abs(solvedCols);	  	non-compiled	[CE]  variable  solvedCols  might  not  have  been  initialized	76	None	add
375	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  Integer  solvedCols  =  Math.min(solvedCols,  sum);  [CE]  cannot  find  symbol  sum  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  Integer  solvedCols  =  Math.min(solvedCols,  sum);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    Integer  solvedCols  =  Math.min(solvedCols,  sum);	  	non-compiled	[CE]  cannot  find  symbol  sum	76	None	add
376	[BUG]  [BUGGY]  sum2  =  Math.min(diagR[delta],  parl);  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(diagR[delta],  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(diagR[delta],  parl);	  sum2    =    Math.min(diagR[pj],    parl);    	non-compiled	[CE]  possible  loss  of  precision	74	None	replace
377	[BUG]  [BUGGY]  sum2  =  Math.min(diagR[pj],  solveCols);  [CE]  cannot  find  symbol  pj  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(diagR[pj],  solveCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(diagR[pj],  solveCols);	  sum2    =    Math.min(diagR[pj],    parl);    	non-compiled	[CE]  cannot  find  symbol  pj	74	None	replace
378	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solveCols,  parl  -  1);  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solveCols,  parl  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solveCols,  parl  -  1);	  double    solvedCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  solveCols	66	None	replace
379	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solveCols,  parl  +  1);  [CE]  cannot  find  symbol  solveCols  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solveCols,  parl  +  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solveCols,  parl  +  1);	  double    solvedCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  solveCols	66	None	replace
380	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(work2  -  work1)/  permutation[0];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(work2  -  work1)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(work2  -  work1)/  permutation[0];	  double    solvedCols    =    Math.abs(parl    -    work1)/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	87	None	replace
381	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  parl  +  1);  [CE]  possible  loss  of  precision  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  parl  +  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  parl  +  1);	  int    solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  possible  loss  of  precision	10	None	replace
382	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols  >  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	79	None	replace
383	[BUG]  [BUGGY]  if(solvedCols!=  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols!=  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols!=  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	79	None	replace
384	[BUG]  [BUGGY]  if(solvedCols!=  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols!=  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols!=  0)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	79	None	replace
385	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  parl)/  work3[0];  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  parl)/  work3[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  parl)/  work3[0];	  double    solvedCols    =    Math.abs(parl    -    parl)/    permutation[0];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	4	None	replace
386	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  permutation[0])/  parl;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  permutation[0])/  parl;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  permutation[0])/  parl;	  double    solvedCols    =    Math.abs(parl    -    parl)/    permutation[0];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	4	None	replace
387	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR[0],  diagR[1]);  [CE]  no  suitable  method  found  for  min(int,double,double)  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(solvedCols,  diagR[0],  diagR[1]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(solvedCols,  diagR[0],  diagR[1]);	  int    solvedCols    =    Math.min(diagR,    solvedCols);    	non-compiled	[CE]  no  suitable  method  found  for  min(int,double,double)	92	None	replace
388	[BUG]  [BUGGY]  double  solveCols  =  Math.min(solveCols,  fp);  [CE]  variable  solveCols  might  not  have  been  initialized  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solveCols  =  Math.min(solveCols,  fp);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solveCols  =  Math.min(solveCols,  fp);	  double    solveCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  variable  solveCols  might  not  have  been  initialized	36	None	replace
389	[BUG]  [BUGGY]  if(solves  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solves  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solves  >  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	32	None	replace
390	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  solveCols);  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  solveCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.max(parl,  solveCols);	  sum2    =    Math.max(parl,    sum2);    	non-compiled	[CE]  cannot  find  symbol  solveCols	15	None	replace
391	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  if(sum2  ==  0)  {  sum2  =  Math.max(parl,  parl);  }  else  {  sum2  =  Math.max(parl,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.max(parl,    parl);    if(sum2  ==  0)  {  sum2  =  Math.max(parl,  parl);  }  else  {  sum2  =  Math.max(parl,  parl);  }	  	compilable	  [FE]  AssertionFailedError  	82	2	add
392	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  parl);  if(sum2  ==  0)  {  sum2  =  Math.max(parl,  parl);  }  else  {  sum2  =  Math.max(parl,  parl);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  if(sum2  ==  0)  {  sum2  =  Math.max(parl,  parl);  }  else  {  sum2  =  Math.max(parl,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(parl,    parl);    if(sum2  ==  0)  {  sum2  =  Math.max(parl,  parl);  }  else  {  sum2  =  Math.max(parl,  parl);  }	  	compilable	  [FE]  AssertionFailedError  	82	2	add
393	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  parl);  if(sum2  ==  0)  {  sum  =  Math.max(parl,  parl);  }  else  {  sum  =  Math.max(parl,  parl);  }  [CE]  cannot  find  symbol  sum  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  if(sum2  ==  0)  {  sum  =  Math.max(parl,  parl);  }  else  {  sum  =  Math.max(parl,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(parl,    parl);    if(sum2  ==  0)  {  sum  =  Math.max(parl,  parl);  }  else  {  sum  =  Math.max(parl,  parl);  }	  	non-compiled	[CE]  cannot  find  symbol  sum	82	None	add
394	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  if(sum2  ==  0)  {  sum2  =  Math.min(parl,  parl);  }  else  {  sum2  =  Math.min(parl,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.min(parl,    parl);    if(sum2  ==  0)  {  sum2  =  Math.min(parl,  parl);  }  else  {  sum2  =  Math.min(parl,  parl);  }	  	compilable	  [FE]  AssertionFailedError  	41	2	add
395	[BUG]  [BUGGY]  sum2  =  Math.min(parl,  parl);  if(sum2  ==  0)  {  sum2  =  Math.min(parl,  parl);  }  else  {  sum2  =  Math.min(parl,  parl);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  if(sum2  ==  0)  {  sum2  =  Math.min(parl,  parl);  }  else  {  sum2  =  Math.min(parl,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(parl,    parl);    if(sum2  ==  0)  {  sum2  =  Math.min(parl,  parl);  }  else  {  sum2  =  Math.min(parl,  parl);  }	  	compilable	  [FE]  AssertionFailedError  	41	2	add
396	[BUG]  [BUGGY]  sum2  =  Math.min(parl,  parl);  if(sum2  ==  0)  {  sum2  =  Math.min(parl,  parl);  }  else  {  sum1  =  Math.min(parl,  parl);  }  [CE]  cannot  find  symbol  sum1  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  if(sum2  ==  0)  {  sum2  =  Math.min(parl,  parl);  }  else  {  sum1  =  Math.min(parl,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(parl,    parl);    if(sum2  ==  0)  {  sum2  =  Math.min(parl,  parl);  }  else  {  sum1  =  Math.min(parl,  parl);  }	  	non-compiled	[CE]  cannot  find  symbol  sum1	41	None	add
397	[BUG]  [BUGGY]  sum2  =  parl  +  1;  int  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  parl  +  1;  [CE]  possible  loss  of  precision  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  int  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  parl  +  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    int  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  parl  +  1;	  	non-compiled	[CE]  possible  loss  of  precision	8	None	add
398	[BUG]  [BUGGY]  sum2  =  parl  +  1;  Sum2  =  parl  +  1;  [CE]  cannot  find  symbol  Sum2  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  Sum2  =  parl  +  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    Sum2  =  parl  +  1;	  	non-compiled	[CE]  cannot  find  symbol  Sum2	8	None	add
399	[BUG]  [BUGGY]  sum2  =  parl  +  1;  double  parl  =  parl  +  1;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  double  parl  =  parl  +  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    double  parl  =  parl  +  1;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	add
400	[BUG]  [BUGGY]  sum2  =  parl  +  1;  int  solvedCols  =  Math.min(sum2  -  1,  solveCols);  sum2  =  parl  +  1;  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  int  solvedCols  =  Math.min(sum2  -  1,  solveCols);  sum2  =  parl  +  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    int  solvedCols  =  Math.min(sum2  -  1,  solveCols);  sum2  =  parl  +  1;	  	non-compiled	[CE]  cannot  find  symbol  solveCols	8	None	add
401	[BUG]  [BUGGY]  sum2    =    parl;    sum2  =  parl;  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    sum2  =  parl;  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        sum2    =    parl;    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  cannot  find  symbol  solveCols	27	None	add
402	[BUG]  [BUGGY]  sum2    =    parl;    sum2  =  parl;  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  sum  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    sum2  =  parl;  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        sum2    =    parl;    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  cannot  find  symbol  sum	27	None	add
403	[BUG]  [BUGGY]  sum2    =    parl;    sum2  =  parl;  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  diagR[pj];  }  [CE]  cannot  find  symbol  solveCols  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    sum2  =  parl;  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  diagR[pj];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        sum2    =    parl;    for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  diagR[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  solveCols	27	None	add
404	[BUG]  [BUGGY]  sum2  =  fp  /(delta  *  gNorm);  [CE]  cannot  find  symbol  gNorm  [FE]        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp  /(delta  *  gNorm);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  fp  /(delta  *  gNorm);	  sum2    =    fp    /(delta    *    sum2);    	non-compiled	[CE]  cannot  find  symbol  gNorm	7	None	replace
405	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2  =  Math.max(parl,  solvedCols);	  sum2    =    Math.max(parl,    sum);    	compilable	  [FE]  AssertionFailedError  	14	3	replace
406	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  solvedCols);  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  solvedCols);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.max(parl,  solvedCols);	  sum2    =    Math.max(parl,    sum);    	compilable	  [FE]  AssertionFailedError  	14	3	replace
407	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work1[i])/  work1[pj];  [CE]  cannot  find  symbol  i  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work1[i])/  work1[pj];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  work1[i])/  work1[pj];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[pj];    	non-compiled	[CE]  cannot  find  symbol  i	56	None	replace
408	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work2)/  work1[pj];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work2)/  work1[pj];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  work2)/  work1[pj];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[pj];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	56	None	replace
409	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work1)/  work3[pj];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work1)/  work3[pj];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  work1)/  work3[pj];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[pj];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	56	None	replace
410	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solveCols,  diagR.length);  [CE]  cannot  find  symbol  solveCols  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solveCols,  diagR.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solveCols,  diagR.length);	  double    solvedCols    =    Math.min(solveCols,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  solveCols	67	None	replace
411	[BUG]  [BUGGY]  if(sum  <  =  0)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(sum  <  =  0)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(sum  <  =  0)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	97	None	replace
412	[BUG]  [BUGGY]  sum  =  parl;  if(sum  <  =  0)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  =  parl;  if(sum  <  =  0)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  =  parl;  if(sum  <  =  0)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	97	None	replace
413	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  Math.sqrt(sum2);  sum2  =  parl  -  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    parl    -    1;    Math.sqrt(sum2);  sum2  =  parl  -  1;	  	compilable	  [FE]  AssertionFailedError  	89	2	add
414	[BUG]  [BUGGY]  sum2  =  parl  -  1;  Math.sqrt(sum2);  sum2  =  parl  -  1;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  -  1;  Math.sqrt(sum2);  sum2  =  parl  -  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    -    1;    Math.sqrt(sum2);  sum2  =  parl  -  1;	  	compilable	  [FE]  AssertionFailedError  	89	2	add
415	[BUG]  [BUGGY]  sum2  -=  parl  *  tmp;  [CE]  cannot  find  symbol  tmp  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  *  tmp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  *  tmp;	  sum2    -=    parl    *    s;    	non-compiled	[CE]  cannot  find  symbol  tmp	46	None	replace
416	[BUG]  [BUGGY]  sum2  -=  Math.sqrt(s);  [CE]  cannot  find  symbol  s  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  Math.sqrt(s);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  Math.sqrt(s);	  sum2    -=    Math.sqrt(parl);    	non-compiled	[CE]  cannot  find  symbol  s	75	None	replace
417	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(parl,  parl);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(parl,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(parl,  parl);	  double    solvedCols    =    Math.min(parl,    solveCols);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	38	None	replace
418	[BUG]  [BUGGY]  sum2  /=  parl;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  /=  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  /=  parl;	  sum2    =    s;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	58	None	replace
419	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  double  parl2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    double  parl2  =  parl;  Math.sqrt(parl);  sum2  =  parl;	  	compilable	  [FE]  AssertionFailedError  	98	2	add
420	[BUG]  [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  double  parl2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    Math.sqrt(parl);  sum2  =  parl;  double  parl2  =  parl;  Math.sqrt(parl);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        Math.sqrt(parl);    sum2    =    parl;    double  parl2  =  parl;  Math.sqrt(parl);  sum2  =  parl;	  	compilable	  [FE]  AssertionFailedError  	98	2	add
421	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work2[parl])/  work1[parl];  [CE]  possible  loss  of  precision  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work2[parl])/  work1[parl];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  work2[parl])/  work1[parl];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[parl];    	non-compiled	[CE]  possible  loss  of  precision	33	None	replace
422	[BUG]  [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  [CE]  incomparable  types:  int  and  <null>  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(solvedCols,  parl);  if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(solvedCols,    parl);    if(solvedCols!=  null)  {  sum2  =  Math.min(solvedCols,  parl);  }	  	non-compiled	[CE]  incomparable  types:  int  and  <null>	72	None	add
423	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  if(sum2  ==  fp)  {  sum2  =  fp;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    fp;    if(sum2  ==  fp)  {  sum2  =  fp;  }	  	compilable	  [FE]  AssertionFailedError  	59	2	add
424	[BUG]  [BUGGY]  sum2  =  fp;  if(sum2  ==  fp)  {  sum2  =  fp;  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  if(sum2  ==  fp)  {  sum2  =  fp;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    if(sum2  ==  fp)  {  sum2  =  fp;  }	  	compilable	  [FE]  AssertionFailedError  	59	2	add
425	[BUG]  [BUGGY]  sum2  =  fp;  int  fp  =  fp;  [CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  fp;  int  fp  =  fp;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    fp;    int  fp  =  fp;	  	non-compiled	[CE]  variable  fp  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	59	None	add
426	[BUG]  [BUGGY]  if(diagR[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(diagR[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(diagR[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	31	None	replace
427	[BUG]  [BUGGY]  if(diagR[pj]  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(diagR[pj]  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(diagR[pj]  ==  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	31	None	replace
428	[BUG]  [BUGGY]  if(diagR[pj]  ==  0.0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(diagR[pj]  ==  0.0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(diagR[pj]  ==  0.0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  work2[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    work2[i];    }    	non-compiled	[CE]  illegal  start  of  expression	31	None	replace
429	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	79	None	replace
430	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  if(sum2!=  0)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  illegal  start  of  expression	79	None	replace
431	[BUG]  [BUGGY]  if(solvedCols)  {  sum2  =  parl;  }  [CE]  incompatible  types  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(solvedCols)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(solvedCols)  {  sum2  =  parl;  }	  sum2    =    parl;    if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    	non-compiled	[CE]  incompatible  types	77	None	replace
432	[BUG]  [BUGGY]  if(diagR[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(diagR[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(diagR[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solveCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	30	None	replace
433	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work3);  [CE]  no  suitable  method  found  for  min(double,double[])  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solvedCols,  work3);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solvedCols,  work3);	  double    solvedCols    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  no  suitable  method  found  for  min(double,double[])	85	None	replace
434	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(diagr,  diagR.length);  [CE]  cannot  find  symbol  diagr  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(diagr,  diagR.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(diagr,  diagR.length);	  int    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  cannot  find  symbol  diagr	64	None	replace
435	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(diagr,  parl.length);  [CE]  cannot  find  symbol  diagr  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(diagr,  parl.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(diagr,  parl.length);	  int    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  cannot  find  symbol  diagr	64	None	replace
436	[BUG]  [BUGGY]  solvedCols  =  Math.min(solvedCols,  tmp);  [CE]  cannot  find  symbol  tmp  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  solvedCols  =  Math.min(solvedCols,  tmp);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	solvedCols  =  Math.min(solvedCols,  tmp);	  solvedCols    =    Math.min(solvedCols,    gNorm);    	non-compiled	[CE]  cannot  find  symbol  tmp	3	None	replace
437	[BUG]  [BUGGY]  sum2  =  Math.min(sum2.length,  parl);  [CE]  double  cannot  be  dereferenced  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(sum2.length,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(sum2.length,  parl);	  sum2    =    Math.min(s,    parl);    	non-compiled	[CE]  double  cannot  be  dereferenced	39	None	replace
438	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  Integer  solvedCols  =  Math.max(solvedCols,  sum);  [CE]  cannot  find  symbol  sum  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  Integer  solvedCols  =  Math.max(solvedCols,  sum);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    Integer  solvedCols  =  Math.max(solvedCols,  sum);	  	non-compiled	[CE]  cannot  find  symbol  sum	76	None	add
439	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solveCols  =  Math.min(solvedCols,  sum  -  1);  [CE]  cannot  find  symbol  sum  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  int  solveCols  =  Math.min(solvedCols,  sum  -  1);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    int  solveCols  =  Math.min(solvedCols,  sum  -  1);	  	non-compiled	[CE]  cannot  find  symbol  sum	76	None	add
440	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  Integer  solvedCols  =  Math.max(solvedCols,  sum  /  2.0);  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  parl)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  Integer  solvedCols  =  Math.max(solvedCols,  sum  /  2.0);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    parl)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    Integer  solvedCols  =  Math.max(solvedCols,  sum  /  2.0);	  	non-compiled	[CE]  cannot  find  symbol  sum	76	None	add
441	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  -  work1)/  permutation[1];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  -  work1)/  permutation[1];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  -  work1)/  permutation[1];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    permutation[1];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	57	None	replace
442	[BUG]  [BUGGY]  sum  -=  parl  +  2;  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum  -=  parl  +  2;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum  -=  parl  +  2;	  sum2    -=    parl    +    2;    	non-compiled	[CE]  cannot  find  symbol  sum	88	None	replace
443	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(permutation[0  -  parl)/  permutation[0];  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(permutation[0  -  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(permutation[0  -  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(param    -    parl)/    permutation[0];    	non-compiled	[CE]  ']'  expected	5	None	replace
444	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(diagR[para]);  [CE]  cannot  find  symbol  para  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(diagR[para]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(diagR[para]);	  double    solvedCols    =    Math.abs(diagR[pj]);    	non-compiled	[CE]  cannot  find  symbol  para	51	None	replace
445	[BUG]  [BUGGY]  sum2    =    parl;    sum2  =  parl;  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  diagR[pj];  }  [CE]  cannot  find  symbol  sum  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    sum2  =  parl;  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  diagR[pj];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        sum2    =    parl;    for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  diagR[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  sum	27	None	add
446	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(diagr,  diagR.length);  [CE]  cannot  find  symbol  diagr  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(diagr,  diagR.length);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(diagr,  diagR.length);	  double    solvedCols    =    Math.min(solvedCols,    diagR.length);    	non-compiled	[CE]  cannot  find  symbol  diagr	84	None	replace
447	[BUG]  [BUGGY]  double  solveCols  =  Math.min(diagR,  parl);  [CE]  no  suitable  method  found  for  min(double[],double)  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solveCols  =  Math.min(diagR,  parl);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solveCols  =  Math.min(diagR,  parl);	  double    solveCols    =    Math.min(solveCols,    parl);    	non-compiled	[CE]  no  suitable  method  found  for  min(double[],double)	36	None	replace
448	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(work1  -  work1)/  parl[0];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(work1  -  work1)/  parl[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(work1  -  work1)/  parl[0];	  double    solvedCols    =    Math.abs(parl    -    work1)/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	87	None	replace
449	[BUG]  [BUGGY]  solvedCols  =  Math.min(solvedCols,  diagR[pj]);  [CE]  cannot  find  symbol  pj  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  solvedCols  =  Math.min(solvedCols,  diagR[pj]);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	solvedCols  =  Math.min(solvedCols,  diagR[pj]);	  solvedCols    =    Math.min(solvedCols,    parl);    	non-compiled	[CE]  cannot  find  symbol  pj	1	None	replace
450	[BUG]  [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  if(solvedCols!=  null)  {  sum2  =  Math.max(solvedCols,  parl);  }  [CE]  incomparable  types:  int  and  <null>  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(solvedCols,  parl);  if(solvedCols!=  null)  {  sum2  =  Math.max(solvedCols,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(solvedCols,    parl);    if(solvedCols!=  null)  {  sum2  =  Math.max(solvedCols,  parl);  }	  	non-compiled	[CE]  incomparable  types:  int  and  <null>	53	None	add
451	[BUG]  [BUGGY]  sum2  =  parl  +  1;  int  parl  =  parl  +  1;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  int  parl  =  parl  +  1;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    int  parl  =  parl  +  1;	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	add
452	[BUG]  [BUGGY]  sum2  =  parl  +  1;  if(sum2  <  =  parl)  {  sum2  =  parl  +  1;  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  parl  +  1;  if(sum2  <  =  parl)  {  sum2  =  parl  +  1;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    parl    +    1;    if(sum2  <  =  parl)  {  sum2  =  parl  +  1;  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
453	[BUG]  [BUGGY]  double  sum  -=  0;  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  sum  -=  0;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  sum  -=  0;	  sum    -=    0;    	non-compiled	[CE]  ';'  expected	18	None	replace
454	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work2[pj])/  work1[pj];  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(solvedCols  -  work2[pj])/  work1[pj];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(solvedCols  -  work2[pj])/  work1[pj];	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1[pj];    	non-compiled	[CE]  cannot  find  symbol  pj	56	None	replace
455	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  s);  [CE]  cannot  find  symbol  s  [FE]              AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  s);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.max(parl,  s);	  sum2    =    Math.max(parl,    sum);    	non-compiled	[CE]  cannot  find  symbol  s	14	None	replace
456	[BUG]  [BUGGY]  Math.sqrt(work3);  sum2  =  parl;  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  Math.sqrt(work3);  sum2  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	Math.sqrt(work3);  sum2  =  parl;	  sum2    =    parl;    Math.sqrt(parl);    sum2    =    parl;    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	99	None	replace
457	[BUG]  [BUGGY]  sum2  =  Math.min(diagR[pj],  qy);  [CE]  cannot  find  symbol  pj  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(diagR[pj],  qy);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  =  Math.min(diagR[pj],  qy);	  sum2    =    Math.min(diagR[pj],    parl);    	non-compiled	[CE]  cannot  find  symbol  pj	74	None	replace
458	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(work1  -  work1.length)/  solveCols;  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                  AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(work1  -  work1.length)/  solveCols;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(work1  -  work1.length)/  solveCols;	  double    solvedCols    =    Math.abs(solvedCols    -    parl)/    work1.length;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	34	None	replace
459	[BUG]  [BUGGY]  if(diagR[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(diagR[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(diagR[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
460	[BUG]  [BUGGY]  if(diag[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  if(diag[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	if(diag[pj]  <  =  0)  {  sum2  =  parl;  }  else  {  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  sum2    =    parl;    if(sum2    ==    parl)    {    sum2    =    parl;    }    else    {    for(int    i    =    0;    i    <    solvedCols;    ++i)    {    sum    +=    work1[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	29	None	replace
461	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(s);  [CE]  cannot  find  symbol  s  [FE]                AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(s);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(s);	  double    solvedCols    =    Math.abs(parl);    	non-compiled	[CE]  cannot  find  symbol  s	49	None	replace
462	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(solutions,  solveCols);  [CE]  cannot  find  symbol  solutions  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(solutions,  solveCols);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(solutions,  solveCols);	  double    solvedCols    =    Math.min(solveCols,    solveCols);    	non-compiled	[CE]  cannot  find  symbol  solutions	67	None	replace
463	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(sum2,  solvedCols  -  1);  [CE]  variable  sum2  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.min(sum2,  solvedCols  -  1);  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.min(sum2,  solvedCols  -  1);	  int    solvedCols    =    Math.min(solvedCols,    sum2    -    1);    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	61	None	replace
464	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  double  parl2  =  Math.max(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	add	sum2    =    Math.max(parl,    parl);    double  parl2  =  Math.max(parl,  parl);	  	compilable	  [FE]  AssertionFailedError  	82	2	add
465	[BUG]  [BUGGY]  sum2  =  Math.max(parl,  parl);  double  parl2  =  Math.max(parl,  parl);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.max(parl,  parl);  double  parl2  =  Math.max(parl,  parl);  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.max(parl,    parl);    double  parl2  =  Math.max(parl,  parl);	  	compilable	  [FE]  AssertionFailedError  	82	2	add
466	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  if(solvedCols  >  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  sum  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  if(solvedCols  >  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    if(solvedCols  >  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }	  	non-compiled	[CE]  cannot  find  symbol  sum	78	None	add
467	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  if(solvedCols  >  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  else  {  sum2  =  parl;  }  [CE]  cannot  find  symbol  sum  [FE]      AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  if(solvedCols  >  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  else  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    if(solvedCols  >  0)  {  sum  +=  work1[i][pj]  *  qy[i];  }  else  {  sum2  =  parl;  }	  	non-compiled	[CE]  cannot  find  symbol  sum	78	None	add
468	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  if(solvedCols  >  0)  {  sum  +=  work1[pj]  *  qy[pj];  }  [CE]  cannot  find  symbol  sum  [FE]        AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  if(solvedCols  >  0)  {  sum  +=  work1[pj]  *  qy[pj];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    if(solvedCols  >  0)  {  sum  +=  work1[pj]  *  qy[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  sum	78	None	add
469	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  if(solvedCols  >  0)  {  sum  +=  work1[pj]  *  diagR[pj];  }  [CE]  cannot  find  symbol  sum  [FE]          AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  if(solvedCols  >  0)  {  sum  +=  work1[pj]  *  diagR[pj];  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    if(solvedCols  >  0)  {  sum  +=  work1[pj]  *  diagR[pj];  }	  	non-compiled	[CE]  cannot  find  symbol  sum	78	None	add
470	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  if(solvedCols  >  0)  {  sum  +=  work1[pj]  *  qy[pj];  }  else  {  sum2  =  parl;  }  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2!=  0)  {  sum2  =  parl;  }  else  {  sum2  =  parl;  }  if(solvedCols  >  0)  {  sum  +=  work1[pj]  *  qy[pj];  }  else  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2!=    0)    {    sum2    =    parl;    }    else    {    sum2    =    parl;    }    if(solvedCols  >  0)  {  sum  +=  work1[pj]  *  qy[pj];  }  else  {  sum2  =  parl;  }	  	non-compiled	[CE]  cannot  find  symbol  sum	78	None	add
471	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(diagR  -  parl)/  work3[0];  [CE]  bad  operand  types  for  binary  operator  '-'  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(diagR  -  parl)/  work3[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(diagR  -  parl)/  work3[0];	  double    solvedCols    =    Math.abs(diagR    -    parl)/    permutation[0];    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '-'	68	None	replace
472	[BUG]  [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  double  parl  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2    =    parl;    if(sum2  ==  parl)  {  sum2  =  parl;  }  double  parl  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2        =        parl;        if(sum2    ==    parl)    {    sum2    =    parl;    }    double  parl  =  parl;  if(sum2  ==  parl)  {  sum2  =  parl;  }	  	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	96	None	add
473	[BUG]  [BUGGY]  sum2  -=  parl  *  dxNorm;  [CE]  variable  sum2  might  not  have  been  initialized  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  -=  parl  *  dxNorm;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2  -=  parl  *  dxNorm;	  sum2    -=    parl    *    type;    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	94	None	replace
474	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(parl  *  parl)/  permutation[0];  [CE]  variable  sum2  might  not  have  been  initialized  [FE]                    AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(parl  *  parl)/  permutation[0];  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(parl  *  parl)/  permutation[0];	  double    solvedCols    =    Math.abs(parl    -    parl)/    permutation[0];    	non-compiled	[CE]  variable  sum2  might  not  have  been  initialized	4	None	replace
475	[BUG]  [BUGGY]  double  solvedCols  =  Math.abs(permutation[0  -  parl)/  parl;  [CE]  ']'  expected  [FE]                      AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  solvedCols  =  Math.abs(permutation[0  -  parl)/  parl;  [BUGGY]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  solvedCols  =  Math.abs(permutation[0  -  parl)/  parl;	  double    solvedCols    =    Math.abs(parl    -    parl)/    permutation[0];    	non-compiled	[CE]  ']'  expected	4	None	replace
476	[BUG]  [BUGGY]  double  parl  =  parl;  [CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  double  parl  =  parl;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	double  parl  =  parl;	  sum2    =    parl;    double    parl    =    parl;    	non-compiled	[CE]  variable  parl  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	95	None	replace
477	[BUG]  [BUGGY]  sum2  =  Math.min(parl,  parl);  if(s  >  0)  {  sum2  =  Math.min(parl,  parl);  }  [CE]  cannot  find  symbol  s  [FE]    AssertionFailedError    [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  sum2  =  Math.min(parl,  parl);  if(s  >  0)  {  sum2  =  Math.min(parl,  parl);  }  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	sum2    =    Math.min(parl,    parl);    if(s  >  0)  {  sum2  =  Math.min(parl,  parl);  }	  	non-compiled	[CE]  cannot  find  symbol  s	41	None	add
478	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  0;  [CE]  possible  loss  of  precision  [FE]            AssertionFailedError      [CONTEXT]      sum  +=  jacobian[i][pj]  *  work1[permutation[i]];  }  double  s  =  (work1[pj]  -  sum)  /  diagR[pj];  work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }        [BUGGY]  int  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  0;  [BUGGY]      for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	549	549	2	replace	int  solvedCols  =  Math.min(sum2,  solvedCols);  sum2  =  0;	  sum2    =    parl;    int    solvedCols    =    Math.min(sum2,    solvedCols);    sum2    =    parl;    	non-compiled	[CE]  possible  loss  of  precision	80	None	replace
