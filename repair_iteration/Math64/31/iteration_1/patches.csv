bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  sum  /=  solveCols[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  solveCols[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  /=  solveCols[i][pj]  *  qy[i];	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	16	None	replace
2	[BUG]  [BUGGY]  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  'else'  without  'if'  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  'else'  without  'if'	16	None	replace
3	[BUG]  [BUGGY]  sum  +=  qy  *  sum;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  qy  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  qy  *  sum;	  sum2    +=    qy    *    sum;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	20	None	replace
4	[BUG]  [BUGGY]  sum  -=  qy  *  sum;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  qy  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  -=  qy  *  sum;	  sum2    +=    qy    *    sum;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	20	None	replace
5	[BUG]  [BUGGY]  sum  /=  qy  *  sum;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  qy  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  /=  qy  *  sum;	  sum2    +=    qy    *    sum;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	20	None	replace
6	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
7	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  q	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	11	None	replace
8	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    permutation[j]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	24	None	replace
9	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solvedCols  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solvedCols  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    permutation[j]    *    qy[j];    }    	non-compiled	[CE]  illegal  start  of  expression	24	None	replace
10	[BUG]  [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }  [CE]  cannot  find  symbol  bucket  [FE]                  AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	bucket  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    permutation[j]    *    qy[j];    }    	non-compiled	[CE]  cannot  find  symbol  bucket	24	None	replace
11	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    permutation[j]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	24	None	replace
12	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  permutation[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  permutation[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  permutation[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    	non-compiled	[CE]  illegal  start  of  expression	14	None	replace
13	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  work3;  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  work3;  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  work3;  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    	non-compiled	[CE]  illegal  start  of  expression	14	None	replace
14	[BUG]  [BUGGY]  sum  /=  solvedCols[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  i  [FE]                    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  solvedCols[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  /=  solvedCols[i][pj]  *  qy[i];	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    	non-compiled	[CE]  cannot  find  symbol  i	14	None	replace
15	[BUG]  [BUGGY]  sum  +=  solves[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  solves  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solves[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solves[i][pj]  *  qy[i];	      sum    +=    solveCols[i][pj]    *    qy[i];    	non-compiled	[CE]  cannot  find  symbol  solves	15	None	replace
16	[BUG]  [BUGGY]  sum  +=  solvedCols[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  i  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solvedCols[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solvedCols[i][pj]  *  qy[i];	      sum    +=    solveCols[i][pj]    *    qy[i];    	non-compiled	[CE]  cannot  find  symbol  i	15	None	replace
17	[BUG]  [BUGGY]  sum  +=  solver[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  solver  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solver[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solver[i][pj]  *  qy[i];	      sum    +=    solveCols[i][pj]    *    qy[i];    	non-compiled	[CE]  cannot  find  symbol  solver	15	None	replace
18	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  =  Math.sqrt(sum);	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	compilable	  [FE]  AssertionFailedError  	19	4	replace
19	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	compilable	  [FE]  AssertionFailedError  	19	4	replace
20	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  'else'  without  'if'  [FE]                  AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  'else'  without  'if'	19	None	replace
21	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum,  solveCols[i][pj]  *  qy[i]);  [CE]  cannot  find  symbol  solveCols  [FE]                    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum,  solveCols[i][pj]  *  qy[i]);  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum,  solveCols[i][pj]  *  qy[i]);	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	19	None	replace
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  2;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum2  +=  sum  /  2;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	14	replace
23	[BUG]  [BUGGY]  sum2  +=  sum  /  2;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  2;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  sum  /  2;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	14	replace
24	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  sum  /  2;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  +=  sum  /  2;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	4	replace
25	[BUG]  [BUGGY]  sum  +=  sum  /  2;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  sum  /  2;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  sum  /  2;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	4	replace
26	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  3;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum2  +=  sum  /  3;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	15	replace
27	[BUG]  [BUGGY]  sum2  +=  sum  /  3;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  3;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  sum  /  3;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	15	replace
28	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  1;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum2  +=  sum  /  1;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	15	replace
29	[BUG]  [BUGGY]  sum2  +=  sum  /  1;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  1;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  sum  /  1;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	15	replace
30	[BUG]  [BUGGY]  Sum  sum  +=  solvedCols[i][pj]  *  qy[i];  [CE]  ';'  expected  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  Sum  sum  +=  solvedCols[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	Sum  sum  +=  solvedCols[i][pj]  *  qy[i];	      if(solvedCols!=    null)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  ';'  expected	12	None	replace
31	[BUG]  [BUGGY]  Sum  +=  solvedCols[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  Sum  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  Sum  +=  solvedCols[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	Sum  +=  solvedCols[i][pj]  *  qy[i];	      if(solvedCols!=    null)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  Sum	12	None	replace
32	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[j][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	21	None	replace
33	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solveable[j][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solveable[j][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solveable[j][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[j][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	21	None	replace
34	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[j][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	21	None	replace
35	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  Math.sqrt(sum);  sum2  +=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum2    +=    Math.sqrt(sum);    sum2  +=  Math.sqrt(sum);	  	compilable	  [FE]  AssertionFailedError  	26	15	add
36	[BUG]  [BUGGY]  sum2  +=  Math.sqrt(sum);  sum2  +=  Math.sqrt(sum);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  Math.sqrt(sum);  sum2  +=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    Math.sqrt(sum);    sum2  +=  Math.sqrt(sum);	  	compilable	  [FE]  AssertionFailedError  	26	15	add
37	[BUG]  [BUGGY]  sum2  +=  Math.sqrt(sum);  sum1  +=  Math.sqrt(sum);  [CE]  cannot  find  symbol  sum1  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  Math.sqrt(sum);  sum1  +=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    Math.sqrt(sum);    sum1  +=  Math.sqrt(sum);	  	non-compiled	[CE]  cannot  find  symbol  sum1	26	None	add
38	[BUG]  [BUGGY]  sum2  +=  Math.sqrt(sum);  Sum2  +=  Math.sqrt(sum);  [CE]  cannot  find  symbol  Sum2  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  Math.sqrt(sum);  Sum2  +=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    Math.sqrt(sum);    Sum2  +=  Math.sqrt(sum);	  	non-compiled	[CE]  cannot  find  symbol  Sum2	26	None	add
39	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  Math.sqrt(sum);  sum2  -=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum2    +=    Math.sqrt(sum);    sum2  -=  Math.sqrt(sum);	  	compilable	  [FE]  AssertionFailedError  	26	14	add
40	[BUG]  [BUGGY]  sum2  +=  Math.sqrt(sum);  sum2  -=  Math.sqrt(sum);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  Math.sqrt(sum);  sum2  -=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    Math.sqrt(sum);    sum2  -=  Math.sqrt(sum);	  	compilable	  [FE]  AssertionFailedError  	26	14	add
41	[BUG]  [BUGGY]  sum2  +=  Math.sqrt(sum);  sum3  +=  Math.sqrt(sum);  [CE]  cannot  find  symbol  sum3  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  Math.sqrt(sum);  sum3  +=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    Math.sqrt(sum);    sum3  +=  Math.sqrt(sum);	  	non-compiled	[CE]  cannot  find  symbol  sum3	26	None	add
42	[BUG]  [BUGGY]  sum  +=  sum  *  qy[i];  [CE]  cannot  find  symbol  i  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  sum  *  qy[i];  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  sum  *  qy[i];	  sum2    +=    sum    *    qy;    	non-compiled	[CE]  cannot  find  symbol  i	5	None	replace
43	[BUG]  [BUGGY]  sum2  +=  sum  *  qy[i];  [CE]  cannot  find  symbol  i  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  *  qy[i];  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  sum  *  qy[i];	  sum2    +=    sum    *    qy;    	non-compiled	[CE]  cannot  find  symbol  i	5	None	replace
44	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  *  qy[j];  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum2  +=  sum  *  qy[j];	  sum2    +=    sum    *    qy;    	compilable	  [FE]  AssertionFailedError  	5	14	replace
45	[BUG]  [BUGGY]  sum2  +=  sum  *  qy[j];  [FE]  AssertionFailedError  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  *  qy[j];  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  sum  *  qy[j];	  sum2    +=    sum    *    qy;    	compilable	  [FE]  AssertionFailedError  	5	14	replace
46	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  solvedCols  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  -=  solvedCols  *  sum;	  sum    -=    sum    *    sum;    	compilable	  [FE]  AssertionFailedError  	7	4	replace
47	[BUG]  [BUGGY]  sum  -=  solvedCols  *  sum;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  solvedCols  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  -=  solvedCols  *  sum;	  sum    -=    sum    *    sum;    	compilable	  [FE]  AssertionFailedError  	7	4	replace
48	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  solvedCols;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  -=  sum  *  solvedCols;	  sum    -=    sum    *    sum;    	compilable	  [FE]  AssertionFailedError  	7	4	replace
49	[BUG]  [BUGGY]  sum  -=  sum  *  solvedCols;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  solvedCols;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  -=  sum  *  solvedCols;	  sum    -=    sum    *    sum;    	compilable	  [FE]  AssertionFailedError  	7	4	replace
50	[BUG]  [BUGGY]  sum  -=  solveCols  *  sum;  [CE]  cannot  find  symbol  solveCols  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  solveCols  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  -=  solveCols  *  sum;	  sum    -=    sum    *    sum;    	non-compiled	[CE]  cannot  find  symbol  solveCols	7	None	replace
51	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  2;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  -=  sum  *  2;	  sum    -=    sum    *    sum;    	compilable	  [FE]  AssertionFailedError  	7	4	replace
52	[BUG]  [BUGGY]  sum  -=  sum  *  2;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  2;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  -=  sum  *  2;	  sum    -=    sum    *    sum;    	compilable	  [FE]  AssertionFailedError  	7	4	replace
53	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solvedCols[i][pj]  *  q  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solvedCols[i][pj]  *  q  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solvedCols[i][pj]  *  q	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    i;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	18	None	replace
54	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    i;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	18	None	replace
55	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solvedCols[i][pj]  *  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solvedCols[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solvedCols[i][pj]  *	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    i;    ++i)    {    sum    +=    solvedCols[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	18	None	replace
56	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  sum;  sum2  +=  sum  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum2    +=    sum    /    sum;    sum2  +=  sum  /  sum;	  	compilable	  [FE]  AssertionFailedError  	1	4	add
57	[BUG]  [BUGGY]  sum2  +=  sum  /  sum;  sum2  +=  sum  /  sum;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  sum;  sum2  +=  sum  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    sum    /    sum;    sum2  +=  sum  /  sum;	  	compilable	  [FE]  AssertionFailedError  	1	4	add
58	[BUG]  [BUGGY]  sum2  +=  sum  /  sum;  Sum2  +=  sum  /  sum;  [CE]  cannot  find  symbol  Sum2  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  sum;  Sum2  +=  sum  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    sum    /    sum;    Sum2  +=  sum  /  sum;	  	non-compiled	[CE]  cannot  find  symbol  Sum2	1	None	add
59	[BUG]  [BUGGY]  sum2  +=  sum  /  sum;  sum2  +=  sum  /  Sum;  [CE]  cannot  find  symbol  Sum  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  sum;  sum2  +=  sum  /  Sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    sum    /    sum;    sum2  +=  sum  /  Sum;	  	non-compiled	[CE]  cannot  find  symbol  Sum	1	None	add
60	[BUG]  [BUGGY]  sum2  +=  sum  /  sum;  sum2  +=  sum  /  total;  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  sum;  sum2  +=  sum  /  total;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    sum    /    sum;    sum2  +=  sum  /  total;	  	non-compiled	[CE]  cannot  find  symbol  total	1	None	add
61	[BUG]  [BUGGY]  sum2  +=  sum  /  sum;  sum1  +=  sum  /  sum;  [CE]  cannot  find  symbol  sum1  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  sum;  sum1  +=  sum  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    sum    /    sum;    sum1  +=  sum  /  sum;	  	non-compiled	[CE]  cannot  find  symbol  sum1	1	None	add
62	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[i];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[j][pj]    *    qy[i];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	25	None	replace
63	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solveable[j][pj]  *  qy[i];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solveable[j][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solveable[j][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[j][pj]    *    qy[i];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	25	None	replace
64	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[i];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solved[j][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[j][pj]    *    qy[i];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	25	None	replace
65	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  work3[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  work3[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  work3[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  qy[	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	13	None	replace
66	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  work3[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  work3[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  work3[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	13	None	replace
67	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	13	None	replace
68	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  sum  -=  sum  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum    -=    sum    *    sum;    sum  -=  sum  *  sum;	  	compilable	  [FE]  AssertionFailedError  	6	3	add
69	[BUG]  [BUGGY]  sum  -=  sum  *  sum;  sum  -=  sum  *  sum;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  sum  -=  sum  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    -=    sum    *    sum;    sum  -=  sum  *  sum;	  	compilable	  [FE]  AssertionFailedError  	6	3	add
70	[BUG]  [BUGGY]  sum  -=  sum  *  sum;  Sum  -=  sum  *  sum;  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  Sum  -=  sum  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    -=    sum    *    sum;    Sum  -=  sum  *  sum;	  	non-compiled	[CE]  cannot  find  symbol  Sum	6	None	add
71	[BUG]  [BUGGY]  sum  -=  sum  *  sum;  double  -=  sum  *  sum;  [CE]  unexpected  type  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  double  -=  sum  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    -=    sum    *    sum;    double  -=  sum  *  sum;	  	non-compiled	[CE]  unexpected  type	6	None	add
72	[BUG]  [BUGGY]  sum  -=  sum  *  sum;  total  -=  sum  *  sum;  [CE]  cannot  find  symbol  total  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  total  -=  sum  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    -=    sum    *    sum;    total  -=  sum  *  sum;	  	non-compiled	[CE]  cannot  find  symbol  total	6	None	add
73	[BUG]  [BUGGY]  sum  -=  sum  *  sum;  -=  sum  *  sum;  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  -=  sum  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    -=    sum    *    sum;    -=  sum  *  sum;	  	non-compiled	[CE]  illegal  start  of  expression	6	None	add
74	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    i;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	17	None	replace
75	[BUG]  [BUGGY]  sum  +=  solveCols[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solveCols[i][pj]  *  qy[  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solveCols[i][pj]  *  qy[	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    i;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	17	None	replace
76	[BUG]  [BUGGY]  sum  =  solveCols[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  solveCols[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  solveCols[i][pj]  *  qy[i];	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    i;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[    	non-compiled	[CE]  cannot  find  symbol  solveCols	17	None	replace
77	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solveCols;    ++j)    {    sum    +=    solvedCols[j][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
78	[BUG]  [BUGGY]  if(solveCols  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solveCols  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solveCols  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solveCols;    ++j)    {    sum    +=    solvedCols[j][pj]    *    qy[j];    }    	non-compiled	[CE]  illegal  start  of  expression	22	None	replace
79	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[i];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solveCols;    ++j)    {    sum    +=    solvedCols[j][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
80	[BUG]  [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }  [CE]  cannot  find  symbol  bucket  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  bucket  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	bucket  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solveCols;    ++j)    {    sum    +=    solvedCols[j][pj]    *    qy[j];    }    	non-compiled	[CE]  cannot  find  symbol  bucket	22	None	replace
81	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  -=  Math.sqrt(sum);	  sum2    +=    Math.sqrt(sum);    	compilable	  [FE]  AssertionFailedError  	27	4	replace
82	[BUG]  [BUGGY]  sum  -=  Math.sqrt(sum);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  -=  Math.sqrt(sum);	  sum2    +=    Math.sqrt(sum);    	compilable	  [FE]  AssertionFailedError  	27	4	replace
83	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  /=  Math.sqrt(sum);	  sum2    +=    Math.sqrt(sum);    	compilable	  [FE]  AssertionFailedError  	27	4	replace
84	[BUG]  [BUGGY]  sum  /=  Math.sqrt(sum);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  /=  Math.sqrt(sum);	  sum2    +=    Math.sqrt(sum);    	compilable	  [FE]  AssertionFailedError  	27	4	replace
85	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  +=  Math.sqrt(sum);	  sum2    +=    Math.sqrt(sum);    	compilable	  [FE]  AssertionFailedError  	27	4	replace
86	[BUG]  [BUGGY]  sum  +=  Math.sqrt(sum);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  Math.sqrt(sum);	  sum2    +=    Math.sqrt(sum);    	compilable	  [FE]  AssertionFailedError  	27	4	replace
87	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  sum;  sum  /=  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum    /=    sum;    sum  /=  sum;	  	compilable	  [FE]  AssertionFailedError  	3	4	add
88	[BUG]  [BUGGY]  sum  /=  sum;  sum  /=  sum;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  sum;  sum  /=  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    /=    sum;    sum  /=  sum;	  	compilable	  [FE]  AssertionFailedError  	3	4	add
89	[BUG]  [BUGGY]  sum  /=  sum;  Sum  /=  sum;  [CE]  cannot  find  symbol  Sum  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  sum;  Sum  /=  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    /=    sum;    Sum  /=  sum;	  	non-compiled	[CE]  cannot  find  symbol  Sum	3	None	add
90	[BUG]  [BUGGY]  sum  /=  sum;  sum  /=  Sum;  [CE]  cannot  find  symbol  Sum  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  sum;  sum  /=  Sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    /=    sum;    sum  /=  Sum;	  	non-compiled	[CE]  cannot  find  symbol  Sum	3	None	add
91	[BUG]  [BUGGY]  sum  /=  sum;  double  /=  sum;  [CE]  unexpected  type  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  sum;  double  /=  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    /=    sum;    double  /=  sum;	  	non-compiled	[CE]  unexpected  type	3	None	add
92	[BUG]  [BUGGY]  sum  /=  sum;  total  /=  sum;  [CE]  cannot  find  symbol  total  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  sum;  total  /=  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    /=    sum;    total  /=  sum;	  	non-compiled	[CE]  cannot  find  symbol  total	3	None	add
93	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[i][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[i][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[i][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[i][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	23	None	replace
94	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solveable[i][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solveable[i][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solveable[i][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[i][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	23	None	replace
95	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solved[i][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solved[i][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solved[i][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[i][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	23	None	replace
96	[BUG]  [BUGGY]  sum  /=  solveCols;  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  solveCols;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  /=  solveCols;	  sum    /=    sum;    	non-compiled	[CE]  cannot  find  symbol  solveCols	4	None	replace
97	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  solvedCols;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  /=  solvedCols;	  sum    /=    sum;    	compilable	  [FE]  AssertionFailedError  	4	4	replace
98	[BUG]  [BUGGY]  sum  /=  solvedCols;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  solvedCols;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  /=  solvedCols;	  sum    /=    sum;    	compilable	  [FE]  AssertionFailedError  	4	4	replace
99	[BUG]  [BUGGY]  sum  /=  solvingCols;  [CE]  cannot  find  symbol  solvingCols  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  solvingCols;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  /=  solvingCols;	  sum    /=    sum;    	non-compiled	[CE]  cannot  find  symbol  solvingCols	4	None	replace
100	[BUG]  [BUGGY]  solveCols  =  sum  /  Math.max(solvedCols,  sum);  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  solveCols  =  sum  /  Math.max(solvedCols,  sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	solveCols  =  sum  /  Math.max(solvedCols,  sum);	      	non-compiled	[CE]  cannot  find  symbol  solveCols	9	None	replace
101	[BUG]  [BUGGY]  solveCols  =  sum  /  Math.min(solvedCols,  sum);  [CE]  cannot  find  symbol  solveCols  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  solveCols  =  sum  /  Math.min(solvedCols,  sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	solveCols  =  sum  /  Math.min(solvedCols,  sum);	      	non-compiled	[CE]  cannot  find  symbol  solveCols	9	None	replace
102	[BUG]  [BUGGY]  solveCols  =  sum  /  Math.min(solvedCols,  sum  +  1);  [CE]  cannot  find  symbol  solveCols  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  solveCols  =  sum  /  Math.min(solvedCols,  sum  +  1);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	solveCols  =  sum  /  Math.min(solvedCols,  sum  +  1);	      	non-compiled	[CE]  cannot  find  symbol  solveCols	9	None	replace
103	[BUG]  [BUGGY]  solveCols  =  sum  /  Math.max(solvedCols,  sum);  return;  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  solveCols  =  sum  /  Math.max(solvedCols,  sum);  return;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	solveCols  =  sum  /  Math.max(solvedCols,  sum);  return;	      	non-compiled	[CE]  cannot  find  symbol  solveCols	9	None	replace
104	[BUG]  [BUGGY]  sum  +=  solvedCols[j][pj]  *  qy[i];  [CE]  array  required,  but  int  found  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solvedCols[j][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solvedCols[j][pj]  *  qy[i];	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  array  required,  but  int  found	10	None	replace
105	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  diag[i];  }  [CE]  cannot  find  symbol  i  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  diag[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  diag[i];  }	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  i	10	None	replace
106	[BUG]  [BUGGY]      solveCols  =  sum  /  Math.max(solvedCols,  sum  +  1);  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]      solveCols  =  sum  /  Math.max(solvedCols,  sum  +  1);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	        solveCols  =  sum  /  Math.max(solvedCols,  sum  +  1);	  	non-compiled	[CE]  cannot  find  symbol  solveCols	8	None	add
107	[BUG]  [BUGGY]  SumMethod  solvedCols[i][pj]  *  qy[i];  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  SumMethod  solvedCols[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	SumMethod  solvedCols[i][pj]  *  qy[i];	      if(solvedCols!=    null)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  ']'  expected	12	None	replace
108	[BUG]  [BUGGY]  sum2  +=  Math.sqrt(sum);  total2  +=  Math.sqrt(sum);  [CE]  cannot  find  symbol  total2  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  Math.sqrt(sum);  total2  +=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    Math.sqrt(sum);    total2  +=  Math.sqrt(sum);	  	non-compiled	[CE]  cannot  find  symbol  total2	26	None	add
109	[BUG]  [BUGGY]  if(j  >  0)  {  sum  =  Math.sqrt(sum);  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(j  >  0)  {  sum  =  Math.sqrt(sum);  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(j  >  0)  {  sum  =  Math.sqrt(sum);  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	19	None	replace
110	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  =  Math.sqrt(sum,  solveCols[i][pj]  *  qy[i];  }  [CE]  ')'  expected  [FE]                  AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(sum  >  0)  {  sum  =  Math.sqrt(sum,  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(sum  >  0)  {  sum  =  Math.sqrt(sum,  solveCols[i][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  ')'  expected	19	None	replace
111	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  diag[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  diag[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solvedCols  >  0)  {  sum  +=  solvedCols[i][pj]  *  diag[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    	non-compiled	[CE]  illegal  start  of  expression	14	None	replace
112	[BUG]  [BUGGY]  sum2  +=  Math.sqrt(sum  *  qy);  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  Math.sqrt(sum  *  qy);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  Math.sqrt(sum  *  qy);	  sum2    +=    sum    *    qy;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	5	None	replace
113	[BUG]  [BUGGY]  sum2  +=  solveCols  *  qy;  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  solveCols  *  qy;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  solveCols  *  qy;	  sum2    +=    sum    *    qy;    	non-compiled	[CE]  cannot  find  symbol  solveCols	5	None	replace
114	[BUG]  [BUGGY]  sum2  +=  Math.sqrt(sum  /  qy);  [CE]  bad  operand  types  for  binary  operator  '/'  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  Math.sqrt(sum  /  qy);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  Math.sqrt(sum  /  qy);	  sum2    +=    sum    *    qy;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '/'	5	None	replace
115	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	      	non-compiled	[CE]  cannot  find  symbol  solveCols	9	None	replace
116	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	      	non-compiled	[CE]  cannot  find  symbol  solveCols	9	None	replace
117	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }	      	non-compiled	[CE]  cannot  find  symbol  solveCols	9	None	replace
118	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }	      	non-compiled	[CE]  cannot  find  symbol  solveCols	9	None	replace
119	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	13	None	replace
120	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  q  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  q  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(j  >  0)  {  sum  +=  solvedCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  permutation[i][pj]  *  q	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    permutation[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	13	None	replace
121	[BUG]  [BUGGY]  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  permutation[j]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    permutation[j]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	24	None	replace
122	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solvedCols  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    i;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	17	None	replace
123	[BUG]  [BUGGY]  if(solves  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solves  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solves  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    i;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	17	None	replace
124	[BUG]  [BUGGY]  sum  +=  solveCols[i][pj]  *  diag[i];  [CE]  cannot  find  symbol  solveCols  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solveCols[i][pj]  *  diag[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solveCols[i][pj]  *  diag[i];	      sum    +=    solveCols[i][pj]    *    qy[i];    	non-compiled	[CE]  cannot  find  symbol  solveCols	15	None	replace
125	[BUG]  [BUGGY]  sum  -=  sum  *  sum;  sum  -=  sum  *  Sum;  [CE]  cannot  find  symbol  Sum  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  sum  -=  sum  *  Sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    -=    sum    *    sum;    sum  -=  sum  *  Sum;	  	non-compiled	[CE]  cannot  find  symbol  Sum	6	None	add
126	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  -=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum2  -=  Math.sqrt(sum);	  sum2    +=    Math.sqrt(sum);    	compilable	  [FE]  AssertionFailedError  	27	15	replace
127	[BUG]  [BUGGY]  sum2  -=  Math.sqrt(sum);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  -=  Math.sqrt(sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  -=  Math.sqrt(sum);	  sum2    +=    Math.sqrt(sum);    	compilable	  [FE]  AssertionFailedError  	27	15	replace
128	[BUG]  [BUGGY]      for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]      for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	        for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solveCols[i][j]  *  qy[i];  }	  	non-compiled	[CE]  cannot  find  symbol  solveCols	8	None	add
129	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  work3[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  work3[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  work3[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	16	None	replace
130	[BUG]  [BUGGY]  sum  -=  solveCols[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  solveCols  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  solveCols[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  -=  solveCols[i][pj]  *  qy[i];	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	16	None	replace
131	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  work2[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  work2[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  work2[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	16	None	replace
132	[BUG]  [BUGGY]  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvedCols[j][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solveCols;    ++j)    {    sum    +=    solvedCols[j][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
133	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solveCols[j][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solveCols[j][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solveCols[j][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solveCols;    ++j)    {    sum    +=    solvedCols[j][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
134	[BUG]  [BUGGY]  sum2  -=  qy  *  sum;  [CE]  bad  operand  types  for  binary  operator  '*'  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  -=  qy  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  -=  qy  *  sum;	  sum2    +=    qy    *    sum;    	non-compiled	[CE]  bad  operand  types  for  binary  operator  '*'	20	None	replace
135	[BUG]  [BUGGY]  sum2  +=  solveCols  /  sum;  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  solveCols  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  solveCols  /  sum;	  sum2    +=    sum    /    sum;    	non-compiled	[CE]  cannot  find  symbol  solveCols	2	None	replace
136	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  solvedCols  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum2  +=  solvedCols  /  sum;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	14	replace
137	[BUG]  [BUGGY]  sum2  +=  solvedCols  /  sum;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  solvedCols  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  solvedCols  /  sum;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	14	replace
138	[BUG]  [BUGGY]  sum2  +=  sum  /  solveCols;  [CE]  cannot  find  symbol  solveCols  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  solveCols;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  sum  /  solveCols;	  sum2    +=    sum    /    sum;    	non-compiled	[CE]  cannot  find  symbol  solveCols	2	None	replace
139	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solvedCols;  ++i)  {  sum  +=  solved[i][pj]  *  qy[i];  }	      	non-compiled	[CE]  illegal  start  of  expression	9	None	replace
140	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  i  =  0;  i  <  solveCols;  ++i)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	      	non-compiled	[CE]  illegal  start  of  expression	9	None	replace
141	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[j][j]  *  qy[j];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[j][j]  *  qy[j];  }  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[j][j]  *  qy[j];  }	      	non-compiled	[CE]  illegal  start  of  expression	9	None	replace
142	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  sum;  sum2  -=  sum  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum2    +=    sum    /    sum;    sum2  -=  sum  /  sum;	  	compilable	  [FE]  AssertionFailedError  	1	3	add
143	[BUG]  [BUGGY]  sum2  +=  sum  /  sum;  sum2  -=  sum  /  sum;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  sum  /  sum;  sum2  -=  sum  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2    +=    sum    /    sum;    sum2  -=  sum  /  sum;	  	compilable	  [FE]  AssertionFailedError  	1	3	add
144	[BUG]  [BUGGY]      if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[i][j]  *  qy[j];  }  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]      if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[i][j]  *  qy[j];  }  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	        if(sum  >  0)  {  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  solved[i][j]  *  qy[j];  }	  	non-compiled	[CE]  illegal  start  of  expression	8	None	add
145	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  Math.sqrt(sum);  sum  -=  sum  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum    -=    sum    *    sum;    Math.sqrt(sum);  sum  -=  sum  *  sum;	  	compilable	  [FE]  AssertionFailedError  	6	3	add
146	[BUG]  [BUGGY]  sum  -=  sum  *  sum;  Math.sqrt(sum);  sum  -=  sum  *  sum;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  Math.sqrt(sum);  sum  -=  sum  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    -=    sum    *    sum;    Math.sqrt(sum);  sum  -=  sum  *  sum;	  	compilable	  [FE]  AssertionFailedError  	6	3	add
147	[BUG]  [BUGGY]  sum  -=  sum  *  sum;  Math.sqrt(sum  -=  sum  *  sum;  [CE]  ')'  expected  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  Math.sqrt(sum  -=  sum  *  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    -=    sum    *    sum;    Math.sqrt(sum  -=  sum  *  sum;	  	non-compiled	[CE]  ')'  expected	6	None	add
148	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  Math.sqrt(sum  -=  sum  *  sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum    -=    sum    *    sum;    Math.sqrt(sum  -=  sum  *  sum);	  	compilable	  [FE]  AssertionFailedError  	6	3	add
149	[BUG]  [BUGGY]  sum  -=  sum  *  sum;  Math.sqrt(sum  -=  sum  *  sum);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  -=  sum  *  sum;  Math.sqrt(sum  -=  sum  *  sum);  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum    -=    sum    *    sum;    Math.sqrt(sum  -=  sum  *  sum);	  	compilable	  [FE]  AssertionFailedError  	6	3	add
150	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[j][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	21	None	replace
151	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvingCols[j][pj]  *  qy[j];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvingCols[j][pj]  *  qy[j];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solveCols;  ++j)  {  sum  +=  solvingCols[j][pj]  *  qy[j];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solveCols;    ++j)    {    sum    +=    solvedCols[j][pj]    *    qy[j];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	22	None	replace
152	[BUG]  [BUGGY]  sum  +=  solveCols[j][pj]  *  qy[j];  [CE]  cannot  find  symbol  solveCols  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solveCols[j][pj]  *  qy[j];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solveCols[j][pj]  *  qy[j];	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solveCols;    ++j)    {    sum    +=    solvedCols[j][pj]    *    qy[j];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	22	None	replace
153	[BUG]  [BUGGY]  sum2  +=  jacobian[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  i  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  jacobian[i][pj]  *  qy[i];  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  jacobian[i][pj]  *  qy[i];	  sum2    +=    sum    *    qy;    	non-compiled	[CE]  cannot  find  symbol  i	5	None	replace
154	[BUG]  [BUGGY]  sum2  +=  jacobian[i][pj]  *  qy;  [CE]  cannot  find  symbol  i  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum2  +=  jacobian[i][pj]  *  qy;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum2  +=  jacobian[i][pj]  *  qy;	  sum2    +=    sum    *    qy;    	non-compiled	[CE]  cannot  find  symbol  i	5	None	replace
155	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  diag[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]          AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  diag[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  diag[i];  }  else  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	16	None	replace
156	[BUG]  [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  =  Math.sqrt(sum);  for(int  j  =  0;  j  <  solvedCols;  ++j)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    for(int    j    =    0;    j    <    solvedCols;    ++j)    {    sum    +=    solved[j][pj]    *    qy[i];    }    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	25	None	replace
157	[BUG]  [BUGGY]  sum  +=  solvedcols[i][pj]  *  qy[i];  [CE]  cannot  find  symbol  solvedcols  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solvedcols[i][pj]  *  qy[i];  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solvedcols[i][pj]  *  qy[i];	      if(solvedCols!=    null)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solvedcols	12	None	replace
158	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    i;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	17	None	replace
159	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  q  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  q  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(j  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  i;  ++i)  {  sum  +=  solveCols[i][pj]  *  q	      if(sum    >    0)    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    i;    ++i)    {    sum    +=    solveCols[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	17	None	replace
160	[BUG]  [BUGGY]  sum  +=  solveCols  /  sum;  [CE]  cannot  find  symbol  solveCols  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solveCols  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solveCols  /  sum;	  sum2    +=    sum    /    sum;    	non-compiled	[CE]  cannot  find  symbol  solveCols	2	None	replace
161	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solvedCols  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  +=  solvedCols  /  sum;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	4	replace
162	[BUG]  [BUGGY]  sum  +=  solvedCols  /  sum;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  +=  solvedCols  /  sum;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  +=  solvedCols  /  sum;	  sum2    +=    sum    /    sum;    	compilable	  [FE]  AssertionFailedError  	2	4	replace
163	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  2;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	add	sum  /=  2;	  sum    /=    sum;    	compilable	  [FE]  AssertionFailedError  	4	4	replace
164	[BUG]  [BUGGY]  sum  /=  2;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  sum  /=  2;  [BUGGY]    }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	sum  /=  2;	  sum    /=    sum;    	compilable	  [FE]  AssertionFailedError  	4	4	replace
165	[BUG]  [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[j][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(solvedCols  >  0)  {  sum  +=  solvedCols[j][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(solvedCols  >  0)  {  sum  +=  solvedCols[j][pj]  *  qy[i];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *	      if(solvedCols    >    0)    {    sum    +=    solvedCols[i][pj]    *    qy[i];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    	non-compiled	[CE]  illegal  start  of  expression	14	None	replace
166	[BUG]  [BUGGY]  if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError    [CONTEXT]      sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];    [BUGGY]  if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }  [BUGGY]    sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	557	557	2	replace	if(sum  >  0)  {  sum  +=  solveCols[i][pj]  *  qy[i];  }	      if(sum    >    0)    {    sum    =    Math.sqrt(sum);    }    else    {    sum    +=    solveCols[i][pj]    *    qy[i];    }    	non-compiled	[CE]  cannot  find  symbol  solveCols	19	None	replace
