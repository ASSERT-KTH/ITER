bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  if(lmPar  ==  null)  {  [CE]  incomparable  types:  double  and  <null>  [FE]    AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(lmPar  ==  null)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null)  {	if  (lmPar  ==  0)  {  	non-compiled	[CE]  incomparable  types:  double  and  <null>	75	None	replace
2	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(lmPar  ==  0.0)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  ==  0.0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	75	2	replace
3	[BUG]  [BUGGY]  if(lmPar  ==  0.0)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(lmPar  ==  0.0)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  0.0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	75	2	replace
4	[BUG]  [BUGGY]    [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	  	if  (lmPar  ==  0)  {  	non-compiled	[CE]  class,  interface,  or  enum  expected	75	None	replace
5	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	76	15	add
6	[BUG]  [BUGGY]    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	76	15	add
7	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	    double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	76	15	add
8	[BUG]  [BUGGY]    double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	    double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	76	15	add
9	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	76	15	add
10	[BUG]  [BUGGY]    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	76	15	add
11	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));		compilable	  [FE]  AssertionFailedError  	76	2	add
12	[BUG]  [BUGGY]    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]          AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));		compilable	  [FE]  AssertionFailedError  	76	2	add
13	[BUG]  [BUGGY]    int  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  possible  loss  of  precision  [FE]    AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    int  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	    int  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));		non-compiled	[CE]  possible  loss  of  precision	76	None	add
14	[BUG]  [BUGGY]  if(paru  ==  null)  {  [CE]  incomparable  types:  double  and  <null>  [FE]    AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(paru  ==  null)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  null)  {	if  (lmPar  ==  0)  {  	non-compiled	[CE]  incomparable  types:  double  and  <null>	75	None	replace
15	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(paru  ==  0.0)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  ==  0.0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	75	2	replace
16	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(paru  ==  0.0)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	75	2	replace
17	[BUG]  [BUGGY]  if(paru!=  null)  {  [CE]  incomparable  types:  double  and  <null>  [FE]        AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(paru!=  null)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru!=  null)  {	if  (lmPar  ==  0)  {  	non-compiled	[CE]  incomparable  types:  double  and  <null>	75	None	replace
18	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(paru  >  255)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  >  255)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	75	2	replace
19	[BUG]  [BUGGY]  if(paru  >  255)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(paru  >  255)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  255)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	75	2	replace
20	[BUG]  [BUGGY]  if(lmPar!=  null)  {  [CE]  incomparable  types:  double  and  <null>  [FE]      AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(lmPar!=  null)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=  null)  {	if  (lmPar  ==  0)  {  	non-compiled	[CE]  incomparable  types:  double  and  <null>	75	None	replace
21	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(lmPar  ==  paru)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  ==  paru)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	75	3	replace
22	[BUG]  [BUGGY]  if(lmPar  ==  paru)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]  if(lmPar  ==  paru)  {  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  paru)  {	if  (lmPar  ==  0)  {  	compilable	  [FE]  AssertionFailedError  	75	3	replace
23	[BUG]  [BUGGY]    int  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  possible  loss  of  precision  [FE]    AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    int  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	    int  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);		non-compiled	[CE]  possible  loss  of  precision	76	None	add
24	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	76	15	add
25	[BUG]  [BUGGY]    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError  [CONTEXT]    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {    [BUGGY]    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]  if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);		compilable	  [FE]  AssertionFailedError  	76	15	add
