bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  >=  0.0)  {	  if(lmPar    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	3	12	replace
2	[BUG]  [BUGGY]  if(lmPar  >=  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  >=  0.0)  {	  if(lmPar    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	3	12	replace
3	[BUG]  [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar!=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=    0.0)    {    if(lmPar!=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	4	None	add
4	[BUG]  [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=    0.0)    {    if(lmPar  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	4	None	add
5	[BUG]  [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  >>  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  >>  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=    0.0)    {    if(lmPar  >>  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	4	None	add
6	[BUG]  [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  0.0)  {  if(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=    0.0)    {    if(lmPar  ==  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	4	None	add
7	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	15	add
8	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	15	add
9	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	15	add
10	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	15	add
11	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,.001    *    paru);    LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	12	None	add
12	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,.001    *    paru);    lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	15	add
13	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,.001    *    paru);    lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	15	add
14	[BUG]  [BUGGY]  if(solvedCols  ==  null  ||  solvedCols.length  ==  0)  {  [CE]  incomparable  types:  int  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols  ==  null  ||  solvedCols.length  ==  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols  ==  null  ||  solvedCols.length  ==  0)  {	  if(solvedCols    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	95	None	replace
15	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  251)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  >  251)  {	  if(paru    >    255)    {    if(parau    >    255)    {    	compilable	  [FE]  AssertionFailedError  	45	2	replace
16	[BUG]  [BUGGY]  if(paru  >  251)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  251)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  251)  {	  if(paru    >    255)    {    if(parau    >    255)    {    	compilable	  [FE]  AssertionFailedError  	45	2	replace
17	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	70	15	add
18	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	70	15	add
19	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	70	15	add
20	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	70	15	add
21	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	non-compiled	[CE]  cannot  find  symbol	70	None	add
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	70	15	add
23	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	70	15	add
24	[BUG]  [BUGGY]  if(lmPar!=  null)  {  If(paru  >  255)  {  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  null)  {  If(paru  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=  null)  {  If(paru  >  255)  {	  if(paru    >    255)    {    If(paru    >    255)    {    	non-compiled	[CE]  ';'  expected	44	None	replace
25	[BUG]  [BUGGY]  if(lmPar  ==  null)  {  If(paru  >  255)  {  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null)  {  If(paru  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null)  {  If(paru  >  255)  {	  if(paru    >    255)    {    If(paru    >    255)    {    	non-compiled	[CE]  ';'  expected	44	None	replace
26	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-408,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-408,  0.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-408,    0.001    *    paru);    	non-compiled	[CE]  floating  point  number  too  small	85	None	replace
27	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2251e-408,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2251e-408,  0.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-408,    0.001    *    paru);    	non-compiled	[CE]  floating  point  number  too  small	85	None	replace
28	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.251e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.251e-408,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.251e-408,  0.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-408,    0.001    *    paru);    	non-compiled	[CE]  floating  point  number  too  small	85	None	replace
29	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.3251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.3251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.3251e-308,  0.001  *  paru));	  paru    =    Math.min(paru,    Math.max(2.3e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	122	None	replace
30	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  paru    =    Math.min(paru,    Math.max(2.3e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	122	None	replace
31	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  parl)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  ==  parl)  {	  if(paru    ==    lmPar)    {    	compilable	  [FE]  AssertionFailedError  	39	2	replace
32	[BUG]  [BUGGY]  if(paru  ==  parl)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  parl)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  parl)  {	  if(paru    ==    lmPar)    {    	compilable	  [FE]  AssertionFailedError  	39	2	replace
33	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  <  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  <  lmPar)  {	  if(paru    ==    lmPar)    {    	compilable	  [FE]  AssertionFailedError  	39	2	replace
34	[BUG]  [BUGGY]  if(paru  <  lmPar)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  <  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  <  lmPar)  {	  if(paru    ==    lmPar)    {    	compilable	  [FE]  AssertionFailedError  	39	2	replace
35	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	25	15	add
36	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	25	15	add
37	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	25	None	add
38	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	25	None	add
39	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	25	15	add
40	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	25	15	add
41	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    LmPar    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	11	None	replace
42	[BUG]  [BUGGY]  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    LmPar    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	11	None	replace
43	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  gNorm)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  ==  gNorm)  {	  if(lmPar    ==    paru)    {    if(lmPar    ==    paru)    {    	compilable	  [FE]  AssertionFailedError  	34	2	replace
44	[BUG]  [BUGGY]  if(lmPar  ==  gNorm)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  gNorm)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  gNorm)  {	  if(lmPar    ==    paru)    {    if(lmPar    ==    paru)    {    	compilable	  [FE]  AssertionFailedError  	34	2	replace
45	[BUG]  [BUGGY]  if(lmPar  ==  parl)  {  if(lmPar  ==  parl)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  parl)  {  if(lmPar  ==  parl)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    ==    parl)    {    if(lmPar  ==  parl)  {	  	non-compiled	[CE]  illegal  start  of  expression	41	None	add
46	[BUG]  [BUGGY]  if(lmPar  ==  parl)  {  if(lmPar!=  parl)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  parl)  {  if(lmPar!=  parl)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    ==    parl)    {    if(lmPar!=  parl)  {	  	non-compiled	[CE]  illegal  start  of  expression	41	None	add
47	[BUG]  [BUGGY]  if(lmPar  ==  parl)  {  if(lmPar  >=  parl)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  parl)  {  if(lmPar  >=  parl)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    ==    parl)    {    if(lmPar  >=  parl)  {	  	non-compiled	[CE]  illegal  start  of  expression	41	None	add
48	[BUG]  [BUGGY]  if(lmPar  ==  parl)  {  If(lmPar  ==  parl)  {  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  parl)  {  If(lmPar  ==  parl)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    ==    parl)    {    If(lmPar  ==  parl)  {	  	non-compiled	[CE]  ';'  expected	41	None	add
49	[BUG]  [BUGGY]  if(paru  >  257)  {  if(paru  >  257)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  257)  {  if(paru  >  257)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >    257)    {    if(paru  >  257)  {	  	non-compiled	[CE]  illegal  start  of  expression	55	None	add
50	[BUG]  [BUGGY]  if(paru  >  257)  {  If(paru  >  257)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  257)  {  If(paru  >  257)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >    257)    {    If(paru  >  257)  {	  	non-compiled	[CE]  ';'  expected	55	None	add
51	[BUG]  [BUGGY]  if(paru  >  257)  {  if(parau  >  257)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  257)  {  if(parau  >  257)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >    257)    {    if(parau  >  257)  {	  	non-compiled	[CE]  illegal  start  of  expression	55	None	add
52	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru!=  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru!=  lmPar)  {	  if(lmPar!=    paru)    {    	compilable	  [FE]  AssertionFailedError  	102	9	replace
53	[BUG]  [BUGGY]  if(paru!=  lmPar)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru!=  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru!=  lmPar)  {	  if(lmPar!=    paru)    {    	compilable	  [FE]  AssertionFailedError  	102	9	replace
54	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001)*  paru);  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001)*  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.max(2.2251e-308,  0.001)*  paru);	  if(lmPar    ==    0.0)    {    lmPar    =    Math.max(2.2251e-308,    0.001)    *    paru);    	non-compiled	[CE]  ';'  expected	100	None	replace
55	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001)/  paru);  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001)/  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.max(2.2251e-308,  0.001)/  paru);	  if(lmPar    ==    0.0)    {    lmPar    =    Math.max(2.2251e-308,    0.001)    *    paru);    	non-compiled	[CE]  ';'  expected	100	None	replace
56	[BUG]  [BUGGY]  lmPar  =  Math.max(2.251e-308,  0.001)*  paru);  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.max(2.251e-308,  0.001)*  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.max(2.251e-308,  0.001)*  paru);	  if(lmPar    ==    0.0)    {    lmPar    =    Math.max(2.2251e-308,    0.001)    *    paru);    	non-compiled	[CE]  ';'  expected	100	None	replace
57	[BUG]  [BUGGY]  if(paramPar  ==  null  ||  paru.length  <  2)  {  [CE]  cannot  find  symbol  paramPar  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paramPar  ==  null  ||  paru.length  <  2)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paramPar  ==  null  ||  paru.length  <  2)  {	  if(lmPar    ==    null    ||    paru.length    <    2)    {    	non-compiled	[CE]  cannot  find  symbol  paramPar	108	None	replace
58	[BUG]  [BUGGY]  if(lmPar  ==  null  ||  paru.length  <  2  ||  paru.length  >  2)  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null  ||  paru.length  <  2  ||  paru.length  >  2)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null  ||  paru.length  <  2  ||  paru.length  >  2)  {	  if(lmPar    ==    null    ||    paru.length    <    2)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	108	None	replace
59	[BUG]  [BUGGY]  if(lmPar  <  0.0)  {  if(lmPar  <  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  0.0)  {  if(lmPar  <  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    <    0.0)    {    if(lmPar  <  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
60	[BUG]  [BUGGY]  if(lmPar  <  0.0)  {  If(lmPar  <  0.0)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  0.0)  {  If(lmPar  <  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    <    0.0)    {    If(lmPar  <  0.0)  {	  	non-compiled	[CE]  ';'  expected	2	None	add
61	[BUG]  [BUGGY]  if(lmPar  <  0.0)  {  if(lmPar  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  0.0)  {  if(lmPar  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    <    0.0)    {    if(lmPar  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
62	[BUG]  [BUGGY]  if(lmPar  <  0.0)  {  if(lmPar  <  0.001)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  0.0)  {  if(lmPar  <  0.001)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    <    0.0)    {    if(lmPar  <  0.001)  {	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
63	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2252e-308,.001  *  paru);	          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar    =    Math.min(2.2252e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	29	None	replace
64	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	75	None	replace
65	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  ')'  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru);	  lmPar    =    Math.min(paru,    Math.max(2e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	114	None	replace
66	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.3251e-308,  0.001  *  paru);  [CE]  ')'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.3251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.3251e-308,  0.001  *  paru);	  lmPar    =    Math.min(paru,    Math.max(2e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	114	None	replace
67	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(paru  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >    0.0)    {    if(paru  >  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	104	None	add
68	[BUG]  [BUGGY]  if(paru  >  0.0)  {  If(paru  >  0.0)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  If(paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >    0.0)    {    If(paru  >  0.0)  {	  	non-compiled	[CE]  ';'  expected	104	None	add
69	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(parau  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(parau  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >    0.0)    {    if(parau  >  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	104	None	add
70	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(paru  >  0.001)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(paru  >  0.001)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >    0.0)    {    if(paru  >  0.001)  {	  	non-compiled	[CE]  illegal  start  of  expression	104	None	add
71	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >=  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >=    0.0)    {    if(paru  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	23	None	add
72	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  if(paru!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >=  0.0)  {  if(paru!=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >=    0.0)    {    if(paru!=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	23	None	add
73	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  if(paru  >>  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >=  0.0)  {  if(paru  >>  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >=    0.0)    {    if(paru  >>  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	23	None	add
74	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  if(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >=  0.0)  {  if(paru  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >=    0.0)    {    if(paru  ==  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	23	None	add
75	[BUG]  [BUGGY]  if(paru  >  255)  {  int  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  255)  {  int  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  255)  {  int  paru  =  Math.max(2.2251e-308,  0.001  *  paru);	  if(paru    >    255)    {    int    paru    >    255)    {    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	111	None	replace
76	[BUG]  [BUGGY]  if(paru  >  255)  {  int  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  ')'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  255)  {  int  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  255)  {  int  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru);	  if(paru    >    255)    {    int    paru    >    255)    {    	non-compiled	[CE]  ')'  expected	111	None	replace
77	[BUG]  [BUGGY]  if(paru  >  255)  {  int  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  255)  {  int  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  255)  {  int  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  if(paru    >    255)    {    int    paru    >    255)    {    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	111	None	replace
78	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  >  0.0)  {	  if(paru    >=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	24	12	replace
79	[BUG]  [BUGGY]  if(lmPar  >  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  >  0.0)  {	  if(paru    >=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	24	12	replace
80	[BUG]  [BUGGY]  if(lmPar  ==  null  ||  paru!=  null)  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null  ||  paru!=  null)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null  ||  paru!=  null)  {	  if(lmPar    >=    null)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	16	None	replace
81	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru,  countdown);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru,  countdown);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru,  countdown);	  double    lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	58	None	replace
82	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  double    lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	58	None	replace
83	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru  +  1);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru  +  1);	  double    lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	58	None	replace
84	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	69	None	replace
85	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	69	None	replace
86	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  lmPar));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  lmPar));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    lmPar));    	non-compiled	[CE]  class,  interface,  or  enum  expected	50	None	replace
87	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parl));  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parl));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    lmPar));    	non-compiled	[CE]  class,  interface,  or  enum  expected	50	None	replace
88	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	117	None	replace
89	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	117	None	replace
90	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.22e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.22e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.22e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	117	None	replace
91	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));	  Double    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	20	None	replace
92	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));	  Double    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	20	None	replace
93	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]                      AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  solvedCols  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  solvedCols  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));	  Double    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	20	None	replace
94	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));  [CE]  class,  interface,  or  enum  expected  [FE]                        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));	  Double    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	20	None	replace
95	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parl));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parl));	  double    solvedCols    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	18	None	replace
96	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  lmPar));  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  lmPar));	  double    solvedCols    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	18	None	replace
97	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parm));  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parm));	  double    solvedCols    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	18	None	replace
98	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));	  double    solvedCols    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	18	None	replace
99	[BUG]  [BUGGY]  if(solveCols  ==  null  ||  solveCols  >  0)  {  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols  ==  null  ||  solveCols  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols  ==  null  ||  solveCols  >  0)  {	  if(paru    ==    null    ||    solveCols    >    0)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	119	None	replace
100	[BUG]  [BUGGY]  if(solvedCols  ==  null  ||  solveCols  >  0)  {  [CE]  incomparable  types:  int  and  <null>  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols  ==  null  ||  solveCols  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols  ==  null  ||  solveCols  >  0)  {	  if(paru    ==    null    ||    solveCols    >    0)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	119	None	replace
101	[BUG]  [BUGGY]  if(solveCols  ==  null  ||  solveCols  >  1)  {  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols  ==  null  ||  solveCols  >  1)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols  ==  null  ||  solveCols  >  1)  {	  if(paru    ==    null    ||    solveCols    >    0)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	119	None	replace
102	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(dxNorm  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(dxNorm  ==  0.0)  {	  if(paru    ==    0.0)    {    if(parau    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	123	2	replace
103	[BUG]  [BUGGY]  if(dxNorm  ==  0.0)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(dxNorm  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(dxNorm  ==  0.0)  {	  if(paru    ==    0.0)    {    if(parau    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	123	2	replace
104	[BUG]  [BUGGY]  if(lmPar!=  null  ||  paru  >  0.0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  null  ||  paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=  null  ||  paru  >  0.0)  {	  if(lmPar!=    null    &&    paru    >    0.0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	120	None	replace
105	[BUG]  [BUGGY]  if(lmPar  ==  null  &&  paru  >  0.0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null  &&  paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null  &&  paru  >  0.0)  {	  if(lmPar!=    null    &&    paru    >    0.0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	120	None	replace
106	[BUG]  [BUGGY]  if(lmPar  ==  null  ||  paru  >  0.0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null  ||  paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null  ||  paru  >  0.0)  {	  if(lmPar!=    null    &&    paru    >    0.0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	120	None	replace
107	[BUG]  [BUGGY]  if(param  ==  0.0)  {  [CE]  cannot  find  symbol  param  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(param  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(param  ==  0.0)  {	  if(paru    ==    0.0)    {    if(param    ==    0.0)    {    	non-compiled	[CE]  cannot  find  symbol  param	110	None	replace
108	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(lmPar  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  0.0)  {  if(lmPar  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {  if(lmPar  >=  0.0)  {	  if(lmPar    ==    0.0)    {    if(lmPar    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	48	None	replace
109	[BUG]  [BUGGY]  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	26	None	replace
110	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);	          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	26	None	replace
111	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  parl));  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  parl));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    parl));    	non-compiled	[CE]  class,  interface,  or  enum  expected	91	None	replace
112	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	106	15	add
113	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	106	15	add
114	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	106	15	add
115	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	106	15	add
116	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	106	None	add
117	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	106	15	add
118	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	106	15	add
119	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	79	15	add
120	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	79	15	add
121	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	79	None	add
122	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	79	15	add
123	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	79	15	add
124	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	79	None	add
125	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.0251e-308,  0.001  *  paru);  [CE]  ')'  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.0251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.0251e-308,  0.001  *  paru);	  lmPar    =    Math.min(paru,    Math.max(2.0e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	21	None	replace
126	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	93	15	add
127	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	93	15	add
128	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	93	None	add
129	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	93	15	add
130	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	93	15	add
131	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	93	None	add
132	[BUG]  [BUGGY]  Double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown);	  Double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	60	None	replace
133	[BUG]  [BUGGY]  Double  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  Double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	60	None	replace
134	[BUG]  [BUGGY]  Double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  1);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  1);	  Double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	60	None	replace
135	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  long  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	long  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));	  long    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	19	None	replace
136	[BUG]  [BUGGY]  long  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  long  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	long  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));	  long    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	19	None	replace
137	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.251e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	71	None	replace
138	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        paru    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	30	15	add
139	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        paru    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	30	15	add
140	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        paru    =    Math.min(2.2252e-308,    0.001    *    paru);    LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	30	None	add
141	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        paru    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	30	15	add
142	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        paru    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	30	15	add
143	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  Paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  Paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        paru    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  Paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	30	None	add
144	[BUG]  [BUGGY]  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	73	None	replace
145	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  countdown));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  countdown));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  countdown));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	73	None	replace
146	[BUG]  [BUGGY]  LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    LmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	27	None	replace
147	[BUG]  [BUGGY]  if(param  ==  null  ||  paru.length  <  2)  {  [CE]  cannot  find  symbol  param  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(param  ==  null  ||  paru.length  <  2)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(param  ==  null  ||  paru.length  <  2)  {	  if(paru    ==    null    ||    paru.length    <    2)    {    	non-compiled	[CE]  cannot  find  symbol  param	118	None	replace
148	[BUG]  [BUGGY]  if(paru  ==  null  ||  paru.length  <  2  ||  countdown  >  0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  null  ||  paru.length  <  2  ||  countdown  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  null  ||  paru.length  <  2  ||  countdown  >  0)  {	  if(paru    ==    null    ||    paru.length    <    2)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	118	None	replace
149	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar    =    Math.min(2.251e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	13	None	replace
150	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown);	  lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	32	None	replace
151	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2255e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2255e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2255e-308,  0.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2255e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	121	None	replace
152	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-3,  0.001,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-3,  0.001,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-3,  0.001,  0.001  *  paru);	  double    lmPar    =    Math.min(2.2251e-3,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	87	None	replace
153	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru  +  1);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru  +  1);	  double    lmPar    =    Math.min(2.2251e-3,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	87	None	replace
154	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	68	2	add
155	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	68	2	add
156	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	non-compiled	[CE]  cannot  find  symbol	68	None	add
157	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  cannot  find  symbol  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	non-compiled	[CE]  cannot  find  symbol	68	None	add
158	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	68	15	add
159	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	68	15	add
160	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  Paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  cannot  find  symbol  Paru  [FE]            AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  Paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  Paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	non-compiled	[CE]  cannot  find  symbol  Paru	68	None	add
161	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  If(lmPar  ==  0.0)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  0.0)  {  If(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {  If(lmPar  ==  0.0)  {	  if(lmPar    ==    0.0)    {    If(lmPar    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	49	None	replace
162	[BUG]  [BUGGY]  If(lmPar  ==  0.0)  {  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  If(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	If(lmPar  ==  0.0)  {	  if(lmPar    ==    0.0)    {    If(lmPar    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	49	None	replace
163	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
164	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
165	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
166	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
167	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
168	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
169	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
170	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.250e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
171	[BUG]  [BUGGY]  if(gNorm  ==  null  ||  paru.equals(lmPar))  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(gNorm  ==  null  ||  paru.equals(lmPar))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(gNorm  ==  null  ||  paru.equals(lmPar))  {	  if(lmPar    ==    null    ||    paru.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	128	None	replace
172	[BUG]  [BUGGY]  if(paru  ==  null  ||  paru.equals(gNorm))  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  null  ||  paru.equals(gNorm))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  null  ||  paru.equals(gNorm))  {	  if(lmPar    ==    null    ||    paru.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	128	None	replace
173	[BUG]  [BUGGY]  if(paramPar  ==  null  ||  paru.equals(gNorm))  {  [CE]  cannot  find  symbol  paramPar  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paramPar  ==  null  ||  paru.equals(gNorm))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paramPar  ==  null  ||  paru.equals(gNorm))  {	  if(lmPar    ==    null    ||    paru.equals(gNorm))    {    	non-compiled	[CE]  cannot  find  symbol  paramPar	128	None	replace
174	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));	  double    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	17	None	replace
175	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parm));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parm));	  double    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	17	None	replace
176	[BUG]  [BUGGY]  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(2.2251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	80	None	replace
177	[BUG]  [BUGGY]  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	80	None	replace
178	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  gNorm));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  gNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  gNorm));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    gNorm));    	non-compiled	[CE]  class,  interface,  or  enum  expected	92	None	replace
179	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  dxNorm));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  dxNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  dxNorm));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    gNorm));    	non-compiled	[CE]  class,  interface,  or  enum  expected	92	None	replace
180	[BUG]  [BUGGY]  if(lmPar  <  =  parl)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  =  parl)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  =  parl)  {	  if(lmPar    ==    parl)    {    	non-compiled	[CE]  illegal  start  of  expression	42	None	replace
181	[BUG]  [BUGGY]  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	72	None	replace
182	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  countdown));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  countdown));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  countdown));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	72	None	replace
183	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	77	15	add
184	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	77	15	add
185	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	77	None	add
186	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	77	None	add
187	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	77	15	add
188	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	77	15	add
189	[BUG]  [BUGGY]  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(2.2252e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	31	None	replace
190	[BUG]  [BUGGY]  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	31	None	replace
191	[BUG]  [BUGGY]  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	31	None	replace
192	[BUG]  [BUGGY]  if(lmPar  ==  null  ||  paru.equals(lmPar))  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null  ||  paru.equals(lmPar))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null  ||  paru.equals(lmPar))  {	  if(paru    ==    null    ||    paru.equals(lmPar))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	86	None	replace
193	[BUG]  [BUGGY]  if(lmPar  ==  null  ||  paru.equals(paru))  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null  ||  paru.equals(paru))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null  ||  paru.equals(paru))  {	  if(paru    ==    null    ||    paru.equals(lmPar))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	86	None	replace
194	[BUG]  [BUGGY]  if(paru  ==  null  &&  paru.equals(lmPar))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  null  &&  paru.equals(lmPar))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  null  &&  paru.equals(lmPar))  {	  if(paru    ==    null    ||    paru.equals(lmPar))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	86	None	replace
195	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parl);  [CE]  ')'  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parl);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  parl);	  lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	67	None	replace
196	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  countdown);  [CE]  ')'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  countdown);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  countdown);	  lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	67	None	replace
197	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru);  [CE]  ')'  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru);	  lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	67	None	replace
198	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  countdown));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  countdown));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(lmPar,  countdown));	  lmPar    =    Math.min(paru,    Math.max(lmPar,    gNorm));    	non-compiled	[CE]  class,  interface,  or  enum  expected	89	None	replace
199	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  dxNorm));  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  dxNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(lmPar,  dxNorm));	  lmPar    =    Math.min(paru,    Math.max(lmPar,    gNorm));    	non-compiled	[CE]  class,  interface,  or  enum  expected	89	None	replace
200	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	107	None	replace
201	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(lmPar  ==  0.001)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  0.0)  {  if(lmPar  ==  0.001)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {  if(lmPar  ==  0.001)  {	  if(lmPar    ==    0.0)    {    if(lmPar    ==    0.001)    {    	non-compiled	[CE]  illegal  start  of  expression	115	None	replace
202	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(lmPar  ==  0.0001)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  0.0)  {  if(lmPar  ==  0.0001)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {  if(lmPar  ==  0.0001)  {	  if(lmPar    ==    0.0)    {    if(lmPar    ==    0.001)    {    	non-compiled	[CE]  illegal  start  of  expression	115	None	replace
203	[BUG]  [BUGGY]  if(lmPar  <  =  255)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  =  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  =  255)  {	  if(lmPar    >    255)    {    	non-compiled	[CE]  illegal  start  of  expression	54	None	replace
204	[BUG]  [BUGGY]  if(lmPar  <  2251e-308,  0.001  *  paru)  {  [CE]  ')'  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  2251e-308,  0.001  *  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  2251e-308,  0.001  *  paru)  {	  if(lmPar    >    255)    {    	non-compiled	[CE]  ')'  expected	54	None	replace
205	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  <  255)  {	  if(lmPar    >    255)    {    	compilable	  [FE]  AssertionFailedError  	54	12	replace
206	[BUG]  [BUGGY]  if(lmPar  <  255)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  255)  {	  if(lmPar    >    255)    {    	compilable	  [FE]  AssertionFailedError  	54	12	replace
207	[BUG]  [BUGGY]  float  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  float  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	float  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl));	  float    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	113	None	replace
208	[BUG]  [BUGGY]  float  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  float  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	float  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar));	  float    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	113	None	replace
209	[BUG]  [BUGGY]  float  solvedCols  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  float  solvedCols  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	float  solvedCols  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru));	  float    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	113	None	replace
210	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0,  0.001));  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0,  0.001));  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0,  0.001));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001));    	non-compiled	[CE]  class,  interface,  or  enum  expected	33	None	replace
211	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-countdown,  0.001));  [CE]  malformed  floating  point  literal  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-countdown,  0.001));  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2251e-countdown,  0.001));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001));    	non-compiled	[CE]  malformed  floating  point  literal	33	None	replace
212	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001));  [CE]  class,  interface,  or  enum  expected  [FE]                      AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001));  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001));    	non-compiled	[CE]  class,  interface,  or  enum  expected	33	None	replace
213	[BUG]  [BUGGY]  if(lmPar  >  255)  {  if(lmPar  >  255)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >  255)  {  if(lmPar  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    >    255)    {    if(lmPar  >  255)  {	  	non-compiled	[CE]  illegal  start  of  expression	53	None	add
214	[BUG]  [BUGGY]  if(lmPar  >  255)  {  If(lmPar  >  255)  {  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >  255)  {  If(lmPar  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    >    255)    {    If(lmPar  >  255)  {	  	non-compiled	[CE]  ';'  expected	53	None	add
215	[BUG]  [BUGGY]  if(lmPar  >  255)  {  if(lmPar  >  2505)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >  255)  {  if(lmPar  >  2505)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    >    255)    {    if(lmPar  >  2505)  {	  	non-compiled	[CE]  illegal  start  of  expression	53	None	add
216	[BUG]  [BUGGY]  if(lmPar  >  255)  {  if(lmPar  >  254)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >  255)  {  if(lmPar  >  254)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    >    255)    {    if(lmPar  >  254)  {	  	non-compiled	[CE]  illegal  start  of  expression	53	None	add
217	[BUG]  [BUGGY]  if(solvedCols!=  null  ||  solvedCols.length  ==  0)  {  [CE]  incomparable  types:  int  and  <null>  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols!=  null  ||  solvedCols.length  ==  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols!=  null  ||  solvedCols.length  ==  0)  {	  if(solvedCols!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	109	None	replace
218	[BUG]  [BUGGY]  if(solveCols  ==  null  ||  paru.length()  >  0)  {  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols  ==  null  ||  paru.length()  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols  ==  null  ||  paru.length()  >  0)  {	  if(paru    ==    null    ||    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	96	None	replace
219	[BUG]  [BUGGY]  if(solveCols  ==  null  ||  paru)  {  [CE]  cannot  find  symbol  solveCols  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols  ==  null  ||  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols  ==  null  ||  paru)  {	  if(paru    ==    null    ||    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	96	None	replace
220	[BUG]  [BUGGY]  if(solveCols  ==  null  ||  solveCols)  {  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols  ==  null  ||  solveCols)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols  ==  null  ||  solveCols)  {	  if(paru    ==    null    ||    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	96	None	replace
221	[BUG]  [BUGGY]  if(solveCols  ==  null  ||  paru.length  <  2)  {  [CE]  cannot  find  symbol  solveCols  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols  ==  null  ||  paru.length  <  2)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols  ==  null  ||  paru.length  <  2)  {	  if(paru    ==    null    ||    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	96	None	replace
222	[BUG]  [BUGGY]  if(lmPar!=  paru)  {  if(lmPar!=  paru)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  paru)  {  if(lmPar!=  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=    paru)    {    if(lmPar!=  paru)  {	  	non-compiled	[CE]  illegal  start  of  expression	101	None	add
223	[BUG]  [BUGGY]  if(lmPar!=  paru)  {  if(lmPar  >=  paru)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  paru)  {  if(lmPar  >=  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=    paru)    {    if(lmPar  >=  paru)  {	  	non-compiled	[CE]  illegal  start  of  expression	101	None	add
224	[BUG]  [BUGGY]  if(lmPar!=  paru)  {  if(lmPar  >>  paru)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  paru)  {  if(lmPar  >>  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=    paru)    {    if(lmPar  >>  paru)  {	  	non-compiled	[CE]  illegal  start  of  expression	101	None	add
225	[BUG]  [BUGGY]  if(lmPar!=  paru)  {  if(lmPar  ==  paru)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  paru)  {  if(lmPar  ==  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=    paru)    {    if(lmPar  ==  paru)  {	  	non-compiled	[CE]  illegal  start  of  expression	101	None	add
226	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0251e-308,  0.001  *  paru));	  paru    =    Math.min(paru,    Math.max(2.0e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	90	None	replace
227	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown);	  double    solvedCols    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	98	None	replace
228	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(2.2251e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(2.2251e-308,  0.001  *  paru  +  1);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(2.2251e-308,  0.001  *  paru  +  1);	  double    solvedCols    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	98	None	replace
229	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(2.2251e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                      AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(2.2251e-3,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(2.2251e-3,  0.001  *  paru);	  double    solvedCols    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	98	None	replace
230	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
231	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
232	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    LmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	28	None	add
233	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	28	None	add
234	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
235	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
236	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	116	15	add
237	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	116	15	add
238	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	116	15	add
239	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	116	15	add
240	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	116	15	add
241	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	116	15	add
242	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [CE]  cannot  find  symbol  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	non-compiled	[CE]  cannot  find  symbol	116	None	add
243	[BUG]  [BUGGY]  if(solveCols!=  null  &&  paru.length  >  0)  {  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols!=  null  &&  paru.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols!=  null  &&  paru.length  >  0)  {	  if(paru!=    null    &&    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	126	None	replace
244	[BUG]  [BUGGY]  if(solveCols!=  null  &&  paru.compareTo(solveCols)>  0)  {  [CE]  cannot  find  symbol  solveCols  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols!=  null  &&  paru.compareTo(solveCols)>  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols!=  null  &&  paru.compareTo(solveCols)>  0)  {	  if(paru!=    null    &&    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	126	None	replace
245	[BUG]  [BUGGY]  if(solveCols!=  null  &&  paru)  {  [CE]  cannot  find  symbol  solveCols  [FE]                      AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols!=  null  &&  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols!=  null  &&  paru)  {	  if(paru!=    null    &&    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	126	None	replace
246	[BUG]  [BUGGY]  if(solveCols!=  null  &&  paru.compareTo(solveCols)>  0.0)  {  [CE]  cannot  find  symbol  solveCols  [FE]                        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols!=  null  &&  paru.compareTo(solveCols)>  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols!=  null  &&  paru.compareTo(solveCols)>  0.0)  {	  if(paru!=    null    &&    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	126	None	replace
247	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(gNorm,  parl));	  lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  class,  interface,  or  enum  expected	6	None	replace
248	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru,  countdown);	  double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	97	None	replace
249	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);	  double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	97	None	replace
250	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.2251e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.max(2.2251e-3,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.max(2.2251e-3,  0.001  *  paru);	  double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	97	None	replace
251	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	84	None	replace
252	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2251e-308,.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	84	None	replace
253	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.251e-308,.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	84	None	replace
254	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-3,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-3,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-3,.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	84	None	replace
255	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown  +  1);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown  +  1);	  double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru,    countdown);    	non-compiled	[CE]  class,  interface,  or  enum  expected	62	None	replace
256	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.251e-308,  0.001  *  paru,  countdown);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.251e-308,  0.001  *  paru,  countdown);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.251e-308,  0.001  *  paru,  countdown);	  double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru,    countdown);    	non-compiled	[CE]  class,  interface,  or  enum  expected	62	None	replace
257	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown  -  1);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown  -  1);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown  -  1);	  double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru,    countdown);    	non-compiled	[CE]  class,  interface,  or  enum  expected	62	None	replace
258	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >  257)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  >  257)  {	  if(paru    >    257)    {    	compilable	  [FE]  AssertionFailedError  	56	2	replace
259	[BUG]  [BUGGY]  if(lmPar  >  257)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >  257)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  >  257)  {	  if(paru    >    257)    {    	compilable	  [FE]  AssertionFailedError  	56	2	replace
260	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  countdown));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  countdown));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0,  0.001  *  countdown));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    countdown));    	non-compiled	[CE]  class,  interface,  or  enum  expected	52	None	replace
261	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	15	add
262	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	15	add
263	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	15	add
264	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	15	add
265	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	14	None	add
266	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	15	add
267	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.51e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	15	add
268	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl);  [CE]  ')'  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  parl);	  double    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	61	None	replace
269	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru);  [CE]  ')'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(paru,  Math.max(2.0,  0.001  *  paru);	  double    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	61	None	replace
270	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar);  [CE]  ')'  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  lmPar);	  double    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	61	None	replace
271	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001)/  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001)/  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001)/  paru);	  double    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	61	None	replace
272	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(lmPar!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  0.0)  {  if(lmPar!=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {  if(lmPar!=  0.0)  {	  if(lmPar    ==    0.0)    {    if(lmPar!=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	47	None	replace
273	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(lmPar  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  0.0)  {  if(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {  if(lmPar  ==  0.0)  {	  if(lmPar    ==    0.0)    {    if(lmPar!=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	47	None	replace
274	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  2);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  2);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  2);	  double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  class,  interface,  or  enum  expected	88	None	replace
275	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.251e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.251e-308,  0.001  *  paru  +  1);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.251e-308,  0.001  *  paru  +  1);	  double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  class,  interface,  or  enum  expected	88	None	replace
276	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  3);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  3);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  3);	  double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru    +    1);    	non-compiled	[CE]  class,  interface,  or  enum  expected	88	None	replace
277	[BUG]  [BUGGY]  if(gNorm!=  null  &&  paru.equals(gNorm))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(gNorm!=  null  &&  paru.equals(gNorm))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(gNorm!=  null  &&  paru.equals(gNorm))  {	  if(paru!=    null    &&    paru.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	127	None	replace
278	[BUG]  [BUGGY]  if(gNorm!=  null  &&  paru.equals(paru))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                      AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(gNorm!=  null  &&  paru.equals(paru))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(gNorm!=  null  &&  paru.equals(paru))  {	  if(paru!=    null    &&    paru.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	127	None	replace
279	[BUG]  [BUGGY]  if(param!=  null  &&  paru.equals(gNorm))  {  [CE]  cannot  find  symbol  param  [FE]                        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(param!=  null  &&  paru.equals(gNorm))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(param!=  null  &&  paru.equals(gNorm))  {	  if(paru!=    null    &&    paru.equals(gNorm))    {    	non-compiled	[CE]  cannot  find  symbol  param	127	None	replace
280	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(dxNorm  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(dxNorm  >  255)  {	  if(param    >    255)    {    	compilable	  [FE]  AssertionFailedError  	57	8	replace
281	[BUG]  [BUGGY]  if(dxNorm  >  255)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(dxNorm  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(dxNorm  >  255)  {	  if(param    >    255)    {    	compilable	  [FE]  AssertionFailedError  	57	8	replace
282	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(gNorm  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(gNorm  >  255)  {	  if(param    >    255)    {    	compilable	  [FE]  AssertionFailedError  	57	5	replace
283	[BUG]  [BUGGY]  if(gNorm  >  255)  {  [FE]  AssertionFailedError  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(gNorm  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(gNorm  >  255)  {	  if(param    >    255)    {    	compilable	  [FE]  AssertionFailedError  	57	5	replace
284	[BUG]  [BUGGY]  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.max(2.251e-308,  0.001  *  paru);	  if(lmPar    ==    0.0)    {    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	99	None	replace
285	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.max(2.0,  0.001  *  paru);	  if(lmPar    ==    0.0)    {    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	99	None	replace
286	[BUG]  [BUGGY]  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.251e-308,.001  *  paru);	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar    =    Math.min(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	94	None	replace
287	[BUG]  [BUGGY]  long  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  long  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	long  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown);	  long    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	103	None	replace
288	[BUG]  [BUGGY]  long  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  long  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	long  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  long    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	103	None	replace
289	[BUG]  [BUGGY]  if(paru!=  null  ||  paru.length  >  0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru!=  null  ||  paru.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru!=  null  ||  paru.length  >  0)  {	  if(paru!=    null    &&    paru.length    >    0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	125	None	replace
290	[BUG]  [BUGGY]  if(paru  ==  null  &&  paru.length  >  0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  null  &&  paru.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  null  &&  paru.length  >  0)  {	  if(paru!=    null    &&    paru.length    >    0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	125	None	replace
291	[BUG]  [BUGGY]  if(lmPar!=  null  &&  paru.length  >  0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  null  &&  paru.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=  null  &&  paru.length  >  0)  {	  if(paru!=    null    &&    paru.length    >    0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	125	None	replace
292	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  If(lmPar  ==  paru)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  If(lmPar  ==  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  lmPar)  {  If(lmPar  ==  paru)  {	  if(lmPar    ==    paru)    {    If(lmPar    ==    paru)    {    	non-compiled	[CE]  ';'  expected	37	None	replace
293	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  If(lmPar  ==  null)  {  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  If(lmPar  ==  null)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  lmPar)  {  If(lmPar  ==  null)  {	  if(lmPar    ==    paru)    {    If(lmPar    ==    paru)    {    	non-compiled	[CE]  ';'  expected	37	None	replace
294	[BUG]  [BUGGY]  if(lmPar  ==  0)  {  If(lmPar  ==  0)  {  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  0)  {  If(lmPar  ==  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  0)  {  If(lmPar  ==  0)  {	  if(lmPar    ==    paru)    {    If(lmPar    ==    paru)    {    	non-compiled	[CE]  ';'  expected	37	None	replace
295	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  If(lmPar  ==  gNorm)  {  [CE]  ';'  expected  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  If(lmPar  ==  gNorm)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  lmPar)  {  If(lmPar  ==  gNorm)  {	  if(lmPar    ==    paru)    {    If(lmPar    ==    paru)    {    	non-compiled	[CE]  ';'  expected	37	None	replace
296	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  if(paru  ==  lmPar)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  if(paru  ==  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    ==    lmPar)    {    if(paru  ==  lmPar)  {	  	non-compiled	[CE]  illegal  start  of  expression	38	None	add
297	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  if(paru!=  lmPar)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  if(paru!=  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    ==    lmPar)    {    if(paru!=  lmPar)  {	  	non-compiled	[CE]  illegal  start  of  expression	38	None	add
298	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  if(paru  >=  lmPar)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  if(paru  >=  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    ==    lmPar)    {    if(paru  >=  lmPar)  {	  	non-compiled	[CE]  illegal  start  of  expression	38	None	add
299	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  If(paru  ==  lmPar)  {  [CE]  ';'  expected  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  If(paru  ==  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    ==    lmPar)    {    If(paru  ==  lmPar)  {	  	non-compiled	[CE]  ';'  expected	38	None	add
300	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  <  paru)  {	  if(lmPar    <    =    paru)    {    	compilable	  [FE]  AssertionFailedError  	40	9	replace
301	[BUG]  [BUGGY]  if(lmPar  <  paru)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  paru)  {	  if(lmPar    <    =    paru)    {    	compilable	  [FE]  AssertionFailedError  	40	9	replace
302	[BUG]  [BUGGY]  if(lmPar  <  =  MAXIMUM)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  =  MAXIMUM)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  =  MAXIMUM)  {	  if(lmPar    <    =    paru)    {    	non-compiled	[CE]  illegal  start  of  expression	40	None	replace
303	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	74	15	add
304	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	74	15	add
305	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    LmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	74	None	add
306	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  Paru  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  Paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  Paru	74	None	add
307	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	74	15	add
308	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	74	15	add
309	[BUG]  [BUGGY]  if(paru  <  =  lmPar)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  <  =  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  <  =  lmPar)  {	  if(lmPar    <    =    paru)    {    	non-compiled	[CE]  illegal  start  of  expression	40	None	replace
310	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001));  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001));  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001));    	non-compiled	[CE]  class,  interface,  or  enum  expected	33	None	replace
311	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2255e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2255e-3,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2255e-3,  0.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2255e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	121	None	replace
312	[BUG]  [BUGGY]  if(lmPar  ==  null)  {  If(lmPar  ==  null)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null)  {  If(lmPar  ==  null)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null)  {  If(lmPar  ==  null)  {	  if(lmPar    ==    paru)    {    If(lmPar    ==    paru)    {    	non-compiled	[CE]  ';'  expected	37	None	replace
313	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(paru  ==  0.001)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(paru  ==  0.001)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  if(paru  ==  0.001)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.001)    {    	non-compiled	[CE]  illegal  start  of  expression	124	None	replace
314	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(paru  >=  0.001)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(paru  >=  0.001)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  if(paru  >=  0.001)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.001)    {    	non-compiled	[CE]  illegal  start  of  expression	124	None	replace
315	[BUG]  [BUGGY]  if(paru  <  0.0)  {  if(paru  >  0.001)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  <  0.0)  {  if(paru  >  0.001)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  <  0.0)  {  if(paru  >  0.001)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.001)    {    	non-compiled	[CE]  illegal  start  of  expression	124	None	replace
316	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	82	None	replace
317	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.0,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.0,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.0,  0.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	82	None	replace
318	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  If(paru  ==  0.0)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >=  0.0)  {  If(paru  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >=  0.0)  {  If(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	66	None	replace
319	[BUG]  [BUGGY]  if(paru  >  0.0)  {  If(paru  ==  0.0)  {  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  If(paru  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  If(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	66	None	replace
320	[BUG]  [BUGGY]  if(paru!=  0.0)  {  If(paru  ==  0.0)  {  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru!=  0.0)  {  If(paru  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru!=  0.0)  {  If(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	66	None	replace
321	[BUG]  [BUGGY]  lmPar  =  Math.max(2.0,  0.001)*  paru);  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.max(2.0,  0.001)*  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.max(2.0,  0.001)*  paru);	  if(lmPar    ==    0.0)    {    lmPar    =    Math.max(2.2251e-308,    0.001)    *    paru);    	non-compiled	[CE]  ';'  expected	100	None	replace
322	[BUG]  [BUGGY]  long  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  long  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  1);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	long  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru  +  1);	  long    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	103	None	replace
323	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru));	  paru    =    Math.min(paru,    Math.max(2.3e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	122	None	replace
324	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  parl));  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  parl));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    parl));    	non-compiled	[CE]  class,  interface,  or  enum  expected	91	None	replace
325	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru);  [CE]  ')'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru);	  lmPar    =    Math.min(paru,    Math.max(2.252e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	22	None	replace
326	[BUG]  [BUGGY]  if(paru  ==  null)  {  if(lmPar  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  null)  {  if(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  null)  {  if(lmPar  ==  0.0)  {	  if(lmPar    ==    0.0)    {    if(lmPar    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	48	None	replace
327	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  if(lmPar  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >=  0.0)  {  if(lmPar  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >=  0.0)  {  if(lmPar  >=  0.0)  {	  if(lmPar    ==    0.0)    {    if(lmPar    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	48	None	replace
328	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(lmPar  <  0.0)  {  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  0.0)  {  if(lmPar  <  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {  if(lmPar  <  0.0)  {	  if(lmPar    ==    0.0)    {    if(lmPar    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	48	None	replace
329	[BUG]  [BUGGY]  if(params!=  null  &&  paru.length  >  0)  {  [CE]  cannot  find  symbol  params  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(params!=  null  &&  paru.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(params!=  null  &&  paru.length  >  0)  {	  if(paru!=    null    &&    paru.length    >    0)    {    	non-compiled	[CE]  cannot  find  symbol  params	125	None	replace
330	[BUG]  [BUGGY]  if(paramPar!=  null  &&  paru.length  >  0)  {  [CE]  cannot  find  symbol  paramPar  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paramPar!=  null  &&  paru.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paramPar!=  null  &&  paru.length  >  0)  {	  if(paru!=    null    &&    paru.length    >    0)    {    	non-compiled	[CE]  cannot  find  symbol  paramPar	125	None	replace
331	[BUG]  [BUGGY]  if(param  <  0.0)  {  if(param  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(param  <  0.0)  {  if(param  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(param  <  0.0)  {  if(param  >  0.0)  {	  if(lmPar    ==    0.0)    {    if(lmPar    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	46	None	replace
332	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  cannot  find  symbol  LmPar  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	non-compiled	[CE]  cannot  find  symbol  LmPar	9	None	add
333	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
334	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
335	[BUG]  [BUGGY]  if(paru  >  0.0)  {  int  paru  >  0.0)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  int  paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >    0.0)    {    int  paru  >  0.0)  {	  	non-compiled	[CE]  ';'  expected	104	None	add
336	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  if(paru  >=  0.0)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	63	None	replace
337	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(paru  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  if(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	63	None	replace
338	[BUG]  [BUGGY]  if(paru  <  0.0)  {  if(paru  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  <  0.0)  {  if(paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  <  0.0)  {  if(paru  >  0.0)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	63	None	replace
339	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	25	15	add
340	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	25	15	add
341	[BUG]  [BUGGY]  if(paramPar!=  null  &&  paru.equals(gNorm))  {  [CE]  cannot  find  symbol  paramPar  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paramPar!=  null  &&  paru.equals(gNorm))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paramPar!=  null  &&  paru.equals(gNorm))  {	  if(paru!=    null    &&    paru.equals(gNorm))    {    	non-compiled	[CE]  cannot  find  symbol  paramPar	127	None	replace
342	[BUG]  [BUGGY]  if(paru  ==  null  &&  paru.equals(gNorm))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                      AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  null  &&  paru.equals(gNorm))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  null  &&  paru.equals(gNorm))  {	  if(paru!=    null    &&    paru.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	127	None	replace
343	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  paru  =  Math.min(2.2252e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  paru  =  Math.min(2.2252e-3,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  paru  =  Math.min(2.2252e-3,  0.001  *  paru);	          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	31	None	replace
344	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  paru  =  Math.min(2.2252e-38,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  paru  =  Math.min(2.2252e-38,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  paru  =  Math.min(2.2252e-38,  0.001  *  paru);	          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	31	None	replace
345	[BUG]  [BUGGY]  if(solveCols!=  null  &&  paru.length  >  1)  {  [CE]  cannot  find  symbol  solveCols  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols!=  null  &&  paru.length  >  1)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols!=  null  &&  paru.length  >  1)  {	  if(paru!=    null    &&    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	126	None	replace
346	[BUG]  [BUGGY]  if(solvedCols!=  null  &&  paru.length  >  0)  {  [CE]  incomparable  types:  int  and  <null>  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols!=  null  &&  paru.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols!=  null  &&  paru.length  >  0)  {	  if(paru!=    null    &&    solveCols)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	126	None	replace
347	[BUG]  [BUGGY]  if(solveCols!=  null  &&  paru.length()  >  0)  {  [CE]  cannot  find  symbol  solveCols  [FE]                      AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols!=  null  &&  paru.length()  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols!=  null  &&  paru.length()  >  0)  {	  if(paru!=    null    &&    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	126	None	replace
348	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown  +  2);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown  +  2);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru,  countdown  +  2);	  double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru,    countdown);    	non-compiled	[CE]  class,  interface,  or  enum  expected	62	None	replace
349	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  gNorm));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  gNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  gNorm));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    gNorm));    	non-compiled	[CE]  class,  interface,  or  enum  expected	92	None	replace
350	[BUG]  [BUGGY]  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	107	None	replace
351	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.252e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	107	None	replace
352	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  Paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [CE]  cannot  find  symbol  Paru  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  Paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    Paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	non-compiled	[CE]  cannot  find  symbol  Paru	116	None	add
353	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [CE]  cannot  find  symbol  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	non-compiled	[CE]  cannot  find  symbol	116	None	add
354	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    paru  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	15	add
355	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  paru  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    paru  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	15	add
356	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(paru  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  0.0)  {  if(paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {  if(paru  >  0.0)  {	  if(paru    ==    0.0)    {    if(paru    >=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	64	None	replace
357	[BUG]  [BUGGY]  if(lmPar  ==  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	69	None	replace
358	[BUG]  [BUGGY]  if(countdown  >  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(countdown  >  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(countdown  >  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	69	None	replace
359	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }  else  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  ==  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }  else  {	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	compilable	  [FE]  AssertionFailedError  	69	12	replace
360	[BUG]  [BUGGY]  if(lmPar  ==  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }  else  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }  else  {  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  0)  {  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  }  else  {	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	compilable	  [FE]  AssertionFailedError  	69	12	replace
361	[BUG]  [BUGGY]  if(solvedCols  ==  null  ||  solveCols.length  ==  0)  {  [CE]  incomparable  types:  int  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols  ==  null  ||  solveCols.length  ==  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols  ==  null  ||  solveCols.length  ==  0)  {	  if(solvedCols    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	95	None	replace
362	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	74	15	add
363	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	74	15	add
364	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	15	add
365	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	12	15	add
366	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	71	None	replace
367	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	71	None	replace
368	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	71	None	replace
369	[BUG]  [BUGGY]  if(paru  ==  null  ||  paru.length  <  2  ||  solveCols)  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  null  ||  paru.length  <  2  ||  solveCols)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  null  ||  paru.length  <  2  ||  solveCols)  {	  if(paru    ==    null    ||    paru.length    <    2)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	118	None	replace
370	[BUG]  [BUGGY]  if(paru!=  null  ||  paru.length  <  2)  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru!=  null  ||  paru.length  <  2)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru!=  null  ||  paru.length  <  2)  {	  if(paru    ==    null    ||    paru.length    <    2)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	118	None	replace
371	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  gNorm);  [CE]  ')'  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  gNorm);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  gNorm);	  double    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	61	None	replace
372	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru);  [CE]  ')'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru);	  double    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	61	None	replace
373	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-0,  0.001  *  paru);  [CE]  ')'  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-0,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(paru,  Math.max(2.2251e-0,  0.001  *  paru);	  double    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	61	None	replace
374	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));	  Double    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	20	None	replace
375	[BUG]  [BUGGY]  Double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  gNorm));  [CE]  class,  interface,  or  enum  expected  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  gNorm));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  solvedCols  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  gNorm));	  Double    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	20	None	replace
376	[BUG]  [BUGGY]  if(lmPar  ==  null  ||  paru.length  <  2  ||  lmPar.length  >  0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null  ||  paru.length  <  2  ||  lmPar.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null  ||  paru.length  <  2  ||  lmPar.length  >  0)  {	  if(lmPar    ==    null    ||    paru.length    <    2)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	108	None	replace
377	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  if(lmPar  >=  0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  if(lmPar  >=  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  lmPar)  {  if(lmPar  >=  0)  {	  if(lmPar    ==    paru)    {    if(lmPar    >=    paru)    {    	non-compiled	[CE]  illegal  start  of  expression	36	None	replace
378	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  if(lmPar  >=  null)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  if(lmPar  >=  null)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  lmPar)  {  if(lmPar  >=  null)  {	  if(lmPar    ==    paru)    {    if(lmPar    >=    paru)    {    	non-compiled	[CE]  illegal  start  of  expression	36	None	replace
379	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  if(lmPar  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  if(lmPar  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  lmPar)  {  if(lmPar  >=  0.0)  {	  if(lmPar    ==    paru)    {    if(lmPar    >=    paru)    {    	non-compiled	[CE]  illegal  start  of  expression	36	None	replace
380	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  20)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  >  20)  {	  if(paru    >    255)    {    if(paru    >    254)    {    	compilable	  [FE]  AssertionFailedError  	112	3	replace
381	[BUG]  [BUGGY]  if(paru  >  20)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  20)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  20)  {	  if(paru    >    255)    {    if(paru    >    254)    {    	compilable	  [FE]  AssertionFailedError  	112	3	replace
382	[BUG]  [BUGGY]  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  LmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	LmPar  =  Math.min(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    LmPar    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	11	None	replace
383	[BUG]  [BUGGY]  if(solveCols  ==  null  ||  paru.length  >  0)  {  [CE]  cannot  find  symbol  solveCols  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols  ==  null  ||  paru.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols  ==  null  ||  paru.length  >  0)  {	  if(paru    ==    null    ||    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	96	None	replace
384	[BUG]  [BUGGY]  if(paru  >  257)  {  int  paru  >  257)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  257)  {  int  paru  >  257)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >    257)    {    int  paru  >  257)  {	  	non-compiled	[CE]  ';'  expected	55	None	add
385	[BUG]  [BUGGY]  if(paru  >  257)  {  paru  >  257)  {  [CE]  not  a  statement  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  257)  {  paru  >  257)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >    257)    {    paru  >  257)  {	  	non-compiled	[CE]  not  a  statement	55	None	add
386	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	73	None	replace
387	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(param  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(param  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  if(param  ==  0.0)  {	  if(paru    ==    0.0)    {    if(param    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	110	None	replace
388	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(param  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  0.0)  {  if(param  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {  if(param  >  0.0)  {	  if(paru    ==    0.0)    {    if(param    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	110	None	replace
389	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(param  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(param  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  if(param  >=  0.0)  {	  if(paru    ==    0.0)    {    if(param    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	110	None	replace
390	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(param  <  0.0)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  0.0)  {  if(param  <  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  0.0)  {  if(param  <  0.0)  {	  if(paru    ==    0.0)    {    if(param    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	110	None	replace
391	[BUG]  [BUGGY]  if(paru!=  null  &&  paru  >  0.0)  {  [CE]  incomparable  types:  double  and  <null>  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru!=  null  &&  paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru!=  null  &&  paru  >  0.0)  {	  if(lmPar!=    null    &&    paru    >    0.0)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	120	None	replace
392	[BUG]  [BUGGY]  if(lmPar!=  null  &&  paru  <  =  0.0)  {  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  null  &&  paru  <  =  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=  null  &&  paru  <  =  0.0)  {	  if(lmPar!=    null    &&    paru    >    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	120	None	replace
393	[BUG]  [BUGGY]  if(solvedCols!=  null  ||  solveCols.length  ==  0)  {  [CE]  incomparable  types:  int  and  <null>  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols!=  null  ||  solveCols.length  ==  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols!=  null  ||  solveCols.length  ==  0)  {	  if(solvedCols!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	109	None	replace
394	[BUG]  [BUGGY]  if(paru  >  255)  {  int  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  255)  {  int  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  255)  {  int  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  if(paru    >    255)    {    int    paru    >    255)    {    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	111	None	replace
395	[BUG]  [BUGGY]  if(paru  >  255)  {  int  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  255)  {  int  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  255)  {  int  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  if(paru    >    255)    {    int    paru    >    255)    {    	non-compiled	[CE]  variable  paru  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	111	None	replace
396	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >=  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  >=  255)  {	  if(lmPar    >    255)    {    	compilable	  [FE]  AssertionFailedError  	54	2	replace
397	[BUG]  [BUGGY]  if(lmPar  >=  255)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >=  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  >=  255)  {	  if(lmPar    >    255)    {    	compilable	  [FE]  AssertionFailedError  	54	2	replace
398	[BUG]  [BUGGY]  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	72	None	replace
399	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2251e-38,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2251e-38,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2251e-38,.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	84	None	replace
400	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  0));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  0));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(lmPar,  0));	  lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  class,  interface,  or  enum  expected	6	None	replace
401	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl)-  1);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(lmPar,  parl)-  1);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(lmPar,  parl)-  1);	  lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  class,  interface,  or  enum  expected	6	None	replace
402	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  parl));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  parl));	  double    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	17	None	replace
403	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));	  double    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	17	None	replace
404	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  307)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  >  307)  {	  if(paru    >    255)    {    if(parau    >    255)    {    	compilable	  [FE]  AssertionFailedError  	45	2	replace
405	[BUG]  [BUGGY]  if(paru  >  307)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  307)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  307)  {	  if(paru    >    255)    {    if(parau    >    255)    {    	compilable	  [FE]  AssertionFailedError  	45	2	replace
406	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  if(parau  ==  lmPar)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  if(parau  ==  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    ==    lmPar)    {    if(parau  ==  lmPar)  {	  	non-compiled	[CE]  illegal  start  of  expression	38	None	add
407	[BUG]  [BUGGY]  if(paru!=  null)  {  if(lmPar  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru!=  null)  {  if(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru!=  null)  {  if(lmPar  ==  0.0)  {	  if(lmPar    ==    0.0)    {    if(lmPar!=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	47	None	replace
408	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  if(lmPar!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >=  0.0)  {  if(lmPar!=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >=  0.0)  {  if(lmPar!=  0.0)  {	  if(lmPar    ==    0.0)    {    if(lmPar!=    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	47	None	replace
409	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  cannot  find  symbol  Paru  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	non-compiled	[CE]  cannot  find  symbol  Paru	68	None	add
410	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	68	2	add
411	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	68	2	add
412	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	77	15	add
413	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	77	15	add
414	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  2.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  >  2.0)  {	  if(paru    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	105	4	replace
415	[BUG]  [BUGGY]  if(paru  >  2.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  2.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  2.0)  {	  if(paru    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	105	4	replace
416	[BUG]  [BUGGY]  if(lmPar  <  0.0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  0.0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    <    0.0)    {    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	2	None	add
417	[BUG]  [BUGGY]  if(lmPar  <  0.0)  {  lmPar  =  Math.max(2.2251e-308,  0.001)  *  paru);  [CE]  ';'  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  0.0)  {  lmPar  =  Math.max(2.2251e-308,  0.001)  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    <    0.0)    {    lmPar  =  Math.max(2.2251e-308,  0.001)  *  paru);	  	non-compiled	[CE]  ';'  expected	2	None	add
418	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  If(paru  >=  0.0)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >=  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru    >=    0.0)    {    If(paru  >=  0.0)  {	  	non-compiled	[CE]  ';'  expected	23	None	add
419	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  >  lmPar)  {	  if(paru    ==    lmPar)    {    	compilable	  [FE]  AssertionFailedError  	39	9	replace
420	[BUG]  [BUGGY]  if(paru  >  lmPar)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  lmPar)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  lmPar)  {	  if(paru    ==    lmPar)    {    	compilable	  [FE]  AssertionFailedError  	39	9	replace
421	[BUG]  [BUGGY]  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	LmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  if(lmPar    ==    0.0)    {    lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	99	None	replace
422	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	93	15	add
423	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	93	15	add
424	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	93	15	add
425	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    paru  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	93	15	add
426	[BUG]  [BUGGY]  if(param  <  0.0)  {  If(param  >  0.0)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(param  <  0.0)  {  If(param  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(param  <  0.0)  {  If(param  >  0.0)  {	  if(lmPar    ==    0.0)    {    If(lmPar    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	49	None	replace
427	[BUG]  [BUGGY]  if(param  <  0.0)  {  If(param  ==  0.0)  {  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(param  <  0.0)  {  If(param  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(param  <  0.0)  {  If(param  ==  0.0)  {	  if(lmPar    ==    0.0)    {    If(lmPar    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	49	None	replace
428	[BUG]  [BUGGY]  if(paru  ==  null)  {  If(lmPar  ==  0.0)  {  [CE]  ';'  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  null)  {  If(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  null)  {  If(lmPar  ==  0.0)  {	  if(lmPar    ==    0.0)    {    If(lmPar    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	49	None	replace
429	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-38,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-38,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2252e-38,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	117	None	replace
430	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  cannot  find  symbol  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	non-compiled	[CE]  cannot  find  symbol	70	None	add
431	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  cannot  find  symbol  Paru  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	non-compiled	[CE]  cannot  find  symbol  Paru	70	None	add
432	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	70	15	add
433	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	70	15	add
434	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(parau  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(parau  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  if(parau  >=  0.0)  {	  if(paru    ==    0.0)    {    if(parau    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	123	None	replace
435	[BUG]  [BUGGY]  if(paru  <  =  0.0)  {  if(parau  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  <  =  0.0)  {  if(parau  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  <  =  0.0)  {  if(parau  ==  0.0)  {	  if(paru    ==    0.0)    {    if(parau    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	123	None	replace
436	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(parau  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  if(parau  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  if(parau  ==  0.0)  {	  if(paru    ==    0.0)    {    if(parau    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	123	None	replace
437	[BUG]  [BUGGY]  if(paru  >  20)  {  If(paru  >  20)  {  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  20)  {  If(paru  >  20)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  20)  {  If(paru  >  20)  {	  if(paru    >    255)    {    If(paru    >    255)    {    	non-compiled	[CE]  ';'  expected	44	None	replace
438	[BUG]  [BUGGY]  if(paru  >  307)  {  If(paru  >  305)  {  [CE]  ';'  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  307)  {  If(paru  >  305)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  307)  {  If(paru  >  305)  {	  if(paru    >    255)    {    If(paru    >    255)    {    	non-compiled	[CE]  ';'  expected	44	None	replace
439	[BUG]  [BUGGY]  if(paru  >  307)  {  If(paru  >  307)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  307)  {  If(paru  >  307)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  307)  {  If(paru  >  307)  {	  if(paru    >    255)    {    If(paru    >    255)    {    	non-compiled	[CE]  ';'  expected	44	None	replace
440	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-38,  0.001  *  parl));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-38,  0.001  *  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-38,  0.001  *  parl));	  double    solvedCols    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	18	None	replace
441	[BUG]  [BUGGY]  if(lmPar  <  =  0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  =  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  =  0)  {	  if(lmPar    ==    paru)    {    if(lmPar    ==    paru)    {    	non-compiled	[CE]  illegal  start  of  expression	34	None	replace
442	[BUG]  [BUGGY]  if(lmPar  >  255)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  >  255)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar    >    255)    {    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);	  	non-compiled	[CE]  illegal  start  of  expression	53	None	add
443	[BUG]  [BUGGY]  if(solvesCols  ==  null  ||  solveCols  >  0)  {  [CE]  cannot  find  symbol  solvesCols  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvesCols  ==  null  ||  solveCols  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvesCols  ==  null  ||  solveCols  >  0)  {	  if(paru    ==    null    ||    solveCols    >    0)    {    	non-compiled	[CE]  cannot  find  symbol  solvesCols	119	None	replace
444	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);  paru  =  Math.min(2.2251e-38,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);  paru  =  Math.min(2.2251e-38,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);  paru  =  Math.min(2.2251e-38,  0.001  *  paru);	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	80	None	replace
445	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);  paru  =  Math.min(2.2251e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);  paru  =  Math.min(2.2251e-3,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);  paru  =  Math.min(2.2251e-3,  0.001  *  paru);	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	80	None	replace
446	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
447	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
448	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
449	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    paru  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
450	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-0,  0.001  *  lmPar));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-0,  0.001  *  lmPar));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2251e-0,  0.001  *  lmPar));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    lmPar));    	non-compiled	[CE]  class,  interface,  or  enum  expected	50	None	replace
451	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.max(2.2251e-308,  0.001  *  paru  +  1);	  lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	32	None	replace
452	[BUG]  [BUGGY]  lmPar  =  Math.max(2.2251e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.max(2.2251e-3,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.max(2.2251e-3,  0.001  *  paru);	  lmPar    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	32	None	replace
453	[BUG]  [BUGGY]  float  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  float  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	float  solvedCols  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  paru));	  float    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	113	None	replace
454	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  countdown));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  countdown));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.0e-308,  0.001  *  countdown));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    countdown));    	non-compiled	[CE]  class,  interface,  or  enum  expected	52	None	replace
455	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.1e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.1e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.1e-308,  0.001  *  paru));	  paru    =    Math.min(paru,    Math.max(2.0,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	51	None	replace
456	[BUG]  [BUGGY]  if(paru  ==  lmPar)  {  if(lmPar!=  null)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  lmPar)  {  if(lmPar!=  null)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  lmPar)  {  if(lmPar!=  null)  {	  if(lmPar    ==    paru)    {    if(lmPar!=    paru)    {    	non-compiled	[CE]  illegal  start  of  expression	35	None	replace
457	[BUG]  [BUGGY]  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru    =    Math.min(2.251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	107	None	replace
458	[BUG]  [BUGGY]  if(lmPar  <  =  MAXIMUM_PER_SIZE)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  =  MAXIMUM_PER_SIZE)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  =  MAXIMUM_PER_SIZE)  {	  if(lmPar    <    =    paru)    {    	non-compiled	[CE]  illegal  start  of  expression	40	None	replace
459	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru));  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	non-compiled	[CE]  ';'  expected	68	None	add
460	[BUG]  [BUGGY]  if(paru  >  0.0)  {  If(lmPar  ==  0.0)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  If(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  If(lmPar  ==  0.0)  {	  if(lmPar    ==    0.0)    {    If(lmPar    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	49	None	replace
461	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  If(lmPar  ==  0.0)  {  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >=  0.0)  {  If(lmPar  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >=  0.0)  {  If(lmPar  ==  0.0)  {	  if(lmPar    ==    0.0)    {    If(lmPar    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	49	None	replace
462	[BUG]  [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-3,  0.001  *  paru);  [CE]  ')'  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(paru,  Math.max(2.2251e-3,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(paru,  Math.max(2.2251e-3,  0.001  *  paru);	  double    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	61	None	replace
463	[BUG]  [BUGGY]  if(paru  >  0.0)  {  If(paru  >=  0.0)  {  [CE]  ';'  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0)  {  If(paru  >=  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	66	None	replace
464	[BUG]  [BUGGY]  if(paru  <  0.0)  {  If(paru  ==  0.0)  {  [CE]  ';'  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  <  0.0)  {  If(paru  ==  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  <  0.0)  {  If(paru  ==  0.0)  {	  if(paru    ==    0.0)    {    If(paru    ==    0.0)    {    	non-compiled	[CE]  ';'  expected	66	None	replace
465	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	70	15	add
466	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	70	15	add
467	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	77	15	add
468	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	77	15	add
469	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  >  paru)  {	  if(paru    ==    lmPar)    {    	compilable	  [FE]  AssertionFailedError  	39	2	replace
470	[BUG]  [BUGGY]  if(paru  >  paru)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  paru)  {	  if(paru    ==    lmPar)    {    	compilable	  [FE]  AssertionFailedError  	39	2	replace
471	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	116	15	add
472	[BUG]  [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                paru        =        Math.min(paru,        Math.max(2.2251e-308,        0.001        *        paru));        lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  	compilable	  [FE]  AssertionFailedError  	116	15	add
473	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        paru    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	30	15	add
474	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    paru  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        paru    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  paru  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	30	15	add
475	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-3,  0.001));  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-3,  0.001));  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2251e-3,  0.001));	  paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001));    	non-compiled	[CE]  class,  interface,  or  enum  expected	33	None	replace
476	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
477	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
478	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
479	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
480	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
481	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.253e-308,  0.001  *  paru);  lmPar  =  Math.min(2.253e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	9	15	add
482	[BUG]  [BUGGY]  if(parau  >  255)  {  [CE]  cannot  find  symbol  parau  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(parau  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(parau  >  255)  {	  if(paru    >    255)    {    if(parau    >    255)    {    	non-compiled	[CE]  cannot  find  symbol  parau	45	None	replace
483	[BUG]  [BUGGY]  short  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  short  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	short  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  long    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	103	None	replace
484	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	93	15	add
485	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,.001    *    paru);    lmPar  =  Math.min(2.2251e-308,.001  *  paru);  lmPar  =  Math.min(2.2251e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	93	15	add
486	[BUG]  [BUGGY]  if(solvedCols  ==  null  ||  solvedCols.length  <  2)  {  [CE]  incomparable  types:  int  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols  ==  null  ||  solvedCols.length  <  2)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols  ==  null  ||  solvedCols.length  <  2)  {	  if(solvedCols    ==    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	95	None	replace
487	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  0.001)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  ==  0.001)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.001)    {    	compilable	  [FE]  AssertionFailedError  	124	2	replace
488	[BUG]  [BUGGY]  if(lmPar  ==  0.001)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  0.001)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  0.001)  {	  if(paru    ==    0.0)    {    if(paru    ==    0.001)    {    	compilable	  [FE]  AssertionFailedError  	124	2	replace
489	[BUG]  [BUGGY]  if(lmPar!=  paru)  {  If(lmPar!=  paru)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  paru)  {  If(lmPar!=  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=    paru)    {    If(lmPar!=  paru)  {	  	non-compiled	[CE]  ';'  expected	101	None	add
490	[BUG]  [BUGGY]  LmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  LmPar  =  Math.min(2.2252e-3,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	LmPar  =  Math.min(2.2252e-3,  0.001  *  paru);	          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    LmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	27	None	replace
491	[BUG]  [BUGGY]  if(paru  ==  null  ||  paru.length  <  2  ||  paru.length  >  4)  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  ==  null  ||  paru.length  <  2  ||  paru.length  >  4)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  ==  null  ||  paru.length  <  2  ||  paru.length  >  4)  {	  if(paru    ==    null    ||    paru.length    <    2)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	118	None	replace
492	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-3,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-3,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(paru,  Math.max(2.2252e-3,  0.001  *  paru));	  double    solvedCols    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	18	None	replace
493	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	15	add
494	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	14	15	add
495	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0  ||  paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  >  0.0  ||  paru  >  0.0)  {	  if(paru    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	105	12	replace
496	[BUG]  [BUGGY]  if(paru  >  0.0  ||  paru  >  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0  ||  paru  >  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0  ||  paru  >  0.0)  {	  if(paru    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	105	12	replace
497	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0  ||  paru  >  1.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  >  0.0  ||  paru  >  1.0)  {	  if(paru    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	105	12	replace
498	[BUG]  [BUGGY]  if(paru  >  0.0  ||  paru  >  1.0)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  0.0  ||  paru  >  1.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  0.0  ||  paru  >  1.0)  {	  if(paru    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	105	12	replace
499	[BUG]  [BUGGY]  if(lmPar  ==  null  ||  paru.equals(param))  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null  ||  paru.equals(param))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null  ||  paru.equals(param))  {	  if(paru    ==    null    ||    paru.equals(lmPar))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	86	None	replace
500	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	84	None	replace
501	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	25	15	add
502	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	25	15	add
503	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-38,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-38,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	25	15	add
504	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-38,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-38,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-38,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	25	15	add
505	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  2)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  <  2)  {	  if(lmPar    ==    paru)    {    if(lmPar    >=    paru)    {    	compilable	  [FE]  AssertionFailedError  	36	11	replace
506	[BUG]  [BUGGY]  if(lmPar  <  2)  {  [FE]  AssertionFailedError  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  2)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  2)  {	  if(lmPar    ==    paru)    {    if(lmPar    >=    paru)    {    	compilable	  [FE]  AssertionFailedError  	36	11	replace
507	[BUG]  [BUGGY]  lmPar  =  Math.min(2.25,  Math.max(lmPar,  parl));  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(2.25,  Math.max(lmPar,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(2.25,  Math.max(lmPar,  parl));	          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar    =    Math.min(2.2251e-308,.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	94	None	replace
508	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  2  ||  lmPar  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar  <  2  ||  lmPar  >  255)  {	  if(lmPar    >    255)    {    	compilable	  [FE]  AssertionFailedError  	54	11	replace
509	[BUG]  [BUGGY]  if(lmPar  <  2  ||  lmPar  >  255)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  2  ||  lmPar  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  2  ||  lmPar  >  255)  {	  if(lmPar    >    255)    {    	compilable	  [FE]  AssertionFailedError  	54	11	replace
510	[BUG]  [BUGGY]  if(param!=  null  &&  paru.length  >  0)  {  [CE]  cannot  find  symbol  param  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(param!=  null  &&  paru.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(param!=  null  &&  paru.length  >  0)  {	  if(paru!=    null    &&    paru.length    >    0)    {    	non-compiled	[CE]  cannot  find  symbol  param	125	None	replace
511	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2262e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2262e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2262e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	117	None	replace
512	[BUG]  [BUGGY]  double  solvedCols  =  Math.max(2.0,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.max(2.0,  0.001  *  paru);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.max(2.0,  0.001  *  paru);	  double    solvedCols    =    Math.max(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	97	None	replace
513	[BUG]  [BUGGY]  if(paru!=  null  &&  paru.equals(dxNorm))  {  [CE]  incomparable  types:  double  and  <null>  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru!=  null  &&  paru.equals(dxNorm))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru!=  null  &&  paru.equals(dxNorm))  {	  if(paru!=    null    &&    paru.equals(gNorm))    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	127	None	replace
514	[BUG]  [BUGGY]  if(paru  <  =  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  <  =  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  <  =  0.0)  {	  if(paru    ==    0.0)    {    if(parau    ==    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	123	None	replace
515	[BUG]  [BUGGY]  double  lmPar  =  Math.min(2.2252e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  lmPar  =  Math.min(2.2252e-408,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  lmPar  =  Math.min(2.2252e-408,  0.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-408,    0.001    *    paru);    	non-compiled	[CE]  floating  point  number  too  small	85	None	replace
516	[BUG]  [BUGGY]  Double  lmPar  =  Math.min(2.2251e-408,  0.001  *  paru);  [CE]  floating  point  number  too  small  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  lmPar  =  Math.min(2.2251e-408,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  lmPar  =  Math.min(2.2251e-408,  0.001  *  paru);	          double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    double    lmPar    =    Math.min(2.2251e-408,    0.001    *    paru);    	non-compiled	[CE]  floating  point  number  too  small	85	None	replace
517	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  254)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  >  254)  {	  if(paru    >    255)    {    if(paru    >    254)    {    	compilable	  [FE]  AssertionFailedError  	112	2	replace
518	[BUG]  [BUGGY]  if(paru  >  254)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  254)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  254)  {	  if(paru    >    255)    {    if(paru    >    254)    {    	compilable	  [FE]  AssertionFailedError  	112	2	replace
519	[BUG]  [BUGGY]  if(lmPar  ==  null  ||  paru.length  <  2  ||  paru.length  >  4)  {  [CE]  incomparable  types:  double  and  <null>  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  ==  null  ||  paru.length  <  2  ||  paru.length  >  4)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  ==  null  ||  paru.length  <  2  ||  paru.length  >  4)  {	  if(lmPar    ==    null    ||    paru.length    <    2)    {    	non-compiled	[CE]  incomparable  types:  double  and  <null>	108	None	replace
520	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  <  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(paru  <  0.0)  {	  if(lmPar    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	3	2	replace
521	[BUG]  [BUGGY]  if(paru  <  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  <  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  <  0.0)  {	  if(lmPar    <    0.0)    {    	compilable	  [FE]  AssertionFailedError  	3	2	replace
522	[BUG]  [BUGGY]  if(solvedCols!=  null  &&  solvedCols.length  >  0)  {  [CE]  incomparable  types:  int  and  <null>  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols!=  null  &&  solvedCols.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols!=  null  &&  solvedCols.length  >  0)  {	  if(solvedCols!=    null)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	109	None	replace
523	[BUG]  [BUGGY]  if(paru  >  20)  {  If(paru  >  255)  {  [CE]  ';'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(paru  >  20)  {  If(paru  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(paru  >  20)  {  If(paru  >  255)  {	  if(paru    >    255)    {    If(paru    >    255)    {    	non-compiled	[CE]  ';'  expected	44	None	replace
524	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2251e-38,  0.001  *  paru));  Paru  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	72	None	replace
525	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-3,  0.001  *  paru);  [CE]  ')'  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-3,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2252e-3,  0.001  *  paru);	  lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	67	None	replace
526	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  lmPar);  [CE]  ')'  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  lmPar);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  lmPar);	  lmPar    =    Math.min(paru,    Math.max(2.2252e-308,    0.001    *    paru);    	non-compiled	[CE]  ')'  expected	67	None	replace
527	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2  *  parl,  parl));  [CE]  class,  interface,  or  enum  expected  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2  *  parl,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2  *  parl,  parl));	  lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  class,  interface,  or  enum  expected	6	None	replace
528	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1  *  parl,  parl));  [CE]  class,  interface,  or  enum  expected  [FE]          AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1  *  parl,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(1  *  parl,  parl));	  lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  class,  interface,  or  enum  expected	6	None	replace
529	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1.0,  parl));  [CE]  class,  interface,  or  enum  expected  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(1.0,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(1.0,  parl));	  lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  class,  interface,  or  enum  expected	6	None	replace
530	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(pr,  parl));  [CE]  class,  interface,  or  enum  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(pr,  parl));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(pr,  parl));	  lmPar    =    Math.min(paru,    Math.max(lmPar,    parl));    	non-compiled	[CE]  class,  interface,  or  enum  expected	6	None	replace
531	[BUG]  [BUGGY]  if(solvedCols  ==  null  ||  solveCols)  {  [CE]  incomparable  types:  int  and  <null>  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols  ==  null  ||  solveCols)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols  ==  null  ||  solveCols)  {	  if(paru    ==    null    ||    solveCols)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	96	None	replace
532	[BUG]  [BUGGY]  if(solvedCols  ==  null  ||  paru.length  >  0)  {  [CE]  incomparable  types:  int  and  <null>  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols  ==  null  ||  paru.length  >  0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols  ==  null  ||  paru.length  >  0)  {	  if(paru    ==    null    ||    solveCols)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	96	None	replace
533	[BUG]  [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  par  [CE]  ')'  expected  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  par  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  Paru  lmPar  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  par	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    Paru    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  ')'  expected	73	None	replace
534	[BUG]  [BUGGY]  if(solvedCols!=  null  &&  paru)  {  [CE]  incomparable  types:  int  and  <null>  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solvedCols!=  null  &&  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solvedCols!=  null  &&  paru)  {	  if(paru!=    null    &&    solveCols)    {    	non-compiled	[CE]  incomparable  types:  int  and  <null>	126	None	replace
535	[BUG]  [BUGGY]  if(solveCols!=  null  &&  paru.type  ==  Token.NAME)  {  [CE]  cannot  find  symbol  solveCols  [FE]                    AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(solveCols!=  null  &&  paru.type  ==  Token.NAME)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(solveCols!=  null  &&  paru.type  ==  Token.NAME)  {	  if(paru!=    null    &&    solveCols)    {    	non-compiled	[CE]  cannot  find  symbol  solveCols	126	None	replace
536	[BUG]  [BUGGY]  if(lmPar  <  =  paru)  {  If(lmPar  ==  paru)  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  =  paru)  {  If(lmPar  ==  paru)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  =  paru)  {  If(lmPar  ==  paru)  {	  if(lmPar    ==    paru)    {    If(lmPar    ==    paru)    {    	non-compiled	[CE]  illegal  start  of  expression	37	None	replace
537	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  parl)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	if(lmPar!=  parl)  {	  if(lmPar    ==    parl)    {    	compilable	  [FE]  AssertionFailedError  	42	11	replace
538	[BUG]  [BUGGY]  if(lmPar!=  parl)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  parl)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=  parl)  {	  if(lmPar    ==    parl)    {    	compilable	  [FE]  AssertionFailedError  	42	11	replace
539	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
540	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    lmPar  =  Math.max(2.2252e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
541	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-38,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    lmPar  =  Math.min(2.2252e-38,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
542	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-38,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2252e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2252e-308,.001  *  paru);  lmPar  =  Math.min(2.2252e-38,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2252e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2252e-308,.001    *    paru);    lmPar  =  Math.min(2.2252e-38,  0.001  *  paru);  lmPar  =  Math.min(2.2252e-308,.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	28	15	add
543	[BUG]  [BUGGY]  if(param  <  0.0)  {  [CE]  cannot  find  symbol  param  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(param  <  0.0)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(param  <  0.0)  {	  if(paru    ==    0.0)    {    if(param    ==    0.0)    {    	non-compiled	[CE]  cannot  find  symbol  param	110	None	replace
544	[BUG]  [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2251e-3,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  lmPar  =  Math.min(paru,  Math.max(2.2251e-3,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	lmPar  =  Math.min(paru,  Math.max(2.2251e-3,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    lmPar    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	71	None	replace
545	[BUG]  [BUGGY]  int  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  int  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	int  solvedCols  =  Math.min(paru,  Math.max(2.2252e-308,  0.001  *  paru));	  long    solvedCols    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	19	None	replace
546	[BUG]  [BUGGY]  Double  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  lmPar  =  Math.min(2.2251e-3,  0.001  *  paru);	  Double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	60	None	replace
547	[BUG]  [BUGGY]  Double  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Double  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Double  lmPar  =  Math.min(2.2252e-308,  0.001  *  paru);	  Double    lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	60	None	replace
548	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	106	15	add
549	[BUG]  [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.251e-308,    0.001    *    paru);    paru  =  Math.min(2.251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.251e-308,        0.001        *        paru);        paru    =    Math.min(2.251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.251e-308,  0.001  *  paru);  paru  =  Math.min(2.251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	106	15	add
550	[BUG]  [BUGGY]  Parser  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [CE]  class,  interface,  or  enum  expected  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  Parser  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	Parser  paru  =  Math.min(paru,  Math.max(2.2251e-308,  0.001  *  paru));	          paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    paru    =    Math.min(paru,    Math.max(2.2251e-308,    0.001    *    paru));    	non-compiled	[CE]  class,  interface,  or  enum  expected	69	None	replace
551	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	74	15	add
552	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	74	15	add
553	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	add	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	79	15	add
554	[BUG]  [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]          lmPar    =    Math.min(2.2251e-308,    0.001    *    paru);    paru  =  Math.min(2.2251e-308,  0.001  *  paru);  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);  [BUGGY]      if  (lmPar  ==  0)  {  lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	                lmPar        =        Math.min(2.2251e-308,        0.001        *        paru);        paru    =    Math.min(2.2251e-308,    0.001    *    paru);    lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  paru  =  Math.min(2.2251e-308,  0.001  *  paru);	  	compilable	  [FE]  AssertionFailedError  	79	15	add
555	[BUG]  [BUGGY]  double  solvedCols  =  Math.min(2.2251e-308,  0.001  *  lmPar);  [CE]  class,  interface,  or  enum  expected  [FE]                  AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  double  solvedCols  =  Math.min(2.2251e-308,  0.001  *  lmPar);  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	double  solvedCols  =  Math.min(2.2251e-308,  0.001  *  lmPar);	  double    solvedCols    =    Math.min(2.2251e-308,    0.001    *    paru);    	non-compiled	[CE]  class,  interface,  or  enum  expected	98	None	replace
556	[BUG]  [BUGGY]  if(lmPar!=  null  &&  paru  <  =  Math.max(2.2251e-308,  0.001  *  paru))  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  null  &&  paru  <  =  Math.max(2.2251e-308,  0.001  *  paru))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=  null  &&  paru  <  =  Math.max(2.2251e-308,  0.001  *  paru))  {	  if(lmPar    >=    null)    {    	non-compiled	[CE]  illegal  start  of  expression	16	None	replace
557	[BUG]  [BUGGY]  if(lmPar!=  null  &&  paru  <  =  Math.min(2.2251e-308,  0.001  *  paru))  {  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar!=  null  &&  paru  <  =  Math.min(2.2251e-308,  0.001  *  paru))  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar!=  null  &&  paru  <  =  Math.min(2.2251e-308,  0.001  *  paru))  {	  if(lmPar    >=    null)    {    	non-compiled	[CE]  illegal  start  of  expression	16	None	replace
558	[BUG]  [BUGGY]  if(lmPar  <  =  0.0  ||  paru  >  255)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError      [CONTEXT]        lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  for  (int  countdown  =  10;  countdown  >=  0;  --countdown)  {        [BUGGY]  if(lmPar  <  =  0.0  ||  paru  >  255)  {  [BUGGY]      lmPar  =  Math.max(2.2251e-308,  0.001  *  paru);  }  double  sPar  =  Math.sqrt(lmPar);  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];  work1[pj]  =  sPar  *  diag[pj];  }  determineLMDirection(qy,  work1,  work2,  work3);  dxNorm  =  0;  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	576	576	2	replace	if(lmPar  <  =  0.0  ||  paru  >  255)  {	  if(lmPar    <    =    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	1	None	replace
