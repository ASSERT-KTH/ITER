bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  double  sum  =  2;  double  sum  =  2;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  2;  double  sum  =  2;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    2;    double  sum  =  2;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	add
2	[BUG]  [BUGGY]  double  sum  =  2;  Double  sum  =  2;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  2;  Double  sum  =  2;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    2;    Double  sum  =  2;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	add
3	[BUG]  [BUGGY]  double  sum  =  2;  int  sum  =  2;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  2;  int  sum  =  2;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    2;    int  sum  =  2;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	add
4	[BUG]  [BUGGY]  double  sum  =  2;  long  sum  =  2;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  2;  long  sum  =  2;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    2;    long  sum  =  2;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	5	None	add
5	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
6	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
7	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
8	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  q	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
9	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
10	[BUG]  [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
11	[BUG]  [BUGGY]  if(pj  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(pj  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(pj  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  q	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
12	[BUG]  [BUGGY]  sum2  +=  work1[pj]  *  qy[pj];  [CE]  cannot  find  symbol  sum  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  sum2  +=  work1[pj]  *  qy[pj];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	sum2  +=  work1[pj]  *  qy[pj];	      double[]    diag    =    work1[pj];    sum2    +=    diag[pj]    *    qy[pj];    	non-compiled	[CE]  cannot  find  symbol  sum	10	None	replace
13	[BUG]  [BUGGY]  sum2  +=  diag[pj]  *  qy[pj];  [CE]  cannot  find  symbol  sum  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  sum2  +=  diag[pj]  *  qy[pj];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	sum2  +=  diag[pj]  *  qy[pj];	      double[]    diag    =    work1[pj];    sum2    +=    diag[pj]    *    qy[pj];    	non-compiled	[CE]  cannot  find  symbol  sum	10	None	replace
14	[BUG]  [BUGGY]  double[]  diag  =  work1[pj];  sum2  +=  work3[pj]  *  qy[pj];  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag  =  work1[pj];  sum2  +=  work3[pj]  *  qy[pj];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag  =  work1[pj];  sum2  +=  work3[pj]  *  qy[pj];	      double[]    diag    =    work1[pj];    sum2    +=    diag[pj]    *    qy[pj];    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	replace
15	[BUG]  [BUGGY]  double  sum  =  0.0;  double  sum  =  0.0;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  0.0;  double  sum  =  0.0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    0.0;    double  sum  =  0.0;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	13	None	add
16	[BUG]  [BUGGY]  double  sum  =  0.0;  Double  sum  =  0.0;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  0.0;  Double  sum  =  0.0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    0.0;    Double  sum  =  0.0;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	13	None	add
17	[BUG]  [BUGGY]  double  sum  =  0.0;  int  sum  =  0.0;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  0.0;  int  sum  =  0.0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    0.0;    int  sum  =  0.0;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	13	None	add
18	[BUG]  [BUGGY]  double  sum  =  0.0;  long  sum  =  0.0;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  0.0;  long  sum  =  0.0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    0.0;    long  sum  =  0.0;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	13	None	add
19	[BUG]  [BUGGY]  double  pj  =  permutation[j].doubleValue()  +  1;  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  permutation[j].doubleValue()  +  1;  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  permutation[j].doubleValue()  +  1;	      double    pj    =    permutation[j].doubleValue();    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	replace
20	[BUG]  [BUGGY]  double  pj  =  permutation[j].doubleValue()  +  2;  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  permutation[j].doubleValue()  +  2;  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  permutation[j].doubleValue()  +  2;	      double    pj    =    permutation[j].doubleValue();    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	replace
21	[BUG]  [BUGGY]  double  pj  =  parl[j].doubleValue();  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  parl[j].doubleValue();  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  parl[j].doubleValue();	      double    pj    =    permutation[j].doubleValue();    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	replace
22	[BUG]  [BUGGY]  double[]  diag[pj]  =  work3[pj];  sum2  +=  diag[pj]  *  s;  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag[pj]  =  work3[pj];  sum2  +=  diag[pj]  *  s;  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag[pj]  =  work3[pj];  sum2  +=  diag[pj]  *  s;	      double[]    diag[pj]    =    work1[pj];    sum2    +=    diag[pj]    *    s;    	non-compiled	[CE]  ']'  expected	11	None	replace
23	[BUG]  [BUGGY]  double[]  diag[pj]  =  s;  sum2  +=  diag[pj]  *  work3;  [CE]  ']'  expected  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag[pj]  =  s;  sum2  +=  diag[pj]  *  work3;  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag[pj]  =  s;  sum2  +=  diag[pj]  *  work3;	      double[]    diag[pj]    =    work1[pj];    sum2    +=    diag[pj]    *    s;    	non-compiled	[CE]  ']'  expected	11	None	replace
24	[BUG]  [BUGGY]  double[]  diag[pj]  =  work1[pj];  sum2  +=  diag[pj]  *  parl;  [CE]  ']'  expected  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag[pj]  =  work1[pj];  sum2  +=  diag[pj]  *  parl;  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag[pj]  =  work1[pj];  sum2  +=  diag[pj]  *  parl;	      double[]    diag[pj]    =    work1[pj];    sum2    +=    diag[pj]    *    s;    	non-compiled	[CE]  ']'  expected	11	None	replace
25	[BUG]  [BUGGY]  double  j  =  Math.sqrt(work1[j]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(work1[j]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(work1[j]);	      double    j    =    Math.sqrt(pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	19	None	replace
26	[BUG]  [BUGGY]  double  j  =  Math.sqrt(diag[j]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(diag[j]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(diag[j]);	      double    j    =    Math.sqrt(pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	19	None	replace
27	[BUG]  [BUGGY]  double  j  =  Math.sqrt(parl);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(parl);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(parl);	      double    j    =    Math.sqrt(pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	19	None	replace
28	[BUG]  [BUGGY]  double  j  =  Math.sqrt(work1);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(work1);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(work1);	      double    j    =    Math.sqrt(pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	19	None	replace
29	[BUG]  [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  q	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i]    	non-compiled	[CE]  illegal  start  of  expression	21	None	replace
30	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(sum2);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =  Math.sqrt(sum2);	  double    sum    =    Math.sqrt(pj);    	compilable	  [FE]  AssertionFailedError  	4	3	replace
31	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(sum2);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(sum2);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =  Math.sqrt(sum2);	  double    sum    =    Math.sqrt(pj);    	compilable	  [FE]  AssertionFailedError  	4	3	replace
32	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(work1[pj]);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =  Math.sqrt(work1[pj]);	  double    sum    =    Math.sqrt(pj);    	compilable	  [FE]  AssertionFailedError  	4	15	replace
33	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(work1[pj]);  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(work1[pj]);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =  Math.sqrt(work1[pj]);	  double    sum    =    Math.sqrt(pj);    	compilable	  [FE]  AssertionFailedError  	4	15	replace
34	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(work1);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(work1);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =  Math.sqrt(work1);	  double    sum    =    Math.sqrt(pj);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	4	None	replace
35	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(work1[j]);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =  Math.sqrt(work1[j]);	  double    sum    =    Math.sqrt(pj);    	compilable	  [FE]  AssertionFailedError  	4	15	replace
36	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(work1[j]);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(work1[j]);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =  Math.sqrt(work1[j]);	  double    sum    =    Math.sqrt(pj);    	compilable	  [FE]  AssertionFailedError  	4	15	replace
37	[BUG]  [BUGGY]  double[]  diag[pj]  =  work1[pj];  sum2  +=  diag[pj]  *  qy[0];  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag[pj]  =  work1[pj];  sum2  +=  diag[pj]  *  qy[0];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag[pj]  =  work1[pj];  sum2  +=  diag[pj]  *  qy[0];	      double[]    diag[pj]    =    work1[pj];    sum2    +=    diag[pj]    *    qy[pj];    	non-compiled	[CE]  ']'  expected	9	None	replace
38	[BUG]  [BUGGY]  double  sum  :  0;  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  :  0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  :  0;	  double    sum    =    2;    	non-compiled	[CE]  ';'  expected	6	None	replace
39	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1.0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =  1.0;	  double    sum    =    0.0;    	compilable	  [FE]  AssertionFailedError  	14	3	replace
40	[BUG]  [BUGGY]  double  sum  =  1.0;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1.0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =  1.0;	  double    sum    =    0.0;    	compilable	  [FE]  AssertionFailedError  	14	3	replace
41	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  10.0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =  10.0;	  double    sum    =    0.0;    	compilable	  [FE]  AssertionFailedError  	14	3	replace
42	[BUG]  [BUGGY]  double  sum  =  10.0;  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  10.0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =  10.0;	  double    sum    =    0.0;    	compilable	  [FE]  AssertionFailedError  	14	3	replace
43	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  <  0)?  0  :  pj;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =(pj  <  0)?  0  :  pj;	  double    sum    =(pj    <    =    0)?    0    :    pj;    	compilable	  [FE]  AssertionFailedError  	25	3	replace
44	[BUG]  [BUGGY]  double  sum  =(pj  <  0)?  0  :  pj;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  <  0)?  0  :  pj;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =(pj  <  0)?  0  :  pj;	  double    sum    =(pj    <    =    0)?    0    :    pj;    	compilable	  [FE]  AssertionFailedError  	25	3	replace
45	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  ==  0)?  0  :  pj;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =(pj  ==  0)?  0  :  pj;	  double    sum    =(pj    <    =    0)?    0    :    pj;    	compilable	  [FE]  AssertionFailedError  	25	3	replace
46	[BUG]  [BUGGY]  double  sum  =(pj  ==  0)?  0  :  pj;  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  ==  0)?  0  :  pj;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =(pj  ==  0)?  0  :  pj;	  double    sum    =(pj    <    =    0)?    0    :    pj;    	compilable	  [FE]  AssertionFailedError  	25	3	replace
47	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  >=  0)?  0  :  pj;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =(pj  >=  0)?  0  :  pj;	  double    sum    =(pj    <    =    0)?    0    :    pj;    	compilable	  [FE]  AssertionFailedError  	25	2	replace
48	[BUG]  [BUGGY]  double  sum  =(pj  >=  0)?  0  :  pj;  [FE]  AssertionFailedError  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  >=  0)?  0  :  pj;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =(pj  >=  0)?  0  :  pj;	  double    sum    =(pj    <    =    0)?    0    :    pj;    	compilable	  [FE]  AssertionFailedError  	25	2	replace
49	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  <  1)?  0  :  pj;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =(pj  <  1)?  0  :  pj;	  double    sum    =(pj    <    =    0)?    0    :    pj;    	compilable	  [FE]  AssertionFailedError  	25	3	replace
50	[BUG]  [BUGGY]  double  sum  =(pj  <  1)?  0  :  pj;  [FE]  AssertionFailedError  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  <  1)?  0  :  pj;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =(pj  <  1)?  0  :  pj;	  double    sum    =(pj    <    =    0)?    0    :    pj;    	compilable	  [FE]  AssertionFailedError  	25	3	replace
51	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(pj);  double  sum  =  Math.sqrt(pj);  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(pj);  double  sum  =  Math.sqrt(pj);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    Math.sqrt(pj);    double  sum  =  Math.sqrt(pj);	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
52	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(pj);  Double  sum  =  Math.sqrt(pj);  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(pj);  Double  sum  =  Math.sqrt(pj);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    Math.sqrt(pj);    Double  sum  =  Math.sqrt(pj);	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
53	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(pj);  int  sum  =  Math.sqrt(pj);  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(pj);  int  sum  =  Math.sqrt(pj);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    Math.sqrt(pj);    int  sum  =  Math.sqrt(pj);	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
54	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(pj);  double  Sum  =  Math.sqrt(pj);  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(pj);  double  Sum  =  Math.sqrt(pj);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    Math.sqrt(pj);    double  Sum  =  Math.sqrt(pj);	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
55	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  3;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =  3;	  double    sum    =    1;    	compilable	  [FE]  AssertionFailedError  	2	3	replace
56	[BUG]  [BUGGY]  double  sum  =  3;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  3;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =  3;	  double    sum    =    1;    	compilable	  [FE]  AssertionFailedError  	2	3	replace
57	[BUG]  [BUGGY]  double  sum  =  1;  double  sum  =  1;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1;  double  sum  =  1;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    1;    double  sum  =  1;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	add
58	[BUG]  [BUGGY]  double  sum  =  1;  Double  sum  =  1;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1;  Double  sum  =  1;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    1;    Double  sum  =  1;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	add
59	[BUG]  [BUGGY]  double  sum  =  1;  int  sum  =  1;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1;  int  sum  =  1;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    1;    int  sum  =  1;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	add
60	[BUG]  [BUGGY]  double  sum  =  1;  long  sum  =  1;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1;  long  sum  =  1;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    1;    long  sum  =  1;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	add
61	[BUG]  [BUGGY]  double  j  =  Math.sqrt(diag[pj]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(diag[pj]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(diag[pj]);	      double    j    =    Math.sqrt(solvedCols[pj]);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
62	[BUG]  [BUGGY]  double  j  =  Math.sqrt(solvedCols[j]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(solvedCols[j]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(solvedCols[j]);	      double    j    =    Math.sqrt(solvedCols[pj]);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
63	[BUG]  [BUGGY]  double  j  =  Math.sqrt(work1[pj]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(work1[pj]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(work1[pj]);	      double    j    =    Math.sqrt(solvedCols[pj]);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
64	[BUG]  [BUGGY]  double  j  =  Math.sqrt(solvedCols[0]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(solvedCols[0]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(solvedCols[0]);	      double    j    =    Math.sqrt(solvedCols[pj]);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
65	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  work1[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  work1[i][pj]  *  qy[  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  work1[i][pj]  *  qy[	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	22	None	replace
66	[BUG]  [BUGGY]  int  j  =  permutation[j];  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  int  j  =  permutation[j];  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	int  j  =  permutation[j];	      	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	7	None	replace
67	[BUG]  [BUGGY]  int  j  =  permutation[j].doubleValue();  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  int  j  =  permutation[j].doubleValue();  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	int  j  =  permutation[j].doubleValue();	      	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	7	None	replace
68	[BUG]  [BUGGY]  int  i  =  solvedCols.length;  [CE]  int  cannot  be  dereferenced  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  int  i  =  solvedCols.length;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	int  i  =  solvedCols.length;	      	non-compiled	[CE]  int  cannot  be  dereferenced	7	None	replace
69	[BUG]  [BUGGY]  Math.sqrt(pj);  [CE]  cannot  find  symbol  sum  [FE]                    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  Math.sqrt(pj);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	Math.sqrt(pj);	      	non-compiled	[CE]  cannot  find  symbol  sum	7	None	replace
70	[BUG]  [BUGGY]  double  tmp  =  Math.sqrt(work1,  work2);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  tmp  =  Math.sqrt(work1,  work2);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  tmp  =  Math.sqrt(work1,  work2);	      double    tmp    =    Math.sqrt(work3);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	18	None	replace
71	[BUG]  [BUGGY]  double  tmp  =  Math.sqrt(work1,  work3);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  tmp  =  Math.sqrt(work1,  work3);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  tmp  =  Math.sqrt(work1,  work3);	      double    tmp    =    Math.sqrt(work3);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	18	None	replace
72	[BUG]  [BUGGY]  double  tmp  =  Math.sqrt(pj,  work3);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  tmp  =  Math.sqrt(pj,  work3);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  tmp  =  Math.sqrt(pj,  work3);	      double    tmp    =    Math.sqrt(work3);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	18	None	replace
73	[BUG]  [BUGGY]  double  tmp  =  Math.sqrt(work2,  work3);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  tmp  =  Math.sqrt(work2,  work3);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  tmp  =  Math.sqrt(work2,  work3);	      double    tmp    =    Math.sqrt(work3);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	18	None	replace
74	[BUG]  [BUGGY]  double  j  =  Math.sqrt(solvedCols,  pj);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(solvedCols,  pj);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(solvedCols,  pj);	      double    j    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
75	[BUG]  [BUGGY]  double  j  =  Math.sqrt(solvedCols,  parl);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(solvedCols,  parl);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(solvedCols,  parl);	      double    j    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
76	[BUG]  [BUGGY]  double  j  =  Math.sqrt(permutation[j]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(permutation[j]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(permutation[j]);	      double    j    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
77	[BUG]  [BUGGY]  double  j  =  Math.min(solvedCols,  parl);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.min(solvedCols,  parl);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.min(solvedCols,  parl);	      double    j    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
78	[BUG]  [BUGGY]  double  j  =  Math.min(solvedCols,  pj,  parl);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.min(solvedCols,  pj,  parl);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.min(solvedCols,  pj,  parl);	      double    j    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
79	[BUG]  [BUGGY]  double  j  =  Math.min(diag[j],  solvedCols);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.min(diag[j],  solvedCols);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.min(diag[j],  solvedCols);	      double    j    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
80	[BUG]  [BUGGY]  double  j  =  Math.min(solvedCols,  pj,  permutation[j]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.min(solvedCols,  pj,  permutation[j]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.min(solvedCols,  pj,  permutation[j]);	      double    j    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
81	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    k;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	24	None	replace
82	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    k;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	24	None	replace
83	[BUG]  [BUGGY]  if(pj  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]                    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(pj  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(pj  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    k;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	24	None	replace
84	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]                      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    k;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	24	None	replace
85	[BUG]  [BUGGY]  double  pj  =  work1[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  work1[j];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  work1[j];	      double    pj    =    permutation[j];    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	replace
86	[BUG]  [BUGGY]  double  pj  =  parl[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  parl[j];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  parl[j];	      double    pj    =    permutation[j];    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	replace
87	[BUG]  [BUGGY]  double  pj  =  work1.length;  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  work1.length;  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  work1.length;	      double    pj    =    permutation[j];    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	replace
88	[BUG]  [BUGGY]  double  pj  =  work2[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  work2[j];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  work2[j];	      double    pj    =    permutation[j];    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	replace
89	[BUG]  [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
90	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  work1[i]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(j  >  0)  {  sum  +=  work1[i]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(j  >  0)  {  sum  +=  work1[i]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
91	[BUG]  [BUGGY]  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  work1[i][pj]  *  qy[i];  }	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
92	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  work1[i]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(j  >  0)  {  sum  +=  work1[i]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(j  >  0)  {  sum  +=  work1[i]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
93	[BUG]  [BUGGY]  double  j  =  Math.min(diag,  solvedCols);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.min(diag,  solvedCols);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.min(diag,  solvedCols);	      double    j    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
94	[BUG]  [BUGGY]  double  j  =  Math.min(solvedCols,  sum2);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.min(solvedCols,  sum2);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.min(solvedCols,  sum2);	      double    j    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
95	[BUG]  [BUGGY]  double  j  =  Math.min(solvedCols,  pj  -  1);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.min(solvedCols,  pj  -  1);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.min(solvedCols,  pj  -  1);	      double    j    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
96	[BUG]  [BUGGY]  double  pj  =  solveCols[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  solveCols[j];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  solveCols[j];	      double    pj    =    permutation[j];    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	replace
97	[BUG]  [BUGGY]  double  pj  =  work3[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  work3[j];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  work3[j];	      double    pj    =    permutation[j];    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	replace
98	[BUG]  [BUGGY]  double  pj  =  permutation[j]  +  1;  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  permutation[j]  +  1;  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  permutation[j]  +  1;	      double    pj    =    permutation[j];    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	replace
99	[BUG]  [BUGGY]  double  sum  /=  2;  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  /=  2;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  /=  2;	  double    sum    =    2;    	non-compiled	[CE]  ';'  expected	6	None	replace
100	[BUG]  [BUGGY]  double[]  diag[pj]  =  work3[pj];  sum2  +=  diag[pj]  *  qy[pj];  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag[pj]  =  work3[pj];  sum2  +=  diag[pj]  *  qy[pj];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag[pj]  =  work3[pj];  sum2  +=  diag[pj]  *  qy[pj];	      double[]    diag[pj]    =    work1[pj];    sum2    +=    diag[pj]    *    qy[pj];    	non-compiled	[CE]  ']'  expected	9	None	replace
101	[BUG]  [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i]    	non-compiled	[CE]  illegal  start  of  expression	21	None	replace
102	[BUG]  [BUGGY]  if(work3  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(work3  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(work3  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i]    	non-compiled	[CE]  illegal  start  of  expression	21	None	replace
103	[BUG]  [BUGGY]  double[]  diag  =  work1[j];  sum2  +=  diag[pj]  *  qy[j];  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag  =  work1[j];  sum2  +=  diag[pj]  *  qy[j];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag  =  work1[j];  sum2  +=  diag[pj]  *  qy[j];	      double[]    diag    =    work1[pj];    sum2    +=    diag[pj]    *    qy[pj];    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	replace
104	[BUG]  [BUGGY]  double[]  diag  =  work1[pj];  sum2  +=  diag[pj]  *  qy[0];  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag  =  work1[pj];  sum2  +=  diag[pj]  *  qy[0];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag  =  work1[pj];  sum2  +=  diag[pj]  *  qy[0];	      double[]    diag    =    work1[pj];    sum2    +=    diag[pj]    *    qy[pj];    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	replace
105	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(work3);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(work3);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =  Math.sqrt(work3);	  double    sum    =    Math.sqrt(pj);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	4	None	replace
106	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(sum);  [CE]  variable  sum  might  not  have  been  initialized  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(sum);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =  Math.sqrt(sum);	  double    sum    =    Math.sqrt(pj);    	non-compiled	[CE]  variable  sum  might  not  have  been  initialized	4	None	replace
107	[BUG]  [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    k;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	24	None	replace
108	[BUG]  [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [CE]  illegal  start  of  expression  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(pj  <  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  q	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    k;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	24	None	replace
109	[BUG]  [BUGGY]  int  i  =  Math.min(solvedCols,  pj);  [CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  int  i  =  Math.min(solvedCols,  pj);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	int  i  =  Math.min(solvedCols,  pj);	      	non-compiled	[CE]  variable  i  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	7	None	replace
110	[BUG]  [BUGGY]  Math.sqrt(solvedCols,  pj);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  Math.sqrt(solvedCols,  pj);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	Math.sqrt(solvedCols,  pj);	      	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	7	None	replace
111	[BUG]  [BUGGY]  Math.sqrt(solvedCols[pj]);  [CE]  array  required,  but  int  found  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  Math.sqrt(solvedCols[pj]);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	Math.sqrt(solvedCols[pj]);	      	non-compiled	[CE]  array  required,  but  int  found	7	None	replace
112	[BUG]  [BUGGY]  int  i  =  Math.min(solvedCols,  solveCols);  [CE]  cannot  find  symbol  solveCols  [FE]                    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  int  i  =  Math.min(solvedCols,  solveCols);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	int  i  =  Math.min(solvedCols,  solveCols);	      	non-compiled	[CE]  cannot  find  symbol  solveCols	7	None	replace
113	[BUG]  [BUGGY]  double  j  =  Math.sqrt(solvedCols,  sum2);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(solvedCols,  sum2);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(solvedCols,  sum2);	      double    j    =    Math.sqrt(solvedCols);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	15	None	replace
114	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj!=  0)?  0  :  pj;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =(pj!=  0)?  0  :  pj;	  double    sum    =(pj    <    =    0)?    0    :    pj;    	compilable	  [FE]  AssertionFailedError  	25	2	replace
115	[BUG]  [BUGGY]  double  sum  =(pj!=  0)?  0  :  pj;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj!=  0)?  0  :  pj;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =(pj!=  0)?  0  :  pj;	  double    sum    =(pj    <    =    0)?    0    :    pj;    	compilable	  [FE]  AssertionFailedError  	25	2	replace
116	[BUG]  [BUGGY]  double[]  diag[pj]  =  work1[pj];  sum2  +=  diag[pj]  *  qy;  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag[pj]  =  work1[pj];  sum2  +=  diag[pj]  *  qy;  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag[pj]  =  work1[pj];  sum2  +=  diag[pj]  *  qy;	      double[]    diag[pj]    =    work1[pj];    sum2    +=    diag[pj]    *    s;    	non-compiled	[CE]  ']'  expected	11	None	replace
117	[BUG]  [BUGGY]  if(work3  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(work3  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(work3  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	22	None	replace
118	[BUG]  [BUGGY]  if(work3  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(work3  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  q  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(work3  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  q	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[    	non-compiled	[CE]  illegal  start  of  expression	22	None	replace
119	[BUG]  [BUGGY]  double  j  =  Math.sqrt(work3);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(work3);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(work3);	      double    j    =    Math.sqrt(pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	19	None	replace
120	[BUG]  [BUGGY]  double  sum  =  1  <  <  work3;  [CE]  >  expected  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1  <  <  work3;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =  1  <  <  work3;	  double    sum    =    1;    	non-compiled	[CE]  >  expected	2	None	replace
121	[BUG]  [BUGGY]  double  pj  =  solveCols[j].doubleValue();  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  solveCols[j].doubleValue();  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  solveCols[j].doubleValue();	      double    pj    =    permutation[j].doubleValue();    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	12	None	replace
122	[BUG]  [BUGGY]  double[]  diag[pj]  =  work1[pj];  sum2  +=  jacobian[pj]  *  qy[pj];  [CE]  ']'  expected  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag[pj]  =  work1[pj];  sum2  +=  jacobian[pj]  *  qy[pj];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag[pj]  =  work1[pj];  sum2  +=  jacobian[pj]  *  qy[pj];	      double[]    diag[pj]    =    work1[pj];    sum2    +=    diag[pj]    *    qy[pj];    	non-compiled	[CE]  ']'  expected	9	None	replace
123	[BUG]  [BUGGY]  double[]  diag[pj]  =  work1[0];  sum2  +=  diag[pj]  *  qy[0];  [CE]  ']'  expected  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag[pj]  =  work1[0];  sum2  +=  diag[pj]  *  qy[0];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag[pj]  =  work1[0];  sum2  +=  diag[pj]  *  qy[0];	      double[]    diag[pj]    =    work1[pj];    sum2    +=    diag[pj]    *    qy[pj];    	non-compiled	[CE]  ']'  expected	9	None	replace
124	[BUG]  [BUGGY]  double  pj  =  solvedCols[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  pj  =  solvedCols[j];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  pj  =  solvedCols[j];	      double    pj    =    permutation[j];    	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	8	None	replace
125	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  pj;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    pj;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	20	None	replace
126	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  <  0)?  0.0  :  0.0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =(pj  <  0)?  0.0  :  0.0;	  double    sum    =    0.0;    	compilable	  [FE]  AssertionFailedError  	14	2	replace
127	[BUG]  [BUGGY]  double  sum  =(pj  <  0)?  0.0  :  0.0;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  <  0)?  0.0  :  0.0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =(pj  <  0)?  0.0  :  0.0;	  double    sum    =    0.0;    	compilable	  [FE]  AssertionFailedError  	14	2	replace
128	[BUG]  [BUGGY]  double  j  =  Math.min(solvedCols,  solvedCols);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.min(solvedCols,  solvedCols);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.min(solvedCols,  solvedCols);	      double    j    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
129	[BUG]  [BUGGY]  double  j  =  Math.min(solvedCols,  pj  +  1);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.min(solvedCols,  pj  +  1);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.min(solvedCols,  pj  +  1);	      double    j    =    Math.min(solvedCols,    pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	16	None	replace
130	[BUG]  [BUGGY]  double  sum  =  0.0;  double  sum  =  0.00;  [CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  0.0;  double  sum  =  0.00;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    0.0;    double  sum  =  0.00;	  	non-compiled	[CE]  variable  sum  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	13	None	add
131	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  k;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    k;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	24	None	replace
132	[BUG]  [BUGGY]  int  qy  =  Math.sqrt(solvedCols);  [CE]  variable  qy  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  int  qy  =  Math.sqrt(solvedCols);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	int  qy  =  Math.sqrt(solvedCols);	      	non-compiled	[CE]  variable  qy  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	7	None	replace
133	[BUG]  [BUGGY]  int  qy  =  Math.sqrt(pj);  [CE]  variable  qy  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  int  qy  =  Math.sqrt(pj);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	int  qy  =  Math.sqrt(pj);	      	non-compiled	[CE]  variable  qy  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	7	None	replace
134	[BUG]  [BUGGY]  int  qy  =  Math.sqrt(parl);  [CE]  variable  qy  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                  AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  int  qy  =  Math.sqrt(parl);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	int  qy  =  Math.sqrt(parl);	      	non-compiled	[CE]  variable  qy  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	7	None	replace
135	[BUG]  [BUGGY]  double  tmp  =  Math.sqrt(work1);  [CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  tmp  =  Math.sqrt(work1);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  tmp  =  Math.sqrt(work1);	      double    tmp    =    Math.sqrt(work3);    	non-compiled	[CE]  method  sqrt  in  class  Math  cannot  be  applied  to  given  types;	18	None	replace
136	[BUG]  [BUGGY]  double  sum  =  1;  char  pj  =  permutation[j].doubleValue();  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1;  char  pj  =  permutation[j].doubleValue();  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    1;    char  pj  =  permutation[j].doubleValue();	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	add
137	[BUG]  [BUGGY]  double  sum  =  1;  char  pj  =  permutation[j];  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1;  char  pj  =  permutation[j];  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    1;    char  pj  =  permutation[j];	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	add
138	[BUG]  [BUGGY]  double  sum  =  1;  char  pj  =  permutation[j];  double  sum  =  1;  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1;  char  pj  =  permutation[j];  double  sum  =  1;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    1;    char  pj  =  permutation[j];  double  sum  =  1;	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	add
139	[BUG]  [BUGGY]  double  sum  =  1;  char  pj  =  permutation[j];  sum  =  1;  [CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]          AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  1;  char  pj  =  permutation[j];  sum  =  1;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    1;    char  pj  =  permutation[j];  sum  =  1;	  	non-compiled	[CE]  variable  pj  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	1	None	add
140	[BUG]  [BUGGY]  double[]  diag  =  work1[pj];  sum2  +=  jacobian[pj]  *  qy[pj];  [CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag  =  work1[pj];  sum2  +=  jacobian[pj]  *  qy[pj];  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag  =  work1[pj];  sum2  +=  jacobian[pj]  *  qy[pj];	      double[]    diag    =    work1[pj];    sum2    +=    diag[pj]    *    qy[pj];    	non-compiled	[CE]  variable  diag  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	10	None	replace
141	[BUG]  [BUGGY]  double[]  diag[pj]  =  s;  sum2  +=  diag[pj]  *  s;  [CE]  ']'  expected  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double[]  diag[pj]  =  s;  sum2  +=  diag[pj]  *  s;  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double[]  diag[pj]  =  s;  sum2  +=  diag[pj]  *  s;	      double[]    diag[pj]    =    work1[pj];    sum2    +=    diag[pj]    *    s;    	non-compiled	[CE]  ']'  expected	11	None	replace
142	[BUG]  [BUGGY]  double  j  =  Math.sqrt(work1.length[pj]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]            AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(work1.length[pj]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(work1.length[pj]);	      double    j    =    Math.sqrt(solvedCols[pj]);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
143	[BUG]  [BUGGY]  double  j  =  Math.sqrt(work2[pj]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(work2[pj]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(work2[pj]);	      double    j    =    Math.sqrt(solvedCols[pj]);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
144	[BUG]  [BUGGY]  double  j  =  Math.sqrt(work1.length,  work2.length);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(work1.length,  work2.length);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(work1.length,  work2.length);	      double    j    =    Math.sqrt(solvedCols[pj]);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	17	None	replace
145	[BUG]  [BUGGY]  double  j  =  Math.sqrt(work3[pj]);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  j  =  Math.sqrt(work3[pj]);  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  j  =  Math.sqrt(work3[pj]);	      double    j    =    Math.sqrt(pj);    	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	19	None	replace
146	[BUG]  [BUGGY]  double  sum  =  Math.sqrt(pj);  int  j  =  Math.sqrt(pj);  [CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =  Math.sqrt(pj);  int  j  =  Math.sqrt(pj);  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double    sum    =    Math.sqrt(pj);    int  j  =  Math.sqrt(pj);	  	non-compiled	[CE]  variable  j  is  already  defined  in  method  determineLMParameter(double[],double,double[],double[],double[],double[])	3	None	add
147	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]  [CE]  illegal  start  of  expression  [FE]              AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i]	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
148	[BUG]  [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [CE]  illegal  start  of  expression  [FE]                AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  [BUGGY]    double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	if(j  >  0)  {  sum  +=  work1[pj]  *  work2[pj];  }  else  {  for(int  i  =  0;  i  <  =  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }	      if(pj    >    0)    {    sum    +=    work1[pj]    *    work2[pj];    }    else    {    for(int    i    =    0;    i    <    =    j;    ++i)    {    sum    +=    jacobian[i][pj]    *    qy[i];    }    	non-compiled	[CE]  illegal  start  of  expression	23	None	replace
149	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  <  0)?  1  :  0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =(pj  <  0)?  1  :  0;	  double    sum    =    1;    	compilable	  [FE]  AssertionFailedError  	2	2	replace
150	[BUG]  [BUGGY]  double  sum  =(pj  <  0)?  1  :  0;  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  <  0)?  1  :  0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =(pj  <  0)?  1  :  0;	  double    sum    =    1;    	compilable	  [FE]  AssertionFailedError  	2	2	replace
151	[BUG]  [BUGGY]  double  sum  =(pj  <  =  0)?  1  :  0;  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  <  =  0)?  1  :  0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =(pj  <  =  0)?  1  :  0;	  double    sum    =    1;    	non-compiled	[CE]  illegal  start  of  expression	2	None	replace
152	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  >  0)?  1  :  0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	add	double  sum  =(pj  >  0)?  1  :  0;	  double    sum    =    1;    	compilable	  [FE]  AssertionFailedError  	2	3	replace
153	[BUG]  [BUGGY]  double  sum  =(pj  >  0)?  1  :  0;  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    work1[pj]  =  s;  sum2  +=  s  *  s;  }  parl  =  fp  /  (delta  *  sum2);  }  sum2  =  0;  for  (int  j  =  0;  j  <  solvedCols;  ++j)  {  int  pj  =  permutation[j];    [BUGGY]  double  sum  =(pj  >  0)?  1  :  0;  [BUGGY]    for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;  if  (paru  ==  0)  {  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	552	552	2	replace	double  sum  =(pj  >  0)?  1  :  0;	  double    sum    =    1;    	compilable	  [FE]  AssertionFailedError  	2	3	replace
