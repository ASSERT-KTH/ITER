bugid	buggy	buggy_class	suspiciousness	buggy_line	endbuggycode	original_failing_test_number	action	patch	original_buggy	execution_result	diagnosis	previous_bug_id	new_failing_test_number	this_action
1	[BUG]  [BUGGY]  paru  =  1.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  1.0  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.max(delta,  0.1);	      paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
2	[BUG]  [BUGGY]  paru  =  0.5  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  0.5  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.max(delta,  0.1);	      paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
3	[BUG]  [BUGGY]  paru  =  2.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  2.0  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.0  /  Math.max(delta,  0.1);	      paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
4	[BUG]  [BUGGY]  paru  =  0.2  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  0.2  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.2  /  Math.max(delta,  0.1);	      paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
5	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  >=  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  >=  0.0)  {	  if(paru    >=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	4	4	replace
6	[BUG]  [BUGGY]  if(delta  >=  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  >=  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >=  0.0)  {	  if(paru    >=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	4	4	replace
7	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  <  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  <  0.0)  {	  if(paru    >=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	4	2	replace
8	[BUG]  [BUGGY]  if(delta  <  0.0)  {  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  <  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  0.0)  {	  if(paru    >=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	4	2	replace
9	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  >  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  >  0.0)  {	  if(paru    >=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	4	4	replace
10	[BUG]  [BUGGY]  if(delta  >  0.0)  {  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  >  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >  0.0)  {	  if(paru    >=    0.0)    {    	compilable	  [FE]  AssertionFailedError  	4	4	replace
11	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >=  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >=    0.0)    {    if(paru  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
12	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  if(paru  >>  0.0)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >=  0.0)  {  if(paru  >>  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >=    0.0)    {    if(paru  >>  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
13	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  if(paru!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >=  0.0)  {  if(paru!=  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >=    0.0)    {    if(paru!=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
14	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  if(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >=  0.0)  {  if(paru  ==  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >=    0.0)    {    if(paru  ==  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	3	None	add
15	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  0.5);	      paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	13	None	replace
16	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(delta,  0.5);	      paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	13	None	replace
17	[BUG]  [BUGGY]  paru  =  2.0  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  2.0  /  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.0  /  Math.min(delta,  0.5);	      paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	13	None	replace
18	[BUG]  [BUGGY]  paru  =  0.2  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  0.2  /  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.2  /  Math.min(delta,  0.5);	      paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	13	None	replace
19	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	12	4	add
20	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	compilable	  [FE]  AssertionFailedError  	12	4	add
21	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  Paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [CE]  cannot  find  symbol  Paru  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  Paru  =  2.2251e-308  /  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    Paru  =  2.2251e-308  /  Math.min(delta,  0.5);	  	non-compiled	[CE]  cannot  find  symbol  Paru	12	None	add
22	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	12	4	add
23	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	12	4	add
24	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	12	4	add
25	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	12	4	add
26	[BUG]  [BUGGY]  Integer  parl  =  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  Integer  parl  =  Math.max(delta,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(delta,  0.0);	      Integer    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	17	None	replace
27	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  1.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  Integer  parl  =  Math.max(paru,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  1.0);	      Integer    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	17	None	replace
28	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  0.0,  sum);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  Integer  parl  =  Math.max(paru,  0.0,  sum);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  0.0,  sum);	      Integer    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	17	None	replace
29	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  2.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  Integer  parl  =  Math.max(paru,  2.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  2.0);	      Integer    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	17	None	replace
30	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  0.1));  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  0.1));  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.min(delta,  0.1));	      	non-compiled	[CE]  <identifier>  expected	5	None	replace
31	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  0.0));  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  0.0));  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.min(delta,  0.0));	      	non-compiled	[CE]  <identifier>  expected	5	None	replace
32	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(delta,  0.1));  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  Math.max(delta,  0.1));  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(delta,  0.1));	      	non-compiled	[CE]  <identifier>  expected	5	None	replace
33	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  1.0));  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  Math.min(delta,  1.0));  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.min(delta,  1.0));	      	non-compiled	[CE]  <identifier>  expected	5	None	replace
34	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
35	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
36	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [CE]  cannot  find  symbol  Paru  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  Paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    Paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	non-compiled	[CE]  cannot  find  symbol  Paru	6	None	add
37	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	6	4	add
38	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	6	4	add
39	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
40	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
41	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	10	4	add
42	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	10	4	add
43	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  Paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [CE]  cannot  find  symbol  Paru  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  Paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    Paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	non-compiled	[CE]  cannot  find  symbol  Paru	10	None	add
44	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	10	4	add
45	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	10	4	add
46	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	10	4	add
47	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  paru  =  2.2251e-308  /  Math.max(delta,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    paru  =  2.2251e-308  /  Math.max(delta,  0.0);	  	compilable	  [FE]  AssertionFailedError  	10	4	add
48	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  <  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  <  0.0)  {	  if(paru    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	25	2	replace
49	[BUG]  [BUGGY]  if(paru  <  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  <  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  <  0.0)  {	  if(paru    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	25	2	replace
50	[BUG]  [BUGGY]  int  parl  =  Math.min(paru,  0.1);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.min(paru,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(paru,  0.1);	      int    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	20	None	replace
51	[BUG]  [BUGGY]  int  parl  =  Math.min(paru,  0,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.min(paru,  0,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(paru,  0,  0.1);	      int    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	20	None	replace
52	[BUG]  [BUGGY]  double  parl  =  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.min(delta,  0.1);	      int    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	20	None	replace
53	[BUG]  [BUGGY]  int  parl  =  Math.min(paru,  1.0);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.min(paru,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(paru,  1.0);	      int    parl    =    Math.min(delta,    1.0);    	non-compiled	[CE]  <identifier>  expected	22	None	replace
54	[BUG]  [BUGGY]  double  parl  =  Math.min(delta,  1.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.min(delta,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.min(delta,  1.0);	      int    parl    =    Math.min(delta,    1.0);    	non-compiled	[CE]  <identifier>  expected	22	None	replace
55	[BUG]  [BUGGY]  int  parl  =  Math.min(param,  1.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.min(param,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(param,  1.0);	      int    parl    =    Math.min(delta,    1.0);    	non-compiled	[CE]  <identifier>  expected	22	None	replace
56	[BUG]  [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  1.0  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  1.0  /  Math.min(delta,  0.1);	      paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	7	None	replace
57	[BUG]  [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  0.5  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.5  /  Math.min(delta,  0.1);	      paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	7	None	replace
58	[BUG]  [BUGGY]  paru  =  2.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  2.0  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.0  /  Math.min(delta,  0.1);	      paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	7	None	replace
59	[BUG]  [BUGGY]  paru  =  0.2  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  0.2  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.2  /  Math.min(delta,  0.1);	      paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	7	None	replace
60	[BUG]  [BUGGY]  double  parl  =  permutation[0];  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  permutation[0];  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  permutation[0];	      int    parl    =    permutation[0];    	non-compiled	[CE]  <identifier>  expected	14	None	replace
61	[BUG]  [BUGGY]  int  parl  =  permutation[1];  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  permutation[1];  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[1];	      int    parl    =    permutation[0];    	non-compiled	[CE]  <identifier>  expected	14	None	replace
62	[BUG]  [BUGGY]  int  parl  =  permutation[0]  -  1;  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  permutation[0]  -  1;  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[0]  -  1;	      int    parl    =    permutation[0];    	non-compiled	[CE]  <identifier>  expected	14	None	replace
63	[BUG]  [BUGGY]  int  parl  =  permutation[0]  +  1;  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  permutation[0]  +  1;  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[0]  +  1;	      int    parl    =    permutation[0];    	non-compiled	[CE]  <identifier>  expected	14	None	replace
64	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  ==  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  ==  0.0)  {	  if(paru    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	2	2	replace
65	[BUG]  [BUGGY]  if(delta  ==  0.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  ==  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  ==  0.0)  {	  if(paru    ==    0.0)    {    	compilable	  [FE]  AssertionFailedError  	2	2	replace
66	[BUG]  [BUGGY]  if(delta  <  =  0.0)  {  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  <  =  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  =  0.0)  {	  if(paru    <    =    0.0)    {    	non-compiled	[CE]  illegal  start  of  expression	19	None	replace
67	[BUG]  [BUGGY]  int  parl  =  Math.max(paru,  0.0);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.max(paru,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(paru,  0.0);	      int    parl    =    Math.max(parl,    0.0);    	non-compiled	[CE]  <identifier>  expected	16	None	replace
68	[BUG]  [BUGGY]  int  parl  =  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.max(delta,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(delta,  0.0);	      int    parl    =    Math.max(parl,    0.0);    	non-compiled	[CE]  <identifier>  expected	16	None	replace
69	[BUG]  [BUGGY]  int  parl  =  Math.max(param,  0.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.max(param,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(param,  0.0);	      int    parl    =    Math.max(parl,    0.0);    	non-compiled	[CE]  <identifier>  expected	16	None	replace
70	[BUG]  [BUGGY]  int  parl  =  Math.max(permutation,  0.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.max(permutation,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(permutation,  0.0);	      int    parl    =    Math.max(parl,    0.0);    	non-compiled	[CE]  <identifier>  expected	16	None	replace
71	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  <  0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  <  0)  {	  if(paru    <    =    0)    {    	compilable	  [FE]  AssertionFailedError  	26	2	replace
72	[BUG]  [BUGGY]  if(paru  <  0)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  <  0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  <  0)  {	  if(paru    <    =    0)    {    	compilable	  [FE]  AssertionFailedError  	26	2	replace
73	[BUG]  [BUGGY]  if(delta  <  =  0)  {  [CE]  illegal  start  of  expression  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  <  =  0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  <  =  0)  {	  if(paru    <    =    0)    {    	non-compiled	[CE]  illegal  start  of  expression	26	None	replace
74	[BUG]  [BUGGY]  double  paru  =  1.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  1.0  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  1.0  /  Math.min(delta,  0.1);	      double    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	8	None	replace
75	[BUG]  [BUGGY]  double  paru  =  0.5  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  0.5  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.5  /  Math.min(delta,  0.1);	      double    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	8	None	replace
76	[BUG]  [BUGGY]  double  paru  =  2.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  2.0  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.0  /  Math.min(delta,  0.1);	      double    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	8	None	replace
77	[BUG]  [BUGGY]  double  paru  =  0.2  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  0.2  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2  /  Math.min(delta,  0.1);	      double    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	8	None	replace
78	[BUG]  [BUGGY]  if(paru  >  0.0)  {  if(paru  >  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >  0.0)  {  if(paru  >  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0.0)    {    if(paru  >  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	24	None	add
79	[BUG]  [BUGGY]  if(paru  >  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0.0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	non-compiled	[CE]  illegal  start  of  expression	24	None	add
80	[BUG]  [BUGGY]  if(paru  >  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0.0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	24	None	add
81	[BUG]  [BUGGY]  if(paru  >  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0.0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	non-compiled	[CE]  illegal  start  of  expression	24	None	add
82	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  work2),  sum);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  work2),  sum);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work1,  work2),  sum);	      double    parl    =    Math.max(paru,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	21	None	replace
83	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  work1));  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(work3,  Math.max(paru,  work1));  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(paru,  work1));	      double    parl    =    Math.max(paru,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	21	None	replace
84	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work1,  paru));  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work1,  paru));  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(work1,  paru));	      double    parl    =    Math.max(paru,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	21	None	replace
85	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work3,  work2));  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work3,  work2));  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work3,  work2));	      double    parl    =    Math.max(paru,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	21	None	replace
86	[BUG]  [BUGGY]  double  parl  =  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(delta,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(delta,  0.0);	      double    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	15	None	replace
87	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  1.0);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  1.0);	      double    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	15	None	replace
88	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  0.0,  sum);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  0.0,  sum);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  0.0,  sum);	      double    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	15	None	replace
89	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  2.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  2.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  2.0);	      double    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	15	None	replace
90	[BUG]  [BUGGY]  int  parl  =  Math.max(paru,  1.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.max(paru,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(paru,  1.0);	      int    parl    =    Math.max(parl,    1.0);    	non-compiled	[CE]  <identifier>  expected	23	None	replace
91	[BUG]  [BUGGY]  int  parl  =  Math.max(delta,  1.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.max(delta,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(delta,  1.0);	      int    parl    =    Math.max(parl,    1.0);    	non-compiled	[CE]  <identifier>  expected	23	None	replace
92	[BUG]  [BUGGY]  int  parl  =  Math.max(param,  1.0);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.max(param,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(param,  1.0);	      int    parl    =    Math.max(parl,    1.0);    	non-compiled	[CE]  <identifier>  expected	23	None	replace
93	[BUG]  [BUGGY]  int  parl  =  Math.max(permutation,  1.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.max(permutation,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(permutation,  1.0);	      int    parl    =    Math.max(parl,    1.0);    	non-compiled	[CE]  <identifier>  expected	23	None	replace
94	[BUG]  [BUGGY]  int  paru  =  Math.max(delta,  0.0);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  paru  =  Math.max(delta,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(delta,  0.0);	      int    paru    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	18	None	replace
95	[BUG]  [BUGGY]  int  paru  =  Math.max(paru,  0.0,  sum);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  paru  =  Math.max(paru,  0.0,  sum);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(paru,  0.0,  sum);	      int    paru    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	18	None	replace
96	[BUG]  [BUGGY]  int  paru  =  Math.max(paru,  1.0);  [CE]  <identifier>  expected  [FE]                    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  paru  =  Math.max(paru,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(paru,  1.0);	      int    paru    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	18	None	replace
97	[BUG]  [BUGGY]  double  paru  =  Math.max(paru,  0.0);  [CE]  <identifier>  expected  [FE]                      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  Math.max(paru,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  Math.max(paru,  0.0);	      int    paru    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	18	None	replace
98	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(paru  ==  0.0)  {  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  ==  0.0)  {  if(paru  ==  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    ==    0.0)    {    if(paru  ==  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
99	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(paru  >=  0.0)  {  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  ==  0.0)  {  if(paru  >=  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    ==    0.0)    {    if(paru  >=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
100	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  If(paru  ==  0.0)  {  [CE]  ';'  expected  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  ==  0.0)  {  If(paru  ==  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    ==    0.0)    {    If(paru  ==  0.0)  {	  	non-compiled	[CE]  ';'  expected	1	None	add
101	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  if(paru!=  0.0)  {  [CE]  illegal  start  of  expression  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  ==  0.0)  {  if(paru!=  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    ==    0.0)    {    if(paru!=  0.0)  {	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
102	[BUG]  [BUGGY]  double  paru  =  1.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  1.0  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  1.0  /  Math.max(delta,  0.1);	      double    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	9	None	replace
103	[BUG]  [BUGGY]  double  paru  =  0.5  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  0.5  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.5  /  Math.max(delta,  0.1);	      double    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	9	None	replace
104	[BUG]  [BUGGY]  double  paru  =  2.0  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  2.0  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  2.0  /  Math.max(delta,  0.1);	      double    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	9	None	replace
105	[BUG]  [BUGGY]  double  paru  =  0.2  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]                  AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  0.2  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2  /  Math.max(delta,  0.1);	      double    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	9	None	replace
106	[BUG]  [BUGGY]  paru  =  2.2e-308  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  2.2e-308  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.2e-308  /  Math.max(delta,  0.1);	      paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
107	[BUG]  [BUGGY]  paru  =  2.8  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  2.8  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.8  /  Math.max(delta,  0.1);	      paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
108	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >=  0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  >=  0)  {	  if(paru    <    =    0)    {    	compilable	  [FE]  AssertionFailedError  	26	4	replace
109	[BUG]  [BUGGY]  if(paru  >=  0)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >=  0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  >=  0)  {	  if(paru    <    =    0)    {    	compilable	  [FE]  AssertionFailedError  	26	4	replace
110	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  0.5);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  0.5);	      double    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	15	None	replace
111	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	12	4	add
112	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	12	4	add
113	[BUG]  [BUGGY]  int  parl  =  Math.max(params,  0.0);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.max(params,  0.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(params,  0.0);	      int    parl    =    Math.max(parl,    0.0);    	non-compiled	[CE]  <identifier>  expected	16	None	replace
114	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work1,  work2));  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work1,  work2));  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(work1,  work2));	      double    parl    =    Math.max(paru,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	21	None	replace
115	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work2,  work1));  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work2,  work1));  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work2,  work1));	      double    parl    =    Math.max(paru,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	21	None	replace
116	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    ==    0.0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
117	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);  [CE]  illegal  start  of  expression  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    ==    0.0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.0);	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
118	[BUG]  [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [CE]  illegal  start  of  expression  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  ==  0.0)  {  int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    ==    0.0)    {    int  paru  =  2.2251e-308  /  Math.min(delta,  0.2);	  	non-compiled	[CE]  illegal  start  of  expression	1	None	add
119	[BUG]  [BUGGY]  int  parl  =  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(delta,  0.5);	      int    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	20	None	replace
120	[BUG]  [BUGGY]  if(param  >  0.0)  {  [CE]  cannot  find  symbol  param  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(param  >  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(param  >  0.0)  {	  if(paru    >    0.0)    {    	non-compiled	[CE]  cannot  find  symbol  param	25	None	replace
121	[BUG]  [BUGGY]  int  paru  =  Math.max(paru,  0.5);  [CE]  <identifier>  expected  [FE]                AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  paru  =  Math.max(paru,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  paru  =  Math.max(paru,  0.5);	      int    paru    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	18	None	replace
122	[BUG]  [BUGGY]  if(paru  >  0.0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >  0.0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0.0)    {    paru  =  2.2251e-308  /  Math.min(delta,  0.1);	  	non-compiled	[CE]  illegal  start  of  expression	24	None	add
123	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	10	4	add
124	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	10	4	add
125	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	10	4	add
126	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.max(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.max(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	10	4	add
127	[BUG]  [BUGGY]  paru  =  2.2e-308  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  2.2e-308  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.2e-308  /  Math.min(delta,  0.1);	      paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	7	None	replace
128	[BUG]  [BUGGY]  paru  =  2.8  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  2.8  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.8  /  Math.min(delta,  0.1);	      paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	7	None	replace
129	[BUG]  [BUGGY]  int  parl  =  permutation[0]  &  1;  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  permutation[0]  &  1;  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  permutation[0]  &  1;	      int    parl    =    permutation[0];    	non-compiled	[CE]  <identifier>  expected	14	None	replace
130	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  0.1);  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  0.1);	      	non-compiled	[CE]  <identifier>  expected	5	None	replace
131	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	6	4	add
132	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	6	4	add
133	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	6	4	add
134	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [FE]  AssertionFailedError  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }  else  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }	  	compilable	  [FE]  AssertionFailedError  	6	4	add
135	[BUG]  [BUGGY]  paru  =  2.2e-308  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  2.2e-308  /  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.2e-308  /  Math.min(delta,  0.5);	      paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	13	None	replace
136	[BUG]  [BUGGY]  paru  =  0.2e-308  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  0.2e-308  /  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  0.2e-308  /  Math.min(delta,  0.5);	      paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	13	None	replace
137	[BUG]  [BUGGY]  int  parl  =  Math.max(params,  1.0);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.max(params,  1.0);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.max(params,  1.0);	      int    parl    =    Math.max(parl,    1.0);    	non-compiled	[CE]  <identifier>  expected	23	None	replace
138	[BUG]  [BUGGY]  if(paru  >=  0.0)  {  If(paru  >=  0.0)  {  [CE]  ';'  expected  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >=  0.0)  {  If(paru  >=  0.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >=    0.0)    {    If(paru  >=  0.0)  {	  	non-compiled	[CE]  ';'  expected	3	None	add
139	[BUG]  [BUGGY]  double  paru  =  0.2e-308  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  0.2e-308  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2e-308  /  Math.max(delta,  0.1);	      double    paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	9	None	replace
140	[BUG]  [BUGGY]  double  paru  =  0.2e-308  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  paru  =  0.2e-308  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  paru  =  0.2e-308  /  Math.min(delta,  0.1);	      double    paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	8	None	replace
141	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
142	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  paru  =  2.2252e-308  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.1);    paru  =  2.2252e-308  /  Math.min(delta,  0.1);	  	compilable	  [FE]  AssertionFailedError  	6	4	add
143	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(delta  >  0.0  ||  paru  >  1.0)  {	  if(paru    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	25	4	replace
144	[BUG]  [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(delta  >  0.0  ||  paru  >  1.0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(delta  >  0.0  ||  paru  >  1.0)  {	  if(paru    >    0.0)    {    	compilable	  [FE]  AssertionFailedError  	25	4	replace
145	[BUG]  [BUGGY]  int  parl  =  Math.min(params,  0.1);  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  Math.min(params,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  Math.min(params,  0.1);	      int    parl    =    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	20	None	replace
146	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >  0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	if(paru  >  0)  {	  if(paru    <    =    0)    {    	compilable	  [FE]  AssertionFailedError  	26	4	replace
147	[BUG]  [BUGGY]  if(paru  >  0)  {  [FE]  AssertionFailedError  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >  0)  {  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru  >  0)  {	  if(paru    <    =    0)    {    	compilable	  [FE]  AssertionFailedError  	26	4	replace
148	[BUG]  [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work1,  paru2));  [CE]  <identifier>  expected  [FE]          AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(work3,  Math.max(work1,  paru2));  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work3,  Math.max(work1,  paru2));	      double    parl    =    Math.max(paru,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	21	None	replace
149	[BUG]  [BUGGY]  double  parl  =  Math.max(work2,  Math.max(work1,  paru));  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(work2,  Math.max(work1,  paru));  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(work2,  Math.max(work1,  paru));	      double    parl    =    Math.max(paru,    Math.max(work1,    work2));    	non-compiled	[CE]  <identifier>  expected	21	None	replace
150	[BUG]  [BUGGY]  paru  =  4.0  /  Math.min(delta,  0.5);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  4.0  /  Math.min(delta,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  4.0  /  Math.min(delta,  0.5);	      paru    =    2.2251e-308    /    Math.min(delta,    0.5);    	non-compiled	[CE]  <identifier>  expected	13	None	replace
151	[BUG]  [BUGGY]  paru  =  2.3  /  Math.max(delta,  0.1);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  2.3  /  Math.max(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.3  /  Math.max(delta,  0.1);	      paru    =    2.2251e-308    /    Math.max(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	11	None	replace
152	[BUG]  [BUGGY]  Integer  parl  =  Math.max(paru,  0.5);  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  Integer  parl  =  Math.max(paru,  0.5);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	Integer  parl  =  Math.max(paru,  0.5);	      Integer    parl    =    Math.max(paru,    0.0);    	non-compiled	[CE]  <identifier>  expected	17	None	replace
153	[BUG]  [BUGGY]  if(paru  >  0.0)  {  int  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [CE]  illegal  start  of  expression  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  if(paru  >  0.0)  {  int  paru  =  2.2251e-308  /  Math.max(delta,  0.1);  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	if(paru    >    0.0)    {    int  paru  =  2.2251e-308  /  Math.max(delta,  0.1);	  	non-compiled	[CE]  illegal  start  of  expression	24	None	add
154	[BUG]  [BUGGY]  int  parl  =  diag[0];  [CE]  <identifier>  expected  [FE]        AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  int  parl  =  diag[0];  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	int  parl  =  diag[0];	      int    parl    =    permutation[0];    	non-compiled	[CE]  <identifier>  expected	14	None	replace
155	[BUG]  [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  parl));  [CE]  <identifier>  expected  [FE]            AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  parl  =  Math.max(paru,  Math.max(work1,  parl));  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  parl  =  Math.max(paru,  Math.max(work1,  parl));	      	non-compiled	[CE]  <identifier>  expected	5	None	replace
156	[BUG]  [BUGGY]  double  dxNorm  =  Math.max(paru,  Math.max(work1,  parl));  [CE]  <identifier>  expected  [FE]              AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  double  dxNorm  =  Math.max(paru,  Math.max(work1,  parl));  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	double  dxNorm  =  Math.max(paru,  Math.max(work1,  parl));	      	non-compiled	[CE]  <identifier>  expected	5	None	replace
157	[BUG]  [BUGGY]  paru  =  2.3  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  2.3  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  2.3  /  Math.min(delta,  0.1);	      paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	7	None	replace
158	[BUG]  [BUGGY]  paru  =  4.0  /  Math.min(delta,  0.1);  [CE]  <identifier>  expected  [FE]      AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]  paru  =  4.0  /  Math.min(delta,  0.1);  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	paru  =  4.0  /  Math.min(delta,  0.1);	      paru    =    2.2251e-308    /    Math.min(delta,    0.1);    	non-compiled	[CE]  <identifier>  expected	7	None	replace
159	[BUG]  [BUGGY]  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	add	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	12	4	add
160	[BUG]  [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  [FE]  AssertionFailedError  [FE]    AssertionFailedError    [CONTEXT]    int  pj  =  permutation[j];  double  sum  =  0;  for  (int  i  =  0;  i  <=  j;  ++i)  {  sum  +=  jacobian[i][pj]  *  qy[i];  }  sum  /=  diag[pj];  sum2  +=  sum  *  sum;  }  double  gNorm  =  Math.sqrt(sum2);  double  paru  =  gNorm  /  delta;    [BUGGY]      paru  =  2.2251e-308  /  Math.min(delta,  0.5);  if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }  [BUGGY]    if  (paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.1);  }    lmPar  =  Math.min(paru,  Math.max(lmPar,  parl));  if  (lmPar  ==  0)  {  lmPar  =  gNorm  /  dxNorm;  }  [CLASS]  LevenbergMarquardtOptimizer  [METHOD]  determineLMParameter  [RETURN_TYPE]  void  double[]  qy  double  delta  double[]  diag  double[]  work1  double[]  work2  double[]  work3  [VARIABLES]  int[]  permutation  boolean  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  qy  tmpVec  work1  work2  work3  double  actRed  coeff1  coeff2  correction  costRelativeTolerance  delta  dirDer  dirJ  dk  dxNorm  fp  gNorm  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  parl  paru  pc2  preRed  previousCost  previousFP  qrRankingThreshold  r  ratio  s  sPar  sum  sum2  threshold  tmp  xK  xNorm  xk  ypk  int  countdown  i  j  k  pj  pk  rank  solvedCols  	projects/Math64/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java	0.3651483716701107	561	561	2	replace	        paru    =    2.2251e-308    /    Math.min(delta,    0.5);    if(paru  ==  0)  {  paru  =  2.2251e-308  /  Math.min(delta,  0.5);  }  else  {  paru  =  22251e-308  /  Math.min(delta,  0.5);  }	  	compilable	  [FE]  AssertionFailedError  	12	4	add
